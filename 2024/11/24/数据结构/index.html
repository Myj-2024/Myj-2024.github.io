<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构 | 宇仔的小破站</title><meta name="author" content="宇仔"><meta name="copyright" content="宇仔"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="https://myj-2024.github.io/2024/11/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="宇仔的小破站">
<meta property="og:description" content="数据结构">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.picgo.net/2024/12/07/169_1_5b886d18-cb55-4030-8238-9c911a3b887dac464e01b8713ae4.png">
<meta property="article:published_time" content="2024-11-24T11:47:12.000Z">
<meta property="article:modified_time" content="2024-11-24T11:47:12.000Z">
<meta property="article:author" content="宇仔">
<meta property="article:tag" content="数据结构与算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.picgo.net/2024/12/07/169_1_5b886d18-cb55-4030-8238-9c911a3b887dac464e01b8713ae4.png"><link rel="shortcut icon" href="https://img.picgo.net/2024/12/07/08ef53c150f276baea908621b9ae5ff6f990343b25ce8b76.jpg"><link rel="canonical" href="https://myj-2024.github.io/2024/11/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html"><link rel="preconnect" href="//cdnjs.cloudflare.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.33/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdnjs.cloudflare.com/ajax/libs/egjs-infinitegrid/4.11.1/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-24 19:47:12'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/progress_bar.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/readPercent.css"><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><link rel="stylesheet" href="/css/universe.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="/css/progress_bar.css"/><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-zhuye1"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-youlian"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw iconfont icon-liuyanmoban"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-guanyu1"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img.picgo.net/2024/12/07/169_1_5b886d18-cb55-4030-8238-9c911a3b887dac464e01b8713ae4.png')"><nav id="nav"><span id="blog-info"><a href="/" title="宇仔的小破站"><span class="site-name">宇仔的小破站</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="iconfont icon-a-044_sousuo fa-fw"></i><!-- span=' '+_p('search.title')--></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-zhuye1"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-youlian"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw iconfont icon-liuyanmoban"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-guanyu1"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="iconfont icon-caidan fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-24T11:47:12.000Z" title="发表于 2024-11-24 19:47:12">2024-11-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-24T11:47:12.000Z" title="更新于 2024-11-24 19:47:12">2024-11-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">66.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>241分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title="数据结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2024/11/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><h3 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h3><p>数组是最基础的数据结构，在内存中连续存储，支持随机访问。适用于需要频繁按索引访问元素的场景。</p>
<p><code>空间复杂度:O(n)</code></p>
<h4 id="算法讲解"><a href="#算法讲解" class="headerlink" title="算法讲解"></a>算法讲解</h4><h4 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h4><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>数组是计算机科学中最基础的数据结构之一，由相同类型的元素按顺序存储在连续的内存空间中。每个元素通过其索引值（数组下标）来进行唯一标识和访问。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2025/09/26/68d69dd170eb4.webp" alt="img"></p>
<p>在大多数编程语言中，数组的索引都是从0开始的，所以一个长度为n的数组，其索引范围是0到n-1。</p>
<h4 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h4><ol>
<li>固定大小：在大多数语言中，数组创建后大小固定不变</li>
<li>连续内存：元素在内存中顺序存储，无额外开销</li>
<li>随机访问：O(1)时间复杂度直接访问任意元素</li>
<li>同质性：同一数组中所有元素类型相同</li>
<li>索引访问：通过数字索引访问元素</li>
</ol>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="1-访问元素"><a href="#1-访问元素" class="headerlink" title="1. 访问元素"></a>1. 访问元素</h5><ul>
<li>时间复杂度：O(1)</li>
<li>基本语法：<code>array[index]</code></li>
</ul>
<h5 id="2-更新元素"><a href="#2-更新元素" class="headerlink" title="2. 更新元素"></a>2. 更新元素</h5><ul>
<li>时间复杂度：O(1)</li>
<li>基本语法：<code>array[index] = value</code></li>
</ul>
<h5 id="3-遍历数组"><a href="#3-遍历数组" class="headerlink" title="3. 遍历数组"></a>3. 遍历数组</h5><ul>
<li>时间复杂度：O(n)</li>
</ul>
<h5 id="4-搜索元素"><a href="#4-搜索元素" class="headerlink" title="4. 搜索元素"></a>4. 搜索元素</h5><ul>
<li>无序数组：O(n)</li>
<li>有序数组：O(log n)（使用二分查找）</li>
</ul>
<h5 id="5-插入-删除元素"><a href="#5-插入-删除元素" class="headerlink" title="5. 插入/删除元素"></a>5. 插入/删除元素</h5><ul>
<li>在数组末尾：O(1)</li>
<li>在数组指定位置：O(n)（需要移动元素）</li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 声明和初始化</span></span><br><span class="line"><span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]; <span class="comment">// 创建一个长度为5的int数组，默认值都是0</span></span><br><span class="line"><span class="type">int</span>[] primes = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>&#125;; <span class="comment">// 直接使用初始值创建数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">firstPrime</span> <span class="operator">=</span> primes[<span class="number">0</span>]; <span class="comment">// 得到2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新元素</span></span><br><span class="line">numbers[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组长度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> numbers.length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; primes.length; i++) &#123;</span><br><span class="line">    System.out.println(primes[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用增强for循环遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> prime : primes) &#123;</span><br><span class="line">    System.out.println(prime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol>
<li><strong>快速访问</strong>：O(1)时间复杂度随机访问任意元素</li>
<li><strong>空间效率高</strong>：元素紧密排列，内存利用率高</li>
<li><strong>CPU缓存友好</strong>：连续内存布局有利于缓存命中率</li>
<li><strong>下标访问直观</strong>：使用自然数字索引访问简单直观</li>
</ol>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li><strong>固定大小</strong>：创建后大小不可变（Java的原生数组）</li>
<li><strong>插入删除低效</strong>：非尾部操作需要移动元素，时间复杂度O(n)</li>
<li><strong>内存浪费</strong>：预分配过大容量可能造成内存浪费</li>
<li><strong>空间要求</strong>：要求内存中有足够的连续空间</li>
</ol>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li><strong>需要快速随机访问</strong>的场景，如图像处理、矩阵运算</li>
<li><strong>大小已知且固定</strong>的数据集合</li>
<li><strong>需要高性能的数值计算</strong>或科学计算</li>
<li><strong>查询频繁但修改较少</strong>的数据结构</li>
<li><strong>作为底层数据结构</strong>，许多高级数据结构内部使用数组实现</li>
</ol>
<h4 id="扩展：动态数组"><a href="#扩展：动态数组" class="headerlink" title="扩展：动态数组"></a>扩展：动态数组</h4><p>由于原生数组大小固定的限制，很多编程语言提供了动态数组的实现，比如Java中的ArrayList。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建动态数组</span></span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">list.add(<span class="number">10</span>);</span><br><span class="line">list.add(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定位置添加元素</span></span><br><span class="line">list.add(<span class="number">1</span>, <span class="number">15</span>); <span class="comment">// [10, 15, 20]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> list.get(<span class="number">0</span>); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改元素</span></span><br><span class="line">list.set(<span class="number">1</span>, <span class="number">25</span>); <span class="comment">// [10, 25, 20]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">list.remove(<span class="number">2</span>); <span class="comment">// [10, 25]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取大小</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>具体扩容机制和原理参考：<a target="_blank" rel="noopener" href="https://www.mianshiya.com/question/1839515038747066370">Java ArrayList 的扩容机制是什么？ - 面试鸭 - 程序员求职面试刷题神器</a></p>
<h4 id="扩展：多维数组"><a href="#扩展：多维数组" class="headerlink" title="扩展：多维数组"></a>扩展：多维数组</h4><p>多维数组是数组的扩展形式，可以看作是”数组的数组”。最常见的是二维数组，它可以用来表示表格、矩阵等结构。</p>
<h5 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h5><p>二维数组可以想象成一个表格，有行和列，每个元素需要两个索引来定位：一个表示行，一个表示列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 创建一个3行4列的二维数组</span></span><br><span class="line"><span class="type">int</span>[][] matrix = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并初始化二维数组</span></span><br><span class="line"><span class="type">int</span>[][] gameBoard = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<h5 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h5><p>在Java中，二维数组实际上是”数组的数组”，即第一维存储的是指向第二维数组的引用。因此，Java中的二维数组可以是不规则的（每行的长度可以不同）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">▼Java复制代码<span class="comment">// 创建不规则二维数组</span></span><br><span class="line"><span class="type">int</span>[][] irregular = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][];</span><br><span class="line">irregular[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">irregular[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line">irregular[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<h5 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h5><p>Java支持两维以上的多维数组，如三维数组（可以想象成多层二维表格）或更高维度的数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">▼Java复制代码<span class="comment">// 创建三维数组</span></span><br><span class="line"><span class="type">int</span>[][][] cube = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">4</span>][<span class="number">5</span>];  <span class="comment">// 3层，每层4行5列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问三维数组的元素</span></span><br><span class="line">cube[<span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>] = <span class="number">100</span>;  <span class="comment">// 第2层，第3行，第4列</span></span><br></pre></td></tr></table></figure>
<h5 id="多维数组的应用"><a href="#多维数组的应用" class="headerlink" title="多维数组的应用"></a>多维数组的应用</h5><ol>
<li><strong>游戏开发</strong>：使用二维数组表示游戏地图、棋盘等。</li>
<li><strong>图像处理</strong>：使用二维数组表示像素矩阵。</li>
<li><strong>矩阵运算</strong>：科学计算和线性代数中的矩阵运算。</li>
<li><strong>数据分析</strong>：处理表格数据和多维数据集。</li>
<li><strong>3D建模</strong>：使用三维数组表示空间中的体素数据。</li>
</ol>
<h4 id="测验"><a href="#测验" class="headerlink" title="测验"></a>测验</h4><p>1）在Java中，声明一个长度为10的整型数组，初始值为0到9，正确的代码是什么？</p>
<p>2）如果有一个大小为n的数组，要在索引为k的位置插入一个新元素，最坏情况下的时间复杂度是多少？</p>
<p>3）二维数组<code>int[][] arr = new int[5][4]</code>中共有多少个元素？</p>
<p>4）如何在不使用额外空间的情况下反转一个数组？</p>
<h5 id="测验答案"><a href="#测验答案" class="headerlink" title="测验答案"></a>测验答案</h5><p>1）在Java中，声明一个长度为10的整型数组，初始值为0到9，正确的代码是什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">▼Java复制代码<span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    arr[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者直接初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">▼Java</span><br><span class="line"></span><br><span class="line">复制代码<span class="type">int</span>[] arr = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>2）最坏情况时间复杂度为O(n)。发生在需要在数组头部(k=0)插入元素时，这需要将所有现有元素向后移动一位。</p>
<p>3）二维数组<code>int[][] arr = new int[5][4]</code>中共有多少个元素？共有20个元素。这是一个5行4列的二维数组，总元素个数 = 5 × 4 = 20。</p>
<p>4）如何在不使用额外空间的情况下反转一个数组？使用双指针：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 交换元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        arr[right] = temp;</span><br><span class="line">        <span class="comment">// 移动指针</span></span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、字符串"><a href="#二、字符串" class="headerlink" title="二、字符串"></a>二、字符串</h3><p>字符串是由字符组成的有限序列，在计算机中通常以字符数组形式存储，支持拼接、查找、替换等操作。</p>
<h5 id="算法讲解-1"><a href="#算法讲解-1" class="headerlink" title="算法讲解"></a>算法讲解</h5><h4 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h4><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>字符串是计算机科学中最常用的数据类型之一，它是由一系列字符组成的有限序列。在大多数编程语言中，字符串被作为基本数据类型或对象提供，用于表示文本。</p>
<p>从本质上讲，字符串可以看作是一个数组，但与普通数组不同，字符串有特殊的属性和操作方法，更适合处理文本数据。在Java等现代编程语言中，字符串是不可变的对象，这意味着一旦创建，其内容不能被修改。</p>
<h4 id="核心特性-1"><a href="#核心特性-1" class="headerlink" title="核心特性"></a>核心特性</h4><ol>
<li>不可变性：在Java中，字符串对象一旦创建，其值不能被更改</li>
<li>字符序列：由多个字符按顺序排列组成</li>
<li>索引访问：可以通过索引访问单个字符，索引从0开始</li>
<li>字符串池：Java中常量字符串会被存储在字符串池中以节省内存</li>
<li>Unicode支持：可以包含任何Unicode字符，支持多语言文本</li>
</ol>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 创建字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">greeting</span> <span class="operator">=</span> <span class="string">&quot;你好，世界！&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Java编程&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串长度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> greeting.length();  <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> greeting + <span class="string">&quot; 欢迎学习&quot;</span> + name;</span><br><span class="line"><span class="type">String</span> <span class="variable">sameMassage</span> <span class="operator">=</span> greeting.concat(<span class="string">&quot; 欢迎学习&quot;</span>).concat(name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问字符</span></span><br><span class="line"><span class="type">char</span> <span class="variable">firstChar</span> <span class="operator">=</span> greeting.charAt(<span class="number">0</span>);  <span class="comment">// &#x27;你&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取子字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">subStr</span> <span class="operator">=</span> greeting.substring(<span class="number">0</span>, <span class="number">2</span>);  <span class="comment">// &quot;你好&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串比较</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEqual</span> <span class="operator">=</span> greeting.equals(<span class="string">&quot;你好，世界！&quot;</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">ignoreCase</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>.equalsIgnoreCase(<span class="string">&quot;java&quot;</span>);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> message.indexOf(<span class="string">&quot;欢迎&quot;</span>);  <span class="comment">// 返回&quot;欢迎&quot;在字符串中首次出现的索引</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">contains</span> <span class="operator">=</span> message.contains(<span class="string">&quot;Java&quot;</span>);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换</span></span><br><span class="line"><span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> greeting.replace(<span class="string">&#x27;你&#x27;</span>, <span class="string">&#x27;我&#x27;</span>);  <span class="comment">// &quot;我好，世界！&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分割</span></span><br><span class="line">String[] parts = <span class="string">&quot;苹果,香蕉,橙子&quot;</span>.split(<span class="string">&quot;,&quot;</span>);  <span class="comment">// [&quot;苹果&quot;, &quot;香蕉&quot;, &quot;橙子&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换大小写（仅适用于拉丁字母）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">upper</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>.toUpperCase();  <span class="comment">// &quot;HELLO&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">lower</span> <span class="operator">=</span> <span class="string">&quot;HELLO&quot;</span>.toLowerCase();  <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除首尾空白</span></span><br><span class="line"><span class="type">String</span> <span class="variable">trimmed</span> <span class="operator">=</span> <span class="string">&quot;  hello  &quot;</span>.trim();  <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol>
<li><strong>易用性</strong>：提供了丰富的API和操作方法，处理文本更简单</li>
<li><strong>国际化支持</strong>：支持Unicode字符集，可以处理各种语言的文本</li>
<li><strong>内存优化</strong>：字符串池机制减少内存使用</li>
</ol>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li><strong>文本处理</strong>：处理用户输入、配置文件、日志等</li>
<li><strong>数据解析</strong>：解析JSON、XML、CSV等格式的数据</li>
<li><strong>自然语言处理</strong>：文本分析、情感分析、机器翻译等</li>
<li><strong>网络通信</strong>：HTTP请求参数、URL处理、网络协议等</li>
<li><strong>用户界面</strong>：显示文本、多语言支持等</li>
</ol>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><h5 id="StringBuilder-vs-StringBuffer-vs-String"><a href="#StringBuilder-vs-StringBuffer-vs-String" class="headerlink" title="StringBuilder vs StringBuffer vs String"></a>StringBuilder vs StringBuffer vs String</h5><ul>
<li><strong>String</strong>：不可变，适合作为常量使用</li>
<li><strong>StringBuilder</strong>：可变，非线程安全，适合在单线程环境中频繁修改字符串</li>
<li><strong>StringBuffer</strong>：可变，线程安全，适合在多线程环境中使用，但性能略低于StringBuilder</li>
</ul>
<h5 id="字符串编码"><a href="#字符串编码" class="headerlink" title="字符串编码"></a>字符串编码</h5><p>字符串在内存中存储和在文件中保存时需要特定的编码方式，常见的编码包括ASCII、UTF-8、UTF-16等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串与字节数组转换</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;你好，世界&quot;</span>;</span><br><span class="line"><span class="comment">// 将字符串转换为UTF-8编码的字节数组</span></span><br><span class="line"><span class="type">byte</span>[] bytes = str.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">// 将字节数组转回字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查编码是否支持</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">supported</span> <span class="operator">=</span> Charset.isSupported(<span class="string">&quot;UTF-8&quot;</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="常见编码比较"><a href="#常见编码比较" class="headerlink" title="常见编码比较"></a>常见编码比较</h5><ol>
<li><strong>ASCII</strong>：只能表示128个字符，主要是英文字母、数字和符号</li>
<li><strong>ISO-8859-1</strong>：扩展ASCII，可表示西欧语言字符</li>
<li><strong>UTF-8</strong>：变长编码，英文占1字节，中文通常占3字节，兼容ASCII</li>
<li><strong>UTF-16</strong>：Java内部使用的编码，所有字符占2或4字节</li>
<li><strong>GBK/GB2312</strong>：中文编码标准，主要用于表示中文字符</li>
</ol>
<h4 id="测验-1"><a href="#测验-1" class="headerlink" title="测验"></a>测验</h4><p>在Java中，<code>String s1 = &quot;hello&quot;;</code> 和 <code>String s2 = new String(&quot;hello&quot;);</code> 创建的字符串有什么区别？</p>
<blockquote>
<p>测验答案</p>
<ul>
<li><code>s1</code>使用字符串字面量创建，会首先在字符串常量池中查找”hello”，如果存在则直接引用，不存在则在池中创建并引用。</li>
<li><code>s2</code>使用构造函数创建，会在堆内存中创建一个新的String对象，即使常量池中已有相同内容的字符串。</li>
<li>所以<code>s1 == s2</code>返回false（比较引用），但<code>s1.equals(s2)</code>返回true（比较内容）。</li>
</ul>
</blockquote>
<h3 id="三、单向链表"><a href="#三、单向链表" class="headerlink" title="三、单向链表"></a>三、单向链表</h3><p>单向链表是一种线性数据结构，其中每个节点包含数据和指向下一个节点的指针。适用于频繁插入和删除操作的场景。</p>
<p><code>空间复杂度:O(n)</code></p>
<h5 id="算法讲解-2"><a href="#算法讲解-2" class="headerlink" title="算法讲解"></a>算法讲解</h5><h4 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h4><h5 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h5><p>单向链表是一种线性数据结构，它由一系列节点组成，每个节点包含两部分：数据域和指针域。数据域用于存储实际数据，指针域存储指向下一个节点的引用。链表中的最后一个节点指向空（null），表示链表的结束。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2025/09/26/68d69ee6a3bd9.png" alt="img"></p>
<p>与数组不同，链表中的元素在内存中不是连续存储的，而是通过指针连接在一起。这种特性让链表在某些操作上比数组更灵活，特别是在频繁进行插入和删除操作的场景下。</p>
<h4 id="核心特性-2"><a href="#核心特性-2" class="headerlink" title="核心特性"></a>核心特性</h4><ol>
<li>动态大小：链表可以动态增长和缩小，无需预先定义大小</li>
<li>非连续存储：节点在内存中分散存储，通过指针相连</li>
<li>单向性：每个节点只知道下一个节点在哪里，不知道上一个节点</li>
<li>顺序访问：必须从头节点开始，沿着指针逐个访问节点</li>
<li>无索引访问：不能像数组那样通过索引直接访问元素</li>
</ol>
<h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="1-访问元素-1"><a href="#1-访问元素-1" class="headerlink" title="1. 访问元素"></a>1. 访问元素</h5><ul>
<li>时间复杂度：O(n)</li>
<li>说明：必须从头节点开始，沿链表遍历直到找到目标节点</li>
</ul>
<h5 id="2-在头部插入"><a href="#2-在头部插入" class="headerlink" title="2. 在头部插入"></a>2. 在头部插入</h5><ul>
<li>时间复杂度：O(1)</li>
<li>说明：创建新节点并指向当前头节点，然后更新头节点</li>
</ul>
<h5 id="3-在尾部插入"><a href="#3-在尾部插入" class="headerlink" title="3. 在尾部插入"></a>3. 在尾部插入</h5><ul>
<li>时间复杂度：O(n)或O(1)<ul>
<li>O(n)：如果只有头指针，需要遍历到尾部</li>
<li>O(1)：如果维护了尾指针，可以直接在尾部操作</li>
</ul>
</li>
</ul>
<h5 id="4-在中间插入"><a href="#4-在中间插入" class="headerlink" title="4. 在中间插入"></a>4. 在中间插入</h5><ul>
<li>时间复杂度：O(n)</li>
<li>说明：先找到目标位置的前一个节点，再执行插入操作</li>
</ul>
<h5 id="5-删除节点"><a href="#5-删除节点" class="headerlink" title="5. 删除节点"></a>5. 删除节点</h5><ul>
<li>时间复杂度：<ul>
<li>删除头节点：O(1)</li>
<li>删除其他节点：O(n)，因为需要找到待删除节点的前一个节点</li>
</ul>
</li>
</ul>
<h5 id="6-查找元素"><a href="#6-查找元素" class="headerlink" title="6. 查找元素"></a>6. 查找元素</h5><ul>
<li>时间复杂度：O(n)</li>
<li>说明：从头节点开始遍历链表查找目标元素</li>
</ul>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 定义节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;       <span class="comment">// 数据域</span></span><br><span class="line">    Node next;      <span class="comment">// 指针域，指向下一个节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单向链表类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;  <span class="comment">// 头节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数，创建一个空链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SinglyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断链表是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在链表头部插入节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertAtHead</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            head = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newNode.next = head;</span><br><span class="line">            head = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在链表尾部插入节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertAtTail</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            head = newNode;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 找到最后一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (current.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        current.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在指定位置插入节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertAtPosition</span><span class="params">(<span class="type">int</span> data, <span class="type">int</span> position)</span> &#123;</span><br><span class="line">        <span class="comment">// 位置无效</span></span><br><span class="line">        <span class="keyword">if</span> (position &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;位置无效&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 插入位置为0，相当于在头部插入</span></span><br><span class="line">        <span class="keyword">if</span> (position == <span class="number">0</span>) &#123;</span><br><span class="line">            insertAtHead(data);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">previous</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到要插入位置的前一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span> &amp;&amp; count &lt; position) &#123;</span><br><span class="line">            previous = current;</span><br><span class="line">            current = current.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果position超出链表长度，则插入到尾部</span></span><br><span class="line">        previous.next = newNode;</span><br><span class="line">        newNode.next = current;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除第一个值为data的节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="comment">// 链表为空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空，无法删除&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除的是头节点</span></span><br><span class="line">        <span class="keyword">if</span> (head.data == data) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除的不是头节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">previous</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查找要删除的节点</span></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span> &amp;&amp; current.data != data) &#123;</span><br><span class="line">            previous = current;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果找到了要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            previous.next = current.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;未找到要删除的元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.data == data) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(current.data + <span class="string">&quot; -&gt; &quot;</span>);</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取链表长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SinglyLinkedList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SinglyLinkedList</span>();</span><br><span class="line">        </span><br><span class="line">        list.insertAtTail(<span class="number">10</span>);</span><br><span class="line">        list.insertAtTail(<span class="number">20</span>);</span><br><span class="line">        list.insertAtTail(<span class="number">30</span>);</span><br><span class="line">        list.insertAtHead(<span class="number">5</span>);</span><br><span class="line">        list.display();  <span class="comment">// 输出: 5 -&gt; 10 -&gt; 20 -&gt; 30 -&gt; null</span></span><br><span class="line">        </span><br><span class="line">        list.insertAtPosition(<span class="number">15</span>, <span class="number">2</span>);</span><br><span class="line">        list.display();  <span class="comment">// 输出: 5 -&gt; 10 -&gt; 15 -&gt; 20 -&gt; 30 -&gt; null</span></span><br><span class="line">        </span><br><span class="line">        list.delete(<span class="number">15</span>);</span><br><span class="line">        list.display();  <span class="comment">// 输出: 5 -&gt; 10 -&gt; 20 -&gt; 30 -&gt; null</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;查找结果: &quot;</span> + list.search(<span class="number">20</span>));  <span class="comment">// 输出: 查找结果: true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;链表长度: &quot;</span> + list.size());      <span class="comment">// 输出: 链表长度: 4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ol>
<li><strong>动态大小</strong>：链表可以根据需要动态分配内存，不需要预先定义大小</li>
<li><strong>插入和删除高效</strong>：在已知位置插入或删除节点的时间复杂度为O(1)</li>
<li><strong>内存利用灵活</strong>：不需要连续的内存空间，可以充分利用可用内存</li>
<li><strong>实现简单</strong>：基本操作实现相对简单直观</li>
</ol>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li><strong>随机访问低效</strong>：无法像数组那样通过索引直接访问元素，必须从头开始遍历</li>
<li><strong>额外内存开销</strong>：每个节点除了存储数据外，还需要存储指针，增加了内存消耗</li>
<li><strong>缓存不友好</strong>：由于内存不连续，不能有效利用CPU缓存，可能导致性能下降</li>
<li><strong>反向遍历困难</strong>：单向链表不支持反向遍历</li>
</ol>
<h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li><strong>历史记录</strong></li>
<li><strong>撤销功能</strong>：编辑器的撤销操作实现</li>
<li><strong>合适的插入/删除场景</strong>：需要频繁在数据结构中间插入或删除元素的场景</li>
<li><strong>作为其他数据结构的基础</strong></li>
</ol>
<h4 id="扩展：双向链表和循环链表"><a href="#扩展：双向链表和循环链表" class="headerlink" title="扩展：双向链表和循环链表"></a>扩展：双向链表和循环链表</h4><p>单向链表的一个主要缺点是只能从头到尾遍历。为了克服这个限制，有两种常见的链表变种：</p>
<h5 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h5><p>双向链表中的每个节点有两个指针：一个指向下一个节点，一个指向前一个节点。这使得链表可以双向遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoublyNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    DoublyNode next;</span><br><span class="line">    DoublyNode prev;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoublyNode</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h5><p>循环链表是一种特殊的链表，其最后一个节点的指针不是null，而是指向头节点，形成一个环。循环链表可以是单向的或双向的。</p>
<h4 id="测验-2"><a href="#测验-2" class="headerlink" title="测验"></a>测验</h4><p>1）如果要在单向链表中找到倒数第k个节点，最简单的方法是什么？需要几次遍历？</p>
<p>2）如何判断一个单向链表中是否包含环（循环）？</p>
<p>3）编写一个算法反转单向链表。</p>
<p>4）如果有两个单链表，如何找到它们的交点（如果存在）？</p>
<h5 id="测验答案-1"><a href="#测验答案-1" class="headerlink" title="测验答案"></a>测验答案</h5><p>1）找到倒数第k个节点的方法：</p>
<ul>
<li>先遍历一次链表，获取链表长度n</li>
<li>再遍历一次，找到第(n-k+1)个节点</li>
<li>需要两次遍历</li>
</ul>
<p>另一种优化方法是使用快慢指针：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">findKthFromEnd</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Node</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 快指针先走k步</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// k大于链表长度</span></span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 快慢指针同时走，当快指针到达末尾时，慢指针指向倒数第k个节点</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）判断链表是否包含环，可以使用快慢指针（Floyd’s Cycle-Finding Algorithm）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Node</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.next;       <span class="comment">// 慢指针每次走一步</span></span><br><span class="line">        fast = fast.next.next;  <span class="comment">// 快指针每次走两步</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果存在环，快慢指针最终会相遇</span></span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）反转单向链表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">        next = current.next;  <span class="comment">// 暂存下一个节点</span></span><br><span class="line">        current.next = prev;  <span class="comment">// 反转当前节点的指针</span></span><br><span class="line">        prev = current;       <span class="comment">// 向前移动prev</span></span><br><span class="line">        current = next;       <span class="comment">// 向前移动current</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    head = prev;  <span class="comment">// 更新头节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、双端队列"><a href="#四、双端队列" class="headerlink" title="四、双端队列"></a>四、双端队列</h3><p>一种特殊的队列，允许在两端（前端和后端）进行元素的插入和删除操作，它结合了栈和队列的特性</p>
<h5 id="算法讲解-3"><a href="#算法讲解-3" class="headerlink" title="算法讲解"></a>算法讲解</h5><h4 id="双端队列-Deque"><a href="#双端队列-Deque" class="headerlink" title="双端队列(Deque)"></a>双端队列(Deque)</h4><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>双端队列（Double-ended queue，简称Deque）是一种特殊的队列，它允许在队列的两端（前端和后端）进行元素的插入和删除操作。与普通队列（只允许在一端插入，另一端删除）和栈（只允许在同一端插入和删除）不同，双端队列提供了更高的灵活性。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2025/09/26/68d69f9e3b20d.webp" alt="img"></p>
<p>双端队列可以被视为同时结合了栈和队列特性的数据结构，既可以作为栈使用（后进先出），也可以作为队列使用（先进先出）。</p>
<h4 id="核心特性-3"><a href="#核心特性-3" class="headerlink" title="核心特性"></a>核心特性</h4><ol>
<li>双向操作：可以在队列的两端执行插入和删除操作</li>
<li>灵活性：可以同时实现栈和队列的功能</li>
<li>动态大小：大多数实现允许大小动态增长</li>
<li>高效的首尾操作：在两端进行的操作通常具有O(1)的时间复杂度</li>
<li>中间访问受限：通常不支持高效的随机访问</li>
</ol>
<h4 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="1-在前端添加元素-addFirst-offerFirst"><a href="#1-在前端添加元素-addFirst-offerFirst" class="headerlink" title="1. 在前端添加元素(addFirst/offerFirst)"></a>1. 在前端添加元素(addFirst/offerFirst)</h5><ul>
<li>时间复杂度：O(1)</li>
<li>描述：将元素添加到双端队列的前端</li>
</ul>
<h5 id="2-在后端添加元素-addLast-offerLast"><a href="#2-在后端添加元素-addLast-offerLast" class="headerlink" title="2. 在后端添加元素(addLast/offerLast)"></a>2. 在后端添加元素(addLast/offerLast)</h5><ul>
<li>时间复杂度：O(1)</li>
<li>描述：将元素添加到双端队列的后端</li>
</ul>
<h5 id="3-从前端删除元素-removeFirst-pollFirst"><a href="#3-从前端删除元素-removeFirst-pollFirst" class="headerlink" title="3. 从前端删除元素(removeFirst/pollFirst)"></a>3. 从前端删除元素(removeFirst/pollFirst)</h5><ul>
<li>时间复杂度：O(1)</li>
<li>描述：移除并返回双端队列前端的元素</li>
</ul>
<h5 id="4-从后端删除元素-removeLast-pollLast"><a href="#4-从后端删除元素-removeLast-pollLast" class="headerlink" title="4. 从后端删除元素(removeLast/pollLast)"></a>4. 从后端删除元素(removeLast/pollLast)</h5><ul>
<li>时间复杂度：O(1)</li>
<li>描述：移除并返回双端队列后端的元素</li>
</ul>
<h5 id="5-查看前端元素-getFirst-peekFirst"><a href="#5-查看前端元素-getFirst-peekFirst" class="headerlink" title="5. 查看前端元素(getFirst/peekFirst)"></a>5. 查看前端元素(getFirst/peekFirst)</h5><ul>
<li>时间复杂度：O(1)</li>
<li>描述：获取但不移除双端队列前端的元素</li>
</ul>
<h5 id="6-查看后端元素-getLast-peekLast"><a href="#6-查看后端元素-getLast-peekLast" class="headerlink" title="6. 查看后端元素(getLast/peekLast)"></a>6. 查看后端元素(getLast/peekLast)</h5><ul>
<li>时间复杂度：O(1)</li>
<li>描述：获取但不移除双端队列后端的元素</li>
</ul>
<h5 id="7-检查队列是否为空-isEmpty"><a href="#7-检查队列是否为空-isEmpty" class="headerlink" title="7. 检查队列是否为空(isEmpty)"></a>7. 检查队列是否为空(isEmpty)</h5><ul>
<li>时间复杂度：O(1)</li>
<li>描述：判断双端队列是否不包含元素</li>
</ul>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DequeExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建双端队列</span></span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在前端添加元素</span></span><br><span class="line">        deque.addFirst(<span class="number">10</span>);</span><br><span class="line">        deque.offerFirst(<span class="number">20</span>);  <span class="comment">// 优先使用offer方法，不会抛异常</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在后端添加元素</span></span><br><span class="line">        deque.addLast(<span class="number">30</span>);</span><br><span class="line">        deque.offerLast(<span class="number">40</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;双端队列: &quot;</span> + deque);  <span class="comment">// 输出: [20, 10, 30, 40]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查看前端元素（不移除）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> deque.peekFirst();</span><br><span class="line">        System.out.println(<span class="string">&quot;前端元素: &quot;</span> + first);  <span class="comment">// 输出: 20</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查看后端元素（不移除）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> deque.peekLast();</span><br><span class="line">        System.out.println(<span class="string">&quot;后端元素: &quot;</span> + last);  <span class="comment">// 输出: 40</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从前端移除元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">removedFirst</span> <span class="operator">=</span> deque.pollFirst();</span><br><span class="line">        System.out.println(<span class="string">&quot;从前端移除: &quot;</span> + removedFirst);  <span class="comment">// 输出: 20</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从后端移除元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">removedLast</span> <span class="operator">=</span> deque.pollLast();</span><br><span class="line">        System.out.println(<span class="string">&quot;从后端移除: &quot;</span> + removedLast);  <span class="comment">// 输出: 40</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;最终双端队列: &quot;</span> + deque);  <span class="comment">// 输出: [10, 30]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用双端队列作为栈</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        stack.push(<span class="number">50</span>);  <span class="comment">// 等同于addFirst()</span></span><br><span class="line">        stack.push(<span class="number">60</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;栈顶元素: &quot;</span> + stack.peek());  <span class="comment">// 输出: 60</span></span><br><span class="line">        System.out.println(<span class="string">&quot;弹出元素: &quot;</span> + stack.pop());  <span class="comment">// 输出: 60</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h5><ol>
<li><strong>灵活性高</strong>：可以同时进行栈和队列的操作</li>
<li><strong>两端操作高效</strong>：在两端的添加和删除操作时间复杂度为O(1)</li>
<li><strong>动态适应不同场景</strong>：可以根据需求作为栈或队列使用</li>
<li><strong>实现滑动窗口</strong>：特别适合需要从两端操作的滑动窗口算法</li>
</ol>
<h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li><strong>实现复杂</strong>：比普通队列或栈的实现更复杂</li>
<li><strong>中间操作低效</strong>：随机访问或中间位置的操作效率较低</li>
<li><strong>内存占用</strong>：某些实现（如链表实现）需要额外的存储空间</li>
<li><strong>不适合随机访问</strong>：不支持高效的随机访问，只擅长两端操作</li>
</ol>
<h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li><strong>工作窃取算法</strong>：多线程任务调度中的工作窃取</li>
<li><strong>浏览器历史</strong>：前进和后退功能</li>
<li><strong>撤销/重做功能</strong>：编辑器中的操作历史</li>
<li><strong>输入缓冲</strong>：用于字符流处理</li>
<li><strong>滑动窗口问题</strong>：维护固定大小的窗口</li>
<li><strong>算法优化</strong>：BFS、图算法等中的辅助数据结构</li>
<li><strong>缓存实现</strong>：特定类型的缓存策略</li>
</ol>
<h4 id="扩展：双端队列的实现方式"><a href="#扩展：双端队列的实现方式" class="headerlink" title="扩展：双端队列的实现方式"></a>扩展：双端队列的实现方式</h4><h5 id="1-基于数组的实现"><a href="#1-基于数组的实现" class="headerlink" title="1. 基于数组的实现"></a>1. 基于数组的实现</h5><p>使用循环数组实现双端队列，需要维护前端和后端两个指针，并在边界条件下进行循环操作。优点是空间利用率高，缺点是需要预先分配固定大小的空间。</p>
<h5 id="2-基于链表的实现"><a href="#2-基于链表的实现" class="headerlink" title="2. 基于链表的实现"></a>2. 基于链表的实现</h5><p>使用双向链表实现双端队列，每个节点包含前驱和后继指针。这种实现的优点是可以动态调整大小，不需要预先分配空间；缺点是每个元素需要额外空间存储指针，且内存不连续。</p>
<h5 id="3-混合实现"><a href="#3-混合实现" class="headerlink" title="3. 混合实现"></a>3. 混合实现</h5><p>有些实现，如Java的ArrayDeque，使用分段数组等技术优化性能，结合了数组和链表的优点。</p>
<h4 id="测验-3"><a href="#测验-3" class="headerlink" title="测验"></a>测验</h4><p>1）双端队列与普通队列的主要区别是什么？</p>
<p>2）若使用双端队列实现栈，应该使用哪些操作方法？</p>
<p>3）双端队列在两端操作的时间复杂度是多少？</p>
<blockquote>
<p>测验答案</p>
<p>1）双端队列允许在队列的两端（前端和后端）进行元素的插入和删除操作，而普通队列只允许在一端（后端）插入元素，在另一端（前端）删除元素。双端队列更加灵活，既可以用作栈，也可以用作队列。</p>
<p>2）使用双端队列实现栈只使用前端（或只使用后端）的操作方法，即：</p>
<ul>
<li>压栈：addFirst()/offerFirst()或addLast()/offerLast()</li>
<li>出栈：removeFirst()/pollFirst()或removeLast()/pollLast()</li>
<li>查看栈顶：peekFirst()或peekLast()</li>
</ul>
<p>3）时间复杂度为O(1)。</p>
</blockquote>
<h3 id="五、双向链表"><a href="#五、双向链表" class="headerlink" title="五、双向链表"></a>五、双向链表</h3><p>双向链表是一种线性数据结构，其中每个节点包含数据和指向前一个与后一个节点的指针。支持双向遍历，适用于需要双向操作的场景。</p>
<p><code>空间复杂度:O(n)</code></p>
<h5 id="算法讲解-4"><a href="#算法讲解-4" class="headerlink" title="算法讲解"></a>算法讲解</h5><h4 id="双向链表-Doubly-Linked-List"><a href="#双向链表-Doubly-Linked-List" class="headerlink" title="双向链表(Doubly Linked List)"></a>双向链表(Doubly Linked List)</h4><h5 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h5><p>双向链表是链表的一种变体，其中每个节点包含三个部分：数据域、前向指针和后向指针。前向指针指向前一个节点，后向指针指向后一个节点。这种结构使得链表可以从两个方向进行遍历，增加了灵活性。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2025/09/26/68d6a02c587ed.webp" alt="img"></p>
<p>与单向链表相比，双向链表支持双向遍历，并且在某些操作上更高效，例如删除给定节点或在特定节点前插入新节点。双向链表的头结点的前向指针和尾节点的后向指针通常指向null，表示链表的边界。</p>
<h4 id="核心特性-4"><a href="#核心特性-4" class="headerlink" title="核心特性"></a>核心特性</h4><ol>
<li>双向遍历：可以从前向后或从后向前遍历链表</li>
<li>两个指针：每个节点有指向前一个和后一个节点的指针</li>
<li>动态大小：可以根据需要动态增长和缩小</li>
<li>非连续存储：节点在内存中分散存储，通过指针相连</li>
</ol>
<h4 id="基本操作-3"><a href="#基本操作-3" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="1-访问元素-2"><a href="#1-访问元素-2" class="headerlink" title="1. 访问元素"></a>1. 访问元素</h5><ul>
<li>时间复杂度：O(n)</li>
<li>说明：必须从头节点或尾节点开始遍历直到找到目标节点</li>
</ul>
<h5 id="2-插入操作"><a href="#2-插入操作" class="headerlink" title="2. 插入操作"></a>2. 插入操作</h5><ul>
<li>头部插入：O(1)</li>
<li>尾部插入：O(1)</li>
<li>中间插入：O(n)查找位置 + O(1)插入操作</li>
</ul>
<h5 id="3-删除操作"><a href="#3-删除操作" class="headerlink" title="3. 删除操作"></a>3. 删除操作</h5><ul>
<li>头部删除：O(1)</li>
<li>尾部删除：O(1)（如果维护了尾指针）</li>
<li>中间删除：O(n)查找位置 + O(1)删除操作</li>
<li>给定节点删除：O(1)，无需查找其前驱节点</li>
</ul>
<h5 id="4-查找元素"><a href="#4-查找元素" class="headerlink" title="4. 查找元素"></a>4. 查找元素</h5><ul>
<li>时间复杂度：O(n)</li>
<li>可以根据查找目标的位置选择从头部或尾部开始查找</li>
</ul>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 定义节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;       <span class="comment">// 数据域</span></span><br><span class="line">    Node next;      <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    Node prev;      <span class="comment">// 指向前一个节点的指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoublyLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;  <span class="comment">// 头节点</span></span><br><span class="line">    <span class="keyword">private</span> Node tail;  <span class="comment">// 尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;   <span class="comment">// 链表大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数，创建一个空链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoublyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.tail = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断链表是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取链表大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在链表头部插入节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertAtHead</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            head = newNode;</span><br><span class="line">            tail = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newNode.next = head;</span><br><span class="line">            head.prev = newNode;</span><br><span class="line">            head = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在链表尾部插入节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertAtTail</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            head = newNode;</span><br><span class="line">            tail = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail.next = newNode;</span><br><span class="line">            newNode.prev = tail;</span><br><span class="line">            tail = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在指定位置插入节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertAtPosition</span><span class="params">(<span class="type">int</span> data, <span class="type">int</span> position)</span> &#123;</span><br><span class="line">        <span class="comment">// 位置无效</span></span><br><span class="line">        <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; size) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;位置无效&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 插入位置为0，相当于在头部插入</span></span><br><span class="line">        <span class="keyword">if</span> (position == <span class="number">0</span>) &#123;</span><br><span class="line">            insertAtHead(data);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 插入位置为size，相当于在尾部插入</span></span><br><span class="line">        <span class="keyword">if</span> (position == size) &#123;</span><br><span class="line">            insertAtTail(data);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 插入到中间位置</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">        <span class="comment">// 判断从头部还是尾部遍历更快</span></span><br><span class="line">        <span class="keyword">if</span> (position &lt;= size / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 从头部遍历</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; position; i++) &#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在current之前插入新节点</span></span><br><span class="line">            newNode.prev = current.prev;</span><br><span class="line">            newNode.next = current;</span><br><span class="line">            current.prev.next = newNode;</span><br><span class="line">            current.prev = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 从尾部遍历</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> tail;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; position; i--) &#123;</span><br><span class="line">                current = current.prev;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在current之前插入新节点</span></span><br><span class="line">            newNode.prev = current.prev;</span><br><span class="line">            newNode.next = current;</span><br><span class="line">            current.prev.next = newNode;</span><br><span class="line">            current.prev = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除头节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空，无法删除&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">            <span class="comment">// 只有一个节点</span></span><br><span class="line">            head = <span class="literal">null</span>;</span><br><span class="line">            tail = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            head.prev = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除尾节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空，无法删除&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">            <span class="comment">// 只有一个节点</span></span><br><span class="line">            head = <span class="literal">null</span>;</span><br><span class="line">            tail = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail = tail.prev;</span><br><span class="line">            tail.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除指定位置的节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtPosition</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">        <span class="comment">// 位置无效</span></span><br><span class="line">        <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= size) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;位置无效&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除头节点</span></span><br><span class="line">        <span class="keyword">if</span> (position == <span class="number">0</span>) &#123;</span><br><span class="line">            deleteHead();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (position == size - <span class="number">1</span>) &#123;</span><br><span class="line">            deleteTail();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除中间节点</span></span><br><span class="line">        <span class="comment">// 判断从头部还是尾部遍历更快</span></span><br><span class="line">        <span class="keyword">if</span> (position &lt;= size / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 从头部遍历</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; position; i++) &#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current.prev.next = current.next;</span><br><span class="line">            current.next.prev = current.prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 从尾部遍历</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> tail;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; position; i--) &#123;</span><br><span class="line">                current = current.prev;</span><br><span class="line">            &#125;</span><br><span class="line">            current.prev.next = current.next;</span><br><span class="line">            current.next.prev = current.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除第一个值为data的节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空，无法删除&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除的是头节点</span></span><br><span class="line">        <span class="keyword">if</span> (head.data == data) &#123;</span><br><span class="line">            deleteHead();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除的是尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (tail.data == data) &#123;</span><br><span class="line">            deleteTail();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除的是中间节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span> &amp;&amp; current != tail) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.data == data) &#123;</span><br><span class="line">                current.prev.next = current.next;</span><br><span class="line">                current.next.prev = current.prev;</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;未找到要删除的元素&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.data == data) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从头到尾打印链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayForward</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        System.out.print(<span class="string">&quot;null &lt;- &quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(current.data);</span><br><span class="line">            <span class="keyword">if</span> (current.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &lt;-&gt; &quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; -&gt; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从尾到头打印链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayBackward</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> tail;</span><br><span class="line">        System.out.print(<span class="string">&quot;null &lt;- &quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(current.data);</span><br><span class="line">            <span class="keyword">if</span> (current.prev != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &lt;-&gt; &quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; -&gt; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoublyLinkedListDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DoublyLinkedList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoublyLinkedList</span>();</span><br><span class="line">        </span><br><span class="line">        list.insertAtTail(<span class="number">10</span>);</span><br><span class="line">        list.insertAtTail(<span class="number">20</span>);</span><br><span class="line">        list.insertAtTail(<span class="number">30</span>);</span><br><span class="line">        list.insertAtHead(<span class="number">5</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;从头到尾打印：&quot;</span>);</span><br><span class="line">        list.displayForward();  <span class="comment">// 输出: null &lt;- 5 &lt;-&gt; 10 &lt;-&gt; 20 &lt;-&gt; 30 -&gt; null</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;从尾到头打印：&quot;</span>);</span><br><span class="line">        list.displayBackward(); <span class="comment">// 输出: null &lt;- 30 &lt;-&gt; 20 &lt;-&gt; 10 &lt;-&gt; 5 -&gt; null</span></span><br><span class="line">        </span><br><span class="line">        list.insertAtPosition(<span class="number">15</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;插入15到位置2后：&quot;</span>);</span><br><span class="line">        list.displayForward();  <span class="comment">// 输出: null &lt;- 5 &lt;-&gt; 10 &lt;-&gt; 15 &lt;-&gt; 20 &lt;-&gt; 30 -&gt; null</span></span><br><span class="line">        </span><br><span class="line">        list.delete(<span class="number">15</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除15后：&quot;</span>);</span><br><span class="line">        list.displayForward();  <span class="comment">// 输出: null &lt;- 5 &lt;-&gt; 10 &lt;-&gt; 20 &lt;-&gt; 30 -&gt; null</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;查找结果: &quot;</span> + list.search(<span class="number">20</span>));  <span class="comment">// 输出: 查找结果: true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;链表长度: &quot;</span> + list.size());      <span class="comment">// 输出: 链表长度: 4</span></span><br><span class="line">        </span><br><span class="line">        list.deleteHead();</span><br><span class="line">        System.out.println(<span class="string">&quot;删除头节点后：&quot;</span>);</span><br><span class="line">        list.displayForward();  <span class="comment">// 输出: null &lt;- 10 &lt;-&gt; 20 &lt;-&gt; 30 -&gt; null</span></span><br><span class="line">        </span><br><span class="line">        list.deleteTail();</span><br><span class="line">        System.out.println(<span class="string">&quot;删除尾节点后：&quot;</span>);</span><br><span class="line">        list.displayForward();  <span class="comment">// 输出: null &lt;- 10 &lt;-&gt; 20 -&gt; null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<h4 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h5><ol>
<li><strong>双向遍历</strong>：可以从前向后或从后向前遍历，增加了灵活性</li>
<li><strong>某些操作更快</strong>：如果位置靠近尾部，可以从尾部开始遍历，提高效率</li>
<li><strong>实现更多操作</strong>：如反向遍历、直接访问前驱节点等单向链表难以实现的操作</li>
</ol>
<h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li><strong>内存开销大</strong>：每个节点需要额外存储一个指针，增加了内存消耗</li>
<li><strong>实现复杂</strong>：相比单向链表，实现和维护更复杂</li>
<li><strong>操作更慢</strong>：插入和删除需要处理更多的指针关系，稍微增加了操作的复杂度</li>
<li><strong>不适合内存受限环境</strong>：因为每个节点占用更多内存</li>
</ol>
<h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li><strong>浏览器历史记录</strong>：前进和后退功能</li>
<li><strong>双向迭代器</strong>：需要双向遍历的集合数据结构</li>
<li><strong>文本编辑器</strong>：光标移动和文本编辑</li>
<li><strong>撤销/重做功能</strong>：应用中的操作历史管理</li>
<li><strong>音乐播放器</strong>：上一首/下一首歌曲导航</li>
</ol>
<h4 id="扩展：循环双向链表"><a href="#扩展：循环双向链表" class="headerlink" title="扩展：循环双向链表"></a>扩展：循环双向链表</h4><p>循环双向链表是双向链表的变种，尾节点的后向指针指向头节点，头节点的前向指针指向尾节点，形成一个环。这种结构的链表没有明确的开始和结束点，可以从任何节点开始遍历整个链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环双向链表的实现修改</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertAtHead</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        head = newNode;</span><br><span class="line">        tail = newNode;</span><br><span class="line">        <span class="comment">// 形成循环</span></span><br><span class="line">        head.next = head;</span><br><span class="line">        head.prev = head;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newNode.next = head;</span><br><span class="line">        newNode.prev = tail;</span><br><span class="line">        head.prev = newNode;</span><br><span class="line">        tail.next = newNode;</span><br><span class="line">        head = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他方法也需要相应调整...</span></span><br></pre></td></tr></table></figure>
<h4 id="测验-4"><a href="#测验-4" class="headerlink" title="测验"></a>测验</h4><p>1）如何检测双向链表中是否存在环（循环）？</p>
<p>2）如何在不使用额外空间的情况下翻转一个双向链表？</p>
<p>3）如何合并两个已排序的双向链表，且保证结果仍然有序？</p>
<p>4）如何实现一个双向链表的中间节点查找，要求只遍历一次链表？</p>
<h5 id="测验答案-2"><a href="#测验答案-2" class="headerlink" title="测验答案"></a>测验答案</h5><p>1）检测双向链表中是否存在环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty() || size &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在正确的双向链表中，每个节点的next.prev应该等于自己</span></span><br><span class="line">    <span class="comment">// 如果存在环，可能会出现不一致</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.next != <span class="literal">null</span> &amp;&amp; current.next.prev != current) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current.next;</span><br><span class="line">        <span class="comment">// 如果回到了头节点，说明存在循环</span></span><br><span class="line">        <span class="keyword">if</span> (current == head) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）翻转双向链表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty() || size == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换每个节点的前向和后向指针</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 保存下一个节点</span></span><br><span class="line">        temp = current.next;</span><br><span class="line">        <span class="comment">// 交换当前节点的前向和后向指针</span></span><br><span class="line">        current.next = current.prev;</span><br><span class="line">        current.prev = temp;</span><br><span class="line">        <span class="comment">// 如果前一个节点为null，当前节点将成为新的尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (current.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            tail = current;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移动到下一个节点</span></span><br><span class="line">        current = temp;</span><br><span class="line">        <span class="comment">// 如果到达原始链表的头部，当前节点将成为新的头节点</span></span><br><span class="line">        <span class="keyword">if</span> (current == <span class="literal">null</span> &amp;&amp; temp != <span class="literal">null</span>) &#123;</span><br><span class="line">            head = temp.prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换头尾节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">oldHead</span> <span class="operator">=</span> head;</span><br><span class="line">    head = tail;</span><br><span class="line">    tail = oldHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）合并两个有序双向链表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DoublyLinkedList <span class="title function_">mergeSortedLists</span><span class="params">(DoublyLinkedList list1, DoublyLinkedList list2)</span> &#123;</span><br><span class="line">    <span class="type">DoublyLinkedList</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoublyLinkedList</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">Node</span> <span class="variable">current1</span> <span class="operator">=</span> list1.head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">current2</span> <span class="operator">=</span> list2.head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 比较两个链表的节点，将较小的加入结果链表</span></span><br><span class="line">    <span class="keyword">while</span> (current1 != <span class="literal">null</span> &amp;&amp; current2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current1.data &lt;= current2.data) &#123;</span><br><span class="line">            result.insertAtTail(current1.data);</span><br><span class="line">            current1 = current1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.insertAtTail(current2.data);</span><br><span class="line">            current2 = current2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将剩余节点加入结果链表</span></span><br><span class="line">    <span class="keyword">while</span> (current1 != <span class="literal">null</span>) &#123;</span><br><span class="line">        result.insertAtTail(current1.data);</span><br><span class="line">        current1 = current1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (current2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        result.insertAtTail(current2.data);</span><br><span class="line">        current2 = current2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4）查找中间节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">findMiddleNode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用快慢指针</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 快指针每次走两步，慢指针每次走一步</span></span><br><span class="line">    <span class="comment">// 当快指针到达尾部时，慢指针就在中间</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="六、栈"><a href="#六、栈" class="headerlink" title="六、栈"></a>六、栈</h3><p>栈是一种遵循后进先出(LIFO)原则的线性数据结构。只允许在一端（栈顶）进行插入和删除操作。适用于需要回溯的问题解决过程。</p>
<p><code>空间复杂度:O(n)</code></p>
<h5 id="算法讲解-5"><a href="#算法讲解-5" class="headerlink" title="算法讲解"></a>算法讲解</h5><h4 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h4><h5 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h5><p>栈是一种特殊的线性数据结构，遵循后进先出（Last-In-First-Out，LIFO）的原则。最后添加到栈中的元素将是第一个被移除的元素。可以将栈想象为一叠盘子，我们只能从顶部添加或移除盘子。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2025/09/26/68d6a0b33638d.webp" alt="img"></p>
<p>栈的操作仅限于栈顶，即只能在一端进行插入和删除操作。</p>
<h4 id="核心特性-5"><a href="#核心特性-5" class="headerlink" title="核心特性"></a>核心特性</h4><ol>
<li>后进先出(LIFO)：最后入栈的元素最先出栈</li>
<li>只允许在栈顶操作：只能在一端进行插入（压栈）和删除（弹栈）</li>
<li>快速访问栈顶元素：O(1)时间复杂度访问、添加和删除栈顶元素</li>
<li>元素访问受限：无法直接访问栈中间元素</li>
</ol>
<h4 id="基本操作-4"><a href="#基本操作-4" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="1-入栈-push"><a href="#1-入栈-push" class="headerlink" title="1. 入栈(push)"></a>1. 入栈(push)</h5><ul>
<li>时间复杂度：O(1)</li>
<li>描述：将元素添加到栈顶</li>
</ul>
<h5 id="2-出栈-pop"><a href="#2-出栈-pop" class="headerlink" title="2. 出栈(pop)"></a>2. 出栈(pop)</h5><ul>
<li>时间复杂度：O(1)</li>
<li>描述：移除并返回栈顶元素</li>
</ul>
<h5 id="3-查看栈顶-peek"><a href="#3-查看栈顶-peek" class="headerlink" title="3. 查看栈顶(peek)"></a>3. 查看栈顶(peek)</h5><ul>
<li>时间复杂度：O(1)</li>
<li>描述：查看栈顶元素但不移除</li>
</ul>
<h5 id="4-判断栈是否为空-isEmpty"><a href="#4-判断栈是否为空-isEmpty" class="headerlink" title="4. 判断栈是否为空(isEmpty)"></a>4. 判断栈是否为空(isEmpty)</h5><ul>
<li>时间复杂度：O(1)</li>
<li>描述：检查栈中是否有元素</li>
</ul>
<h5 id="5-获取栈大小-size"><a href="#5-获取栈大小-size" class="headerlink" title="5. 获取栈大小(size)"></a>5. 获取栈大小(size)</h5><ul>
<li>时间复杂度：O(1)</li>
<li>描述：获取栈中元素的数量</li>
</ul>
<h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建栈</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 入栈</span></span><br><span class="line">        stack.push(<span class="number">10</span>);</span><br><span class="line">        stack.push(<span class="number">20</span>);</span><br><span class="line">        stack.push(<span class="number">30</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;栈: &quot;</span> + stack); <span class="comment">// 输出: [10, 20, 30]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查看栈顶元素（不移除）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">topElement</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">        System.out.println(<span class="string">&quot;栈顶元素: &quot;</span> + topElement); <span class="comment">// 输出: 30</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 出栈</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">poppedElement</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        System.out.println(<span class="string">&quot;弹出的元素: &quot;</span> + poppedElement); <span class="comment">// 输出: 30</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查栈是否为空</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> stack.isEmpty();</span><br><span class="line">        System.out.println(<span class="string">&quot;栈是否为空: &quot;</span> + isEmpty); <span class="comment">// 输出: false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取栈大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> stack.size();</span><br><span class="line">        System.out.println(<span class="string">&quot;栈大小: &quot;</span> + size); <span class="comment">// 输出: 2</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;最终栈: &quot;</span> + stack); <span class="comment">// 输出: [10, 20]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<h4 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h5><ol>
<li>实现简单：栈的概念和实现都很简单直观</li>
<li>操作高效：所有基本操作的时间复杂度都是O(1)</li>
<li>内存管理：对于某些语言，会用于管理内存和跟踪函数调用</li>
</ol>
<h5 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>访问限制：只能访问栈顶元素，无法直接访问中间元素</li>
<li>没有随机访问：获取中间元素需要先弹出上面所有元素</li>
<li>不适合频繁搜索：查找特定值的时间复杂度为O(n)</li>
</ol>
<h4 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li>函数调用和递归：存储函数调用的返回地址和局部变量</li>
<li>表达式求值：处理中缀、前缀和后缀表达式</li>
<li>撤销操作：实现程序中的撤销功能</li>
<li>浏览器历史：实现浏览器的”后退”功能</li>
<li>深度优先搜索(DFS)：使用栈记录访问路径</li>
<li>内存分配：某些系统中使用栈来分配内存</li>
</ol>
<h4 id="扩展：单调栈"><a href="#扩展：单调栈" class="headerlink" title="扩展：单调栈"></a>扩展：单调栈</h4><p>单调栈是特殊的栈结构，保持栈中元素单调递增或递减。当新元素破坏栈的单调性时，会弹出栈顶元素直到满足单调性。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>以数组 [3,6,4,6,9,2] 构建单调递增栈的过程：</p>
<ol>
<li>初始栈为空 []</li>
<li>遇到3：入栈 → [3]</li>
<li>遇到6：大于栈顶，入栈 → [3,6]</li>
<li>遇到4：小于栈顶6，弹出6；4大于新栈顶3，入栈 → [3,4]</li>
<li>遇到6：大于栈顶，入栈 → [3,4,6]</li>
<li>遇到9：大于栈顶，入栈 → [3,4,6,9]</li>
<li>遇到2：小于栈顶，弹出9,6,4,3直至栈空；入栈 → [2]</li>
</ol>
<h4 id="测验-5"><a href="#测验-5" class="headerlink" title="测验"></a>测验</h4><ol>
<li>栈的主要特点是什么？</li>
<li>栈的push和pop操作的时间复杂度是多少？为什么？</li>
<li>栈和队列的主要区别是什么？</li>
<li>在Java中，Stack类继承自哪个类？这种设计有什么问题？</li>
</ol>
<blockquote>
<p>测验答案</p>
<ol>
<li>栈的主要特点是后进先出(LIFO)，即最后入栈的元素最先出栈。</li>
<li>都是O(1)。因为这些操作只在栈顶进行，不需要访问或移动其他元素。</li>
<li>栈遵循后进先出(LIFO)原则，而队列遵循先进先出(FIFO)原则。即，栈只允许在一端（栈顶）进行操作，而队列允许在一端（队尾）插入，另一端（队头）删除。</li>
<li>在Java中，Stack类继承自Vector类。Vector是一个列表实现，提供了随机访问等与栈原则不符的操作，破坏了栈的封装性。</li>
</ol>
</blockquote>
<h3 id="七、队列"><a href="#七、队列" class="headerlink" title="七、队列"></a>七、队列</h3><p>队列是一种遵循先进先出(FIFO)原则的线性数据结构。只允许在队尾进行插入操作，在队首进行删除操作。适用于需要按照到达顺序处理的问题。</p>
<p><code>空间复杂度:O(n)</code></p>
<h5 id="算法讲解-6"><a href="#算法讲解-6" class="headerlink" title="算法讲解"></a>算法讲解</h5><h4 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h4><h5 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h5><p>队列是一种特殊的线性数据结构，遵循先进先出（First-In-First-Out，FIFO）的原则。最先添加到队列中的元素将是第一个被移除的元素。可以将队列想象为排队购票的人群，先到的人先办理业务，后到的人排在队尾等待。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2025/09/26/68d6a12f93403.webp" alt="img"></p>
<p>队列的操作通常在两端进行：一端（队尾）只用来添加元素，另一端（队头）只用来删除元素。</p>
<h4 id="核心特性-6"><a href="#核心特性-6" class="headerlink" title="核心特性"></a>核心特性</h4><ol>
<li>先进先出(FIFO)：最先入队的元素最先出队</li>
<li>两端操作：在队尾添加元素，在队头删除元素</li>
<li>快速访问首尾元素：O(1)时间复杂度访问队头和队尾元素</li>
<li>元素访问受限：无法直接访问队列中间元素</li>
</ol>
<h4 id="基本操作-5"><a href="#基本操作-5" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="1-入队-enqueue"><a href="#1-入队-enqueue" class="headerlink" title="1. 入队(enqueue)"></a>1. 入队(enqueue)</h5><ul>
<li>时间复杂度：O(1)</li>
<li>描述：将元素添加到队列尾部</li>
</ul>
<h5 id="2-出队-dequeue"><a href="#2-出队-dequeue" class="headerlink" title="2. 出队(dequeue)"></a>2. 出队(dequeue)</h5><ul>
<li>时间复杂度：O(1)</li>
<li>描述：移除并返回队列头部元素</li>
</ul>
<h5 id="3-查看队头-peek-front"><a href="#3-查看队头-peek-front" class="headerlink" title="3. 查看队头(peek/front)"></a>3. 查看队头(peek/front)</h5><ul>
<li>时间复杂度：O(1)</li>
<li>描述：查看队头元素但不移除</li>
</ul>
<h5 id="4-判断队列是否为空-isEmpty"><a href="#4-判断队列是否为空-isEmpty" class="headerlink" title="4. 判断队列是否为空(isEmpty)"></a>4. 判断队列是否为空(isEmpty)</h5><ul>
<li>时间复杂度：O(1)</li>
<li>描述：检查队列中是否有元素</li>
</ul>
<h5 id="5-获取队列大小-size"><a href="#5-获取队列大小-size" class="headerlink" title="5. 获取队列大小(size)"></a>5. 获取队列大小(size)</h5><ul>
<li>时间复杂度：O(1)</li>
<li>描述：获取队列中元素的数量</li>
</ul>
<h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">        #### 使用Java内置的Queue接口</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueueExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建队列（使用LinkedList实现）</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        queue.offer(<span class="number">10</span>);</span><br><span class="line">        queue.offer(<span class="number">20</span>);</span><br><span class="line">        queue.offer(<span class="number">30</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;队列: &quot;</span> + queue); <span class="comment">// 输出: [10, 20, 30]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查看队头元素（不移除）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">frontElement</span> <span class="operator">=</span> queue.peek();</span><br><span class="line">        System.out.println(<span class="string">&quot;队头元素: &quot;</span> + frontElement); <span class="comment">// 输出: 10</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 出队</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dequeuedElement</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        System.out.println(<span class="string">&quot;出队的元素: &quot;</span> + dequeuedElement); <span class="comment">// 输出: 10</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查队列是否为空</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> queue.isEmpty();</span><br><span class="line">        System.out.println(<span class="string">&quot;队列是否为空: &quot;</span> + isEmpty); <span class="comment">// 输出: false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取队列大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        System.out.println(<span class="string">&quot;队列大小: &quot;</span> + size); <span class="comment">// 输出: 2</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;最终队列: &quot;</span> + queue); <span class="comment">// 输出: [20, 30]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<h4 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h5><ol>
<li>实现简单：队列的概念和实现都很简单直观</li>
<li>操作高效：基本操作的时间复杂度都是O(1)</li>
<li>有序处理：保证元素按照添加的顺序处理</li>
<li>适合数据流处理：适用于需要按顺序处理数据的场景</li>
</ol>
<h5 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>访问限制：只能访问队头和队尾元素，无法直接访问中间元素</li>
<li>移除元素受限：只能按先进先出的顺序移除元素</li>
<li>不适合随机访问：获取中间元素需要先出队前面所有元素</li>
</ol>
<h4 id="应用场景-6"><a href="#应用场景-6" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li>任务调度：操作系统中的进程调度</li>
<li>消息队列：分布式系统中的消息传递</li>
<li>缓冲区管理：I/O操作中的数据缓冲</li>
<li>广度优先搜索(BFS)：图算法中使用队列存储待访问的节点</li>
<li>打印任务管理：打印机任务队列</li>
<li>网络数据包处理：网络设备中数据包的处理顺序</li>
</ol>
<h4 id="测验-6"><a href="#测验-6" class="headerlink" title="测验"></a>测验</h4><ol>
<li>队列的主要特点是什么？</li>
<li>队列的enqueue和dequeue操作的时间复杂度是多少？</li>
<li>与栈相比，队列的主要区别是什么？</li>
</ol>
<blockquote>
<p>测验答案</p>
<ol>
<li><h4 id="队列的主要特点是先进先出-FIFO-，即最先入队的元素最先出队。"><a href="#队列的主要特点是先进先出-FIFO-，即最先入队的元素最先出队。" class="headerlink" title="队列的主要特点是先进先出(FIFO)，即最先入队的元素最先出队。"></a>队列的主要特点是先进先出(FIFO)，即最先入队的元素最先出队。</h4></li>
<li><p>都是O(1)。在使用链表或正确实现的数组（循环队列）的情况下，这些操作都是常数时间的。</p>
</li>
<li><p>队列遵循先进先出(FIFO)原则，而栈遵循后进先出(LIFO)原则。队列在两端操作（一端入队，另一端出队），而栈只在一端（栈顶）操作。</p>
</li>
</ol>
</blockquote>
<h3 id="八、循环队列"><a href="#八、循环队列" class="headerlink" title="八、循环队列"></a>八、循环队列</h3><p>循环队列是一种特殊的队列，它的首尾相连，形成一个环。通过使用固定大小的数组和两个指针（front和rear）来实现。当队尾指针到达数组末尾时，它会绕回到数组开始位置，从而有效利用空间。</p>
<p><code>空间复杂度:O(n) - 固定大小</code></p>
<h5 id="算法讲解-7"><a href="#算法讲解-7" class="headerlink" title="算法讲解"></a>算法讲解</h5><h4 id="循环队列-Circular-Queue"><a href="#循环队列-Circular-Queue" class="headerlink" title="循环队列(Circular Queue)"></a>循环队列(Circular Queue)</h4><h5 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h5><p>循环队列是队列的一种变体，采用环形结构设计，解决了普通队列在数组实现中的”假溢出”问题。在普通队列中，随着元素的入队和出队，队头指针不断后移，会导致队列前部空间无法重复利用。而循环队列通过将队列的头尾相连，形成一个环形结构，可以重复利用这些空间。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2025/09/26/68d6a18e165ec.webp" alt="img"></p>
<p>循环队列一般用数组实现，通过两个指针（队头和队尾）和一些简单的计算来模拟循环结构。</p>
<h4 id="核心特性-7"><a href="#核心特性-7" class="headerlink" title="核心特性"></a>核心特性</h4><ul>
<li>环形结构：当到达数组末尾时，下一个位置回到数组开头</li>
<li>空间重用：出队后的空间可以在后续入队操作中重复使用</li>
<li>高效的内存利用：避免了普通队列实现中的”假溢出”问题</li>
<li>固定大小：初始化时指定容量，一般不支持动态扩容</li>
<li>双指针管理：用front和rear指针跟踪队列状态</li>
</ul>
<h4 id="基本操作-6"><a href="#基本操作-6" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="1-入队-enqueue-1"><a href="#1-入队-enqueue-1" class="headerlink" title="1. 入队(enqueue)"></a>1. 入队(enqueue)</h5><ul>
<li>时间复杂度：O(1)</li>
<li>描述：将元素添加到队列尾部，并更新尾指针</li>
</ul>
<h5 id="2-出队-dequeue-1"><a href="#2-出队-dequeue-1" class="headerlink" title="2. 出队(dequeue)"></a>2. 出队(dequeue)</h5><ul>
<li>时间复杂度：O(1)</li>
<li>描述：移除并返回队列头部元素，并更新头指针</li>
</ul>
<h5 id="3-查看队头-peek-front-1"><a href="#3-查看队头-peek-front-1" class="headerlink" title="3. 查看队头(peek/front)"></a>3. 查看队头(peek/front)</h5><ul>
<li>时间复杂度：O(1)</li>
<li>描述：查看队头元素但不移除</li>
</ul>
<h5 id="4-判断队列是否为空-isEmpty-1"><a href="#4-判断队列是否为空-isEmpty-1" class="headerlink" title="4. 判断队列是否为空(isEmpty)"></a>4. 判断队列是否为空(isEmpty)</h5><ul>
<li>时间复杂度：O(1)</li>
<li>描述：检查队列中是否有元素</li>
</ul>
<h5 id="5-判断队列是否已满-isFull"><a href="#5-判断队列是否已满-isFull" class="headerlink" title="5. 判断队列是否已满(isFull)"></a>5. 判断队列是否已满(isFull)</h5><ul>
<li>时间复杂度：O(1)</li>
<li>描述：检查队列是否已达到最大容量</li>
</ul>
<h4 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircularQueue</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front; <span class="comment">// 队头指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;  <span class="comment">// 队尾指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;  <span class="comment">// 当前元素数量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CircularQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.array = <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">        <span class="built_in">this</span>.front = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.rear = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 入队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">enqueue</span><span class="params">(T item)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 队列已满</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        array[rear] = item;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % capacity; <span class="comment">// 循环更新尾指针</span></span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 出队</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 队列为空</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">T</span> <span class="variable">item</span> <span class="operator">=</span> (T) array[front];</span><br><span class="line">        array[front] = <span class="literal">null</span>; <span class="comment">// 避免内存泄漏</span></span><br><span class="line">        front = (front + <span class="number">1</span>) % capacity; <span class="comment">// 循环更新头指针</span></span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查看队头元素</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (T) array[front];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断队列是否已满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size == capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取队列当前大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        CircularQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">CircularQueue</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 入队操作</span></span><br><span class="line">        queue.enqueue(<span class="number">10</span>);</span><br><span class="line">        queue.enqueue(<span class="number">20</span>);</span><br><span class="line">        queue.enqueue(<span class="number">30</span>);</span><br><span class="line">        queue.enqueue(<span class="number">40</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;队列大小: &quot;</span> + queue.size()); <span class="comment">// 输出: 4</span></span><br><span class="line">        System.out.println(<span class="string">&quot;队头元素: &quot;</span> + queue.peek());  <span class="comment">// 输出: 10</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 出队操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;出队元素: &quot;</span> + queue.dequeue()); <span class="comment">// 输出: 10</span></span><br><span class="line">        System.out.println(<span class="string">&quot;出队元素: &quot;</span> + queue.dequeue()); <span class="comment">// 输出: 20</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 继续入队，演示循环利用空间</span></span><br><span class="line">        queue.enqueue(<span class="number">50</span>);</span><br><span class="line">        queue.enqueue(<span class="number">60</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;队列是否已满: &quot;</span> + queue.isFull()); <span class="comment">// 输出: true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;队列大小: &quot;</span> + queue.size());      <span class="comment">// 输出: 4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<h4 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h5><ol>
<li>高效空间利用：可以重用已出队的空间，避免”假溢出”问题</li>
<li>固定内存开销：内存使用量可预测，适合内存受限环境</li>
<li>操作高效：所有基本操作都是O(1)时间复杂度</li>
<li>实现简单：比链表实现的队列更简单，内存布局更紧凑</li>
</ol>
<h5 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>固定大小：初始化后容量固定，不易动态调整</li>
<li>空间判断复杂：需要额外的计数或标记来区分队列满和空的状态</li>
<li>不支持随机访问：只能访问队头和队尾元素</li>
<li>内存分配低效：若设置过大可能造成内存浪费，过小则频繁溢出</li>
</ol>
<h4 id="应用场景-7"><a href="#应用场景-7" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li>缓冲区实现：键盘缓冲、打印机队列等I/O操作</li>
<li>内存管理：操作系统中的内存页面置换算法</li>
<li>任务调度：嵌入式系统中的任务调度器</li>
<li>数据流处理：有界的生产者消费者模式</li>
<li>CPU调度：操作系统中的进程调度</li>
</ol>
<h4 id="测验-7"><a href="#测验-7" class="headerlink" title="测验"></a>测验</h4><ol>
<li>循环队列与普通队列的主要区别是什么？</li>
<li>在循环队列中，怎么判断队列是空还是满？</li>
<li>当循环队列的rear指针到达数组末尾时，下一个元素应该被放在哪里？</li>
<li>循环队列解决了什么问题？</li>
<li>在实现循环队列时，如何计算下一个位置的索引？</li>
</ol>
<blockquote>
<p>测验答案</p>
<ol>
<li>循环队列采用环形结构设计，可以重复利用出队后的空间，解决了普通队列在数组实现中的”假溢出”问题。</li>
<li>有多种方法：(1)使用一个额外的计数变量size来记录元素数量；(2)保持一个空位，当(rear+1)%capacity==front时队列满；(3)使用一个标志变量来区分。</li>
<li>应该被放在数组的开头(索引0)，这就是循环队列的环形特性。</li>
<li>循环队列解决了普通数组实现队列时的”假溢出”问题，即队列前部有空间但无法使用的情况。</li>
<li>使用取模运算：(current_index + 1) % capacity。这样当索引到达数组末尾时，会自动回到开头。</li>
</ol>
</blockquote>
<h3 id="九、优先队列"><a href="#九、优先队列" class="headerlink" title="九、优先队列"></a>九、优先队列</h3><p>优先队列是一种特殊的队列，其中每个元素都有一个优先级。高优先级的元素会比低优先级的元素先被处理。</p>
<h5 id="算法讲解-8"><a href="#算法讲解-8" class="headerlink" title="算法讲解"></a>算法讲解</h5><h4 id="优先队列-Priority-Queue"><a href="#优先队列-Priority-Queue" class="headerlink" title="优先队列(Priority Queue)"></a>优先队列(Priority Queue)</h4><h5 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h5><p>优先队列是一种特殊的队列，它不遵循先进先出的原则，而是根据元素的优先级来决定出队顺序。在优先队列中，不管元素的入队顺序如何，优先级高的元素会优先出队。</p>
<p>优先队列内部一般使用堆（二叉堆）来实现，方便高效地维护元素的优先级顺序。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2025/09/26/68d6a1e4375c3.webp" alt="img"></p>
<h4 id="核心特性-8"><a href="#核心特性-8" class="headerlink" title="核心特性"></a>核心特性</h4><ul>
<li>基于优先级出队：元素的出队顺序由优先级决定</li>
<li>自动排序：插入新元素后，队列会自动调整来维持优先级顺序</li>
<li>快速获取最高优先级元素：O(1)时间复杂度访问最高优先级元素</li>
<li>支持两种堆结构：最大堆（最大值优先）和最小堆（最小值优先）</li>
<li>动态维护：插入和删除操作后都会保持优先级有序</li>
</ul>
<h4 id="基本操作-7"><a href="#基本操作-7" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="入队-enqueue-insert"><a href="#入队-enqueue-insert" class="headerlink" title="入队(enqueue/insert)"></a>入队(enqueue/insert)</h5><ul>
<li>时间复杂度：O(log n)</li>
<li>描述：将元素添加到优先队列中，并根据优先级调整位置</li>
</ul>
<h5 id="出队-dequeue-extractMax-extractMin"><a href="#出队-dequeue-extractMax-extractMin" class="headerlink" title="出队(dequeue/extractMax/extractMin)"></a>出队(dequeue/extractMax/extractMin)</h5><ul>
<li>时间复杂度：O(log n)</li>
<li>描述：移除并返回优先级最高的元素</li>
</ul>
<h5 id="查看顶部元素-peek-top"><a href="#查看顶部元素-peek-top" class="headerlink" title="查看顶部元素(peek/top)"></a>查看顶部元素(peek/top)</h5><ul>
<li>时间复杂度：O(1)</li>
<li>描述：查看优先级最高的元素但不移除</li>
</ul>
<h5 id="判断队列是否为空-isEmpty"><a href="#判断队列是否为空-isEmpty" class="headerlink" title="判断队列是否为空(isEmpty)"></a>判断队列是否为空(isEmpty)</h5><ul>
<li>时间复杂度：O(1)</li>
<li>描述：检查优先队列中是否有元素</li>
</ul>
<h5 id="获取队列大小-size"><a href="#获取队列大小-size" class="headerlink" title="获取队列大小(size)"></a>获取队列大小(size)</h5><ul>
<li>时间复杂度：O(1)</li>
<li>描述：获取优先队列中元素的数量</li>
</ul>
<h4 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueueExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建最小堆（默认）</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        minHeap.offer(<span class="number">30</span>);</span><br><span class="line">        minHeap.offer(<span class="number">10</span>);</span><br><span class="line">        minHeap.offer(<span class="number">20</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;优先队列: &quot;</span> + minHeap); <span class="comment">// 注意：打印顺序可能不是实际的优先级顺序</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查看最高优先级元素（最小值）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">highestPriority</span> <span class="operator">=</span> minHeap.peek();</span><br><span class="line">        System.out.println(<span class="string">&quot;最高优先级元素: &quot;</span> + highestPriority); <span class="comment">// 输出: 10</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 移除最高优先级元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">removed</span> <span class="operator">=</span> minHeap.poll();</span><br><span class="line">        System.out.println(<span class="string">&quot;移除的元素: &quot;</span> + removed); <span class="comment">// 输出: 10</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建最大堆（通过比较器）</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.reverseOrder());</span><br><span class="line">        </span><br><span class="line">        maxHeap.offer(<span class="number">30</span>);</span><br><span class="line">        maxHeap.offer(<span class="number">10</span>);</span><br><span class="line">        maxHeap.offer(<span class="number">20</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;最大堆顶部元素: &quot;</span> + maxHeap.peek()); <span class="comment">// 输出: 30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<h4 id="优缺点-7"><a href="#优缺点-7" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点-8"><a href="#优点-8" class="headerlink" title="优点"></a>优点</h5><ol>
<li>基于优先级处理：支持根据元素重要性决定处理顺序</li>
<li>高效的优先级维护：入队和出队操作的时间复杂度为O(log n)</li>
<li>灵活的优先级定义：可以通过比较器自定义元素的优先级规则</li>
<li>实现简单：基于堆的实现相对简单，比较容易理解</li>
</ol>
<h5 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>操作复杂度较高：比普通队列的O(1)操作复杂度高</li>
<li>不保证FIFO顺序：相同优先级的元素不保证按照入队顺序出队</li>
<li>更新优先级困难：大多数实现不支持直接更新已存在元素的优先级</li>
<li>内存开销：通常比简单队列需要更多内存来维护堆结构</li>
</ol>
<h4 id="应用场景-8"><a href="#应用场景-8" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li>任务调度：操作系统中基于优先级的进程调度</li>
<li>图算法：Dijkstra最短路径、Prim最小生成树等算法</li>
<li>贪心算法：需要每次选择最优元素的场景</li>
<li>事件驱动模拟：基于时间顺序处理事件</li>
<li>医疗急诊系统：病人分级处理</li>
<li>网络流量管理：QoS（服务质量）保证</li>
</ol>
<h4 id="测验-8"><a href="#测验-8" class="headerlink" title="测验"></a>测验</h4><ol>
<li>优先队列与普通队列的主要区别是什么？</li>
<li>基于二叉堆实现的优先队列中，入队操作的时间复杂度是多少？</li>
<li>在Java中，PriorityQueue默认是最小堆还是最大堆？如何创建最大堆？</li>
<li>什么是二叉堆？它有什么特性？</li>
</ol>
<blockquote>
<p>测验答案</p>
<ol>
<li>优先队列按照元素的优先级决定出队顺序.</li>
<li>入队操作的时间复杂度是O(log n)，因为需要进行上浮操作来维护堆。</li>
<li>Java中的PriorityQueue默认是最小堆。可以通过提供一个自定义的Comparator来创建最大堆，例如：<code>PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(Comparator.reverseOrder());</code></li>
<li>二叉堆是一种特殊的完全二叉树，它有两种类型：最小堆（父节点值小于等于子节点）和最大堆（父节点值大于等于子节点）。它的特性包括：完全二叉树结构、父子节点间的大小关系、可以高效地找到最大/最小元素。</li>
</ol>
</blockquote>
<h2 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h2><h3 id="一、二叉树"><a href="#一、二叉树" class="headerlink" title="一、二叉树"></a>一、二叉树</h3><p>二叉树是一种树形数据结构，其中每个节点最多有两个子节点，分别称为左子节点和右子节点。二叉树广泛应用于计算机科学中，用于实现搜索算法、排序算法和数据压缩等。</p>
<p><code>空间复杂度:O(n)</code></p>
<h5 id="算法讲解-9"><a href="#算法讲解-9" class="headerlink" title="算法讲解"></a>算法讲解</h5><h4 id="二叉树-Binary-Tree"><a href="#二叉树-Binary-Tree" class="headerlink" title="二叉树(Binary Tree)"></a>二叉树(Binary Tree)</h4><h5 id="介绍-9"><a href="#介绍-9" class="headerlink" title="介绍"></a>介绍</h5><p>二叉树是一种层次化的数据结构，每个节点最多有两个子节点，通常称为”左子节点”和”右子节点”。二叉树的这种特性使其成为表示层次关系的理想结构。与线性数据结构（如数组、链表）不同，二叉树是非线性的，能够更高效地表示和处理具有层次特性的数据。</p>
<p>二叉树中的核心概念包括：</p>
<ul>
<li>节点(Node): 树的基本单位，包含数据和指向子节点的引用</li>
<li>根节点(Root): 树的顶部节点，是整棵树的入口点</li>
<li>叶节点(Leaf): 没有子节点的节点</li>
<li>父节点(Parent): 有子节点的节点</li>
<li>子节点(Child): 某节点的直接后代</li>
<li>深度(Depth): 从根节点到特定节点的路径长度</li>
<li>高度(Height): 从特定节点到其最远叶节点的路径长度，空树的高度通常定义为 -1（有时也定义为0，取决于教材）。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2025/09/26/68d6a27a0c767.webp" alt="img"></p>
<h4 id="核心特性-9"><a href="#核心特性-9" class="headerlink" title="核心特性"></a>核心特性</h4><p>二叉树的核心特性体现在结构和操作方式上。</p>
<p>每个节点最多拥有两个子节点，这使二叉树的结构清晰且易于操作。二叉树可以是空的，也可以只包含一个根节点，甚至可以发展成复杂的多层次结构。</p>
<p>二叉树还有多种特殊形式，比如满二叉树（每个节点都有0个或2个子节点）、完全二叉树（除最后一层外都被填满，且最后一层从左到右填充）、平衡二叉树（任意节点的左右子树高度差不超过1）等，这些特殊形式各有其应用场景和优势。</p>
<p>二叉树的遍历方式一般有四种：前序、中序、后序和层序遍历，这些方式能够按照不同的顺序访问树中的节点，满足不同的数据处理需求。</p>
<h4 id="基本操作-8"><a href="#基本操作-8" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="1-创建二叉树"><a href="#1-创建二叉树" class="headerlink" title="1. 创建二叉树"></a>1. 创建二叉树</h5><p>创建二叉树可以通过多种方式，比如逐个插入节点构建，或者通过预定义的数组转换为二叉树。创建过程涉及节点的实例化和连接，是二叉树操作的基础。</p>
<h5 id="2-遍历二叉树"><a href="#2-遍历二叉树" class="headerlink" title="2. 遍历二叉树"></a>2. 遍历二叉树</h5><p>二叉树的遍历是指按照特定顺序访问树中的每个节点。常见的遍历方式有四种：</p>
<ul>
<li>前序遍历(Preorder): 先访问根节点，然后遍历左子树，最后遍历右子树，遵循”根-左-右”的访问顺序。</li>
<li>中序遍历(Inorder): 先遍历左子树，然后访问根节点，最后遍历右子树，遵循”左-根-右”的访问顺序。</li>
<li>后序遍历(Postorder): 先遍历左子树，然后遍历右子树，最后访问根节点，遵循”左-右-根”的访问顺序。</li>
<li>层序遍历(Level-order): 按照从上到下、从左到右的顺序逐层访问节点。</li>
</ul>
<h5 id="3-查找节点"><a href="#3-查找节点" class="headerlink" title="3. 查找节点"></a>3. 查找节点</h5><p>在二叉树中查找特定值的节点，通常是遍历二叉树来实现。根据树的特性（如是否为二叉搜索树），查找的效率会有所不同。</p>
<h5 id="4-插入节点"><a href="#4-插入节点" class="headerlink" title="4. 插入节点"></a>4. 插入节点</h5><p>向二叉树中添加新节点，具体插入位置取决于树的类型和规则。在二叉搜索树中，新节点会根据值与现有节点的比较结果来确定位置。</p>
<h5 id="5-删除节点-1"><a href="#5-删除节点-1" class="headerlink" title="5. 删除节点"></a>5. 删除节点</h5><p>从二叉树中移除节点，同时保持树的结构完整。删除操作可能涉及节点的替换和子树的重新链接，属于复杂操作。</p>
<h4 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode root;  <span class="comment">// 根节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造空二叉树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinaryTree</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造带根节点的二叉树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinaryTree</span><span class="params">(<span class="type">int</span> rootValue)</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootValue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取根节点</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">getRoot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断树是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入节点（简单实现：若树为空则作为根节点，否则作为左子节点，若左子节点存在则作为右子节点）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(value);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            root = newNode;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用队列进行层序遍历，找到第一个没有左子节点或右子节点的节点</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果没有左子节点，将新节点作为左子节点</span></span><br><span class="line">            <span class="keyword">if</span> (current.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                current.left = newNode;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 如果没有右子节点，将新节点作为右子节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                current.right = newNode;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将子节点加入队列</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                queue.add(current.left);</span><br><span class="line">                queue.add(current.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorderTraversal</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 访问根节点</span></span><br><span class="line">        System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历左子树</span></span><br><span class="line">        preorderTraversal(node.left);</span><br><span class="line">        <span class="comment">// 遍历右子树</span></span><br><span class="line">        preorderTraversal(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorderTraversal</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历左子树</span></span><br><span class="line">        inorderTraversal(node.left);</span><br><span class="line">        <span class="comment">// 访问根节点</span></span><br><span class="line">        System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历右子树</span></span><br><span class="line">        inorderTraversal(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorderTraversal</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历左子树</span></span><br><span class="line">        postorderTraversal(node.left);</span><br><span class="line">        <span class="comment">// 遍历右子树</span></span><br><span class="line">        postorderTraversal(node.right);</span><br><span class="line">        <span class="comment">// 访问根节点</span></span><br><span class="line">        System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 层序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">levelOrderTraversal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            System.out.print(current.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (current.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(current.left);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (current.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(current.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> height(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> height(node.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取节点数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + countNodes(node.left) + countNodes(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找值为value的节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(TreeNode node, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (node.val == value) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在左右子树中查找</span></span><br><span class="line">        <span class="keyword">return</span> search(node.left, value) || search(node.right, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用示例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 插入节点</span></span><br><span class="line">        tree.insert(<span class="number">1</span>);</span><br><span class="line">        tree.insert(<span class="number">2</span>);</span><br><span class="line">        tree.insert(<span class="number">3</span>);</span><br><span class="line">        tree.insert(<span class="number">4</span>);</span><br><span class="line">        tree.insert(<span class="number">5</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历:&quot;</span>);</span><br><span class="line">        tree.preorderTraversal(tree.getRoot());  <span class="comment">// 输出: 1 2 4 5 3</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;</span></span><br><span class="line"><span class="string">中序遍历:&quot;</span>);</span><br><span class="line">        tree.inorderTraversal(tree.getRoot());   <span class="comment">// 输出: 4 2 5 1 3</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;</span></span><br><span class="line"><span class="string">后序遍历:&quot;</span>);</span><br><span class="line">        tree.postorderTraversal(tree.getRoot()); <span class="comment">// 输出: 4 5 2 3 1</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;</span></span><br><span class="line"><span class="string">层序遍历:&quot;</span>);</span><br><span class="line">        tree.levelOrderTraversal();              <span class="comment">// 输出: 1 2 3 4 5</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;</span></span><br><span class="line"><span class="string">树的高度: &quot;</span> + tree.height(tree.getRoot()));</span><br><span class="line">        System.out.println(<span class="string">&quot;节点数量: &quot;</span> + tree.countNodes(tree.getRoot()));</span><br><span class="line">        System.out.println(<span class="string">&quot;是否包含值为3的节点: &quot;</span> + tree.search(tree.getRoot(), <span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;是否包含值为6的节点: &quot;</span> + tree.search(tree.getRoot(), <span class="number">6</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;           <span class="comment">// 节点值</span></span><br><span class="line">    TreeNode left;     <span class="comment">// 左子节点</span></span><br><span class="line">    TreeNode right;    <span class="comment">// 右子节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我将为您提供JavaScript和Python版本的二叉树实现，保持与Java版本相同的功能和结构。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 定义树节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">val</span> = val;        <span class="comment">// 节点值</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">left</span> = <span class="literal">null</span>;      <span class="comment">// 左子节点</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">right</span> = <span class="literal">null</span>;     <span class="comment">// 右子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">rootValue = <span class="literal">null</span></span>) &#123;</span><br><span class="line">        <span class="comment">// 构造空二叉树或带根节点的二叉树</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">root</span> = rootValue !== <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootValue) : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取根节点</span></span><br><span class="line">    <span class="title function_">getRoot</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断树是否为空</span></span><br><span class="line">    <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">root</span> === <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="title function_">insert</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(value);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">root</span> = newNode;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用队列进行层序遍历，找到第一个没有左子节点或右子节点的节点</span></span><br><span class="line">        <span class="keyword">const</span> queue = [<span class="variable language_">this</span>.<span class="property">root</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (queue.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> current = queue.<span class="title function_">shift</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果没有左子节点，将新节点作为左子节点</span></span><br><span class="line">            <span class="keyword">if</span> (current.<span class="property">left</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">                current.<span class="property">left</span> = newNode;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 如果没有右子节点，将新节点作为右子节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">                current.<span class="property">right</span> = newNode;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将子节点加入队列</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                queue.<span class="title function_">push</span>(current.<span class="property">left</span>);</span><br><span class="line">                queue.<span class="title function_">push</span>(current.<span class="property">right</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="title function_">preorderTraversal</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 访问根节点</span></span><br><span class="line">        process.<span class="property">stdout</span>.<span class="title function_">write</span>(node.<span class="property">val</span> + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历左子树</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">preorderTraversal</span>(node.<span class="property">left</span>);</span><br><span class="line">        <span class="comment">// 遍历右子树</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">preorderTraversal</span>(node.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="title function_">inorderTraversal</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历左子树</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">inorderTraversal</span>(node.<span class="property">left</span>);</span><br><span class="line">        <span class="comment">// 访问根节点</span></span><br><span class="line">        process.<span class="property">stdout</span>.<span class="title function_">write</span>(node.<span class="property">val</span> + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历右子树</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">inorderTraversal</span>(node.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="title function_">postorderTraversal</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历左子树</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">postorderTraversal</span>(node.<span class="property">left</span>);</span><br><span class="line">        <span class="comment">// 遍历右子树</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">postorderTraversal</span>(node.<span class="property">right</span>);</span><br><span class="line">        <span class="comment">// 访问根节点</span></span><br><span class="line">        process.<span class="property">stdout</span>.<span class="title function_">write</span>(node.<span class="property">val</span> + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 层序遍历</span></span><br><span class="line">    <span class="title function_">levelOrderTraversal</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> queue = [<span class="variable language_">this</span>.<span class="property">root</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (queue.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> current = queue.<span class="title function_">shift</span>();</span><br><span class="line">            process.<span class="property">stdout</span>.<span class="title function_">write</span>(current.<span class="property">val</span> + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (current.<span class="property">left</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.<span class="title function_">push</span>(current.<span class="property">left</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (current.<span class="property">right</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.<span class="title function_">push</span>(current.<span class="property">right</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算树的高度</span></span><br><span class="line">    <span class="title function_">height</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node === <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> leftHeight = <span class="variable language_">this</span>.<span class="title function_">height</span>(node.<span class="property">left</span>);</span><br><span class="line">        <span class="keyword">const</span> rightHeight = <span class="variable language_">this</span>.<span class="title function_">height</span>(node.<span class="property">right</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取节点数量</span></span><br><span class="line">    <span class="title function_">countNodes</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node === <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="variable language_">this</span>.<span class="title function_">countNodes</span>(node.<span class="property">left</span>) + <span class="variable language_">this</span>.<span class="title function_">countNodes</span>(node.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找值为value的节点</span></span><br><span class="line">    <span class="title function_">search</span>(<span class="params">node, value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (node.<span class="property">val</span> === value) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在左右子树中查找</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">search</span>(node.<span class="property">left</span>, value) || <span class="variable language_">this</span>.<span class="title function_">search</span>(node.<span class="property">right</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> tree = <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    tree.<span class="title function_">insert</span>(<span class="number">1</span>);</span><br><span class="line">    tree.<span class="title function_">insert</span>(<span class="number">2</span>);</span><br><span class="line">    tree.<span class="title function_">insert</span>(<span class="number">3</span>);</span><br><span class="line">    tree.<span class="title function_">insert</span>(<span class="number">4</span>);</span><br><span class="line">    tree.<span class="title function_">insert</span>(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;前序遍历:&quot;</span>);</span><br><span class="line">    tree.<span class="title function_">preorderTraversal</span>(tree.<span class="title function_">getRoot</span>());  <span class="comment">// 输出: 1 2 4 5 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;</span></span><br><span class="line"><span class="string">中序遍历:&quot;</span>);</span><br><span class="line">    tree.<span class="title function_">inorderTraversal</span>(tree.<span class="title function_">getRoot</span>());   <span class="comment">// 输出: 4 2 5 1 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;</span></span><br><span class="line"><span class="string">后序遍历:&quot;</span>);</span><br><span class="line">    tree.<span class="title function_">postorderTraversal</span>(tree.<span class="title function_">getRoot</span>()); <span class="comment">// 输出: 4 5 2 3 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;</span></span><br><span class="line"><span class="string">层序遍历:&quot;</span>);</span><br><span class="line">    tree.<span class="title function_">levelOrderTraversal</span>();              <span class="comment">// 输出: 1 2 3 4 5</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;</span></span><br><span class="line"><span class="string">树的高度: &quot;</span> + tree.<span class="title function_">height</span>(tree.<span class="title function_">getRoot</span>()));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;节点数量: &quot;</span> + tree.<span class="title function_">countNodes</span>(tree.<span class="title function_">getRoot</span>()));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;是否包含值为3的节点: &quot;</span> + tree.<span class="title function_">search</span>(tree.<span class="title function_">getRoot</span>(), <span class="number">3</span>));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;是否包含值为6的节点: &quot;</span> + tree.<span class="title function_">search</span>(tree.<span class="title function_">getRoot</span>(), <span class="number">6</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行示例</span></span><br><span class="line"><span class="title function_">main</span>();</span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<p>我将为您提供Go和C++版本的二叉树实现，保持与之前版本相同的功能和结构。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;container/list&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeNode 定义树节点结构</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Val   <span class="type">int</span>       <span class="comment">// 节点值</span></span><br><span class="line">	Left  *TreeNode <span class="comment">// 左子节点</span></span><br><span class="line">	Right *TreeNode <span class="comment">// 右子节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BinaryTree 定义二叉树结构</span></span><br><span class="line"><span class="keyword">type</span> BinaryTree <span class="keyword">struct</span> &#123;</span><br><span class="line">	root *TreeNode <span class="comment">// 根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewBinaryTree 创建空二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBinaryTree</span><span class="params">()</span></span> *BinaryTree &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;BinaryTree&#123;root: <span class="literal">nil</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewBinaryTreeWithRoot 创建带根节点的二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBinaryTreeWithRoot</span><span class="params">(rootValue <span class="type">int</span>)</span></span> *BinaryTree &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;BinaryTree&#123;root: &amp;TreeNode&#123;Val: rootValue&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetRoot 获取根节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bt *BinaryTree)</span></span> GetRoot() *TreeNode &#123;</span><br><span class="line">	<span class="keyword">return</span> bt.root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IsEmpty 判断树是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bt *BinaryTree)</span></span> IsEmpty() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> bt.root == <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert 插入节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bt *BinaryTree)</span></span> Insert(value <span class="type">int</span>) &#123;</span><br><span class="line">	newNode := &amp;TreeNode&#123;Val: value&#125;</span><br><span class="line">	<span class="keyword">if</span> bt.IsEmpty() &#123;</span><br><span class="line">		bt.root = newNode</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用队列进行层序遍历，找到第一个没有左子节点或右子节点的节点</span></span><br><span class="line">	queue := list.New()</span><br><span class="line">	queue.PushBack(bt.root)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> queue.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		current := queue.Front().Value.(*TreeNode)</span><br><span class="line">		queue.Remove(queue.Front())</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果没有左子节点，将新节点作为左子节点</span></span><br><span class="line">		<span class="keyword">if</span> current.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">			current.Left = newNode</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果没有右子节点，将新节点作为右子节点</span></span><br><span class="line">		<span class="keyword">if</span> current.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">			current.Right = newNode</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将子节点加入队列</span></span><br><span class="line">		queue.PushBack(current.Left)</span><br><span class="line">		queue.PushBack(current.Right)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PreorderTraversal 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bt *BinaryTree)</span></span> PreorderTraversal(node *TreeNode) &#123;</span><br><span class="line">	<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 访问根节点</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d &quot;</span>, node.Val)</span><br><span class="line">	<span class="comment">// 遍历左子树</span></span><br><span class="line">	bt.PreorderTraversal(node.Left)</span><br><span class="line">	<span class="comment">// 遍历右子树</span></span><br><span class="line">	bt.PreorderTraversal(node.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InorderTraversal 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bt *BinaryTree)</span></span> InorderTraversal(node *TreeNode) &#123;</span><br><span class="line">	<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历左子树</span></span><br><span class="line">	bt.InorderTraversal(node.Left)</span><br><span class="line">	<span class="comment">// 访问根节点</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d &quot;</span>, node.Val)</span><br><span class="line">	<span class="comment">// 遍历右子树</span></span><br><span class="line">	bt.InorderTraversal(node.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PostorderTraversal 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bt *BinaryTree)</span></span> PostorderTraversal(node *TreeNode) &#123;</span><br><span class="line">	<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历左子树</span></span><br><span class="line">	bt.PostorderTraversal(node.Left)</span><br><span class="line">	<span class="comment">// 遍历右子树</span></span><br><span class="line">	bt.PostorderTraversal(node.Right)</span><br><span class="line">	<span class="comment">// 访问根节点</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d &quot;</span>, node.Val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LevelOrderTraversal 层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bt *BinaryTree)</span></span> LevelOrderTraversal() &#123;</span><br><span class="line">	<span class="keyword">if</span> bt.IsEmpty() &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	queue := list.New()</span><br><span class="line">	queue.PushBack(bt.root)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> queue.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		current := queue.Front().Value.(*TreeNode)</span><br><span class="line">		queue.Remove(queue.Front())</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d &quot;</span>, current.Val)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> current.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">			queue.PushBack(current.Left)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> current.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">			queue.PushBack(current.Right)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Height 计算树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bt *BinaryTree)</span></span> Height(node *TreeNode) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	leftHeight := bt.Height(node.Left)</span><br><span class="line">	rightHeight := bt.Height(node.Right)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> leftHeight &gt; rightHeight &#123;</span><br><span class="line">		<span class="keyword">return</span> leftHeight + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> rightHeight + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CountNodes 获取节点数量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bt *BinaryTree)</span></span> CountNodes(node *TreeNode) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span> + bt.CountNodes(node.Left) + bt.CountNodes(node.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Search 查找值为value的节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bt *BinaryTree)</span></span> Search(node *TreeNode, value <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> node.Val == value &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在左右子树中查找</span></span><br><span class="line">	<span class="keyword">return</span> bt.Search(node.Left, value) || bt.Search(node.Right, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	tree := NewBinaryTree()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 插入节点</span></span><br><span class="line">	tree.Insert(<span class="number">1</span>)</span><br><span class="line">	tree.Insert(<span class="number">2</span>)</span><br><span class="line">	tree.Insert(<span class="number">3</span>)</span><br><span class="line">	tree.Insert(<span class="number">4</span>)</span><br><span class="line">	tree.Insert(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;前序遍历:&quot;</span>)</span><br><span class="line">	tree.PreorderTraversal(tree.GetRoot()) <span class="comment">// 输出: 1 2 4 5 3</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;</span></span><br><span class="line"><span class="string">中序遍历:&quot;</span>)</span><br><span class="line">	tree.InorderTraversal(tree.GetRoot()) <span class="comment">// 输出: 4 2 5 1 3</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;</span></span><br><span class="line"><span class="string">后序遍历:&quot;</span>)</span><br><span class="line">	tree.PostorderTraversal(tree.GetRoot()) <span class="comment">// 输出: 4 5 2 3 1</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;</span></span><br><span class="line"><span class="string">层序遍历:&quot;</span>)</span><br><span class="line">	tree.LevelOrderTraversal() <span class="comment">// 输出: 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;</span></span><br><span class="line"><span class="string">树的高度:&quot;</span>, tree.Height(tree.GetRoot()))</span><br><span class="line">	fmt.Println(<span class="string">&quot;节点数量:&quot;</span>, tree.CountNodes(tree.GetRoot()))</span><br><span class="line">	fmt.Println(<span class="string">&quot;是否包含值为3的节点:&quot;</span>, tree.Search(tree.GetRoot(), <span class="number">3</span>))</span><br><span class="line">	fmt.Println(<span class="string">&quot;是否包含值为6的节点:&quot;</span>, tree.Search(tree.GetRoot(), <span class="number">6</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<h4 id="优缺点-8"><a href="#优缺点-8" class="headerlink" title="优缺点"></a>优缺点</h4><p>优势方面，二叉树能够高效地组织和检索数据。特别是在二叉搜索树中，查找、插入和删除操作的平均时间复杂度为O(log n)，比线性数据结构（如链表）的O(n)要好得多。二叉树的层次结构非常适合表示具有层次关系的数据，比如文件系统、组织结构。二叉树还支持多种遍历方式，数据处理非常灵活。</p>
<p>缺陷方便，普通二叉树可能会出现不平衡的情况，导致树的高度增加，降低操作效率。在最坏情况下（如链状树），操作的时间复杂度会退化到O(n)。相比于数组和哈希表，二叉树的实现和维护更复杂，需要管理节点之间的引用关系，比如红黑树、AVL树，实现和维护更加复杂。</p>
<h4 id="应用场景-9"><a href="#应用场景-9" class="headerlink" title="应用场景"></a>应用场景</h4><p>二叉树在计算机科学和实际应用中有着广泛的用途。</p>
<p>比如在表达式求值和编译器设计中，二叉树可以表示和计算表达式。通过构建语法树，编译器能够解析和执行复杂的编程语言结构。二叉树也常用于实现数据库索引，特别是B树和B+树这类二叉树的变种，能够支持高效的数据检索和范围查询。</p>
<p>再比如在计算机图形学领域，二叉树的变种如四叉树和八叉树用于空间分割和碰撞检测。二叉树在搜索算法中也有重要应用，如二分查找树可以高效地查找、插入和删除数据，而堆（一种特殊的二叉树）可以被用于实现优先队列和堆排序算法。</p>
<p>在文件系统组织和网络路由算法中，二叉树也很重要。通过树状结构，系统能够高效地管理文件和目录，找到网络中的最佳路径。</p>
<h4 id="扩展：二叉搜索树"><a href="#扩展：二叉搜索树" class="headerlink" title="扩展：二叉搜索树"></a>扩展：二叉搜索树</h4><p>二叉搜索树（Binary Search Tree, BST）是二叉树的一种特殊形式，它的特性：对于树中的每个节点，左子树中所有节点的值都小于该节点的值，右子树中所有节点的值都大于该节点的值。这种特性让二叉搜索树在查找、插入和删除操作上非常高效。</p>
<p>在二叉搜索树中，查找特定值的过程可以通过比较目标值与当前节点值的大小来确定搜索方向。如果目标值小于当前节点值，则在左子树中查找；如果大于当前节点值，则在右子树中查找；如果相等，则找到目标节点。查找操作的平均时间复杂度为O(log n)，远优于在普通二叉树中的O(n)。</p>
<p>不过当输入数据按照特定顺序插入时（如已排序的数据），二叉搜索树可能会退化成链表，导致操作效率降低。为了解决这个问题，出现了自平衡的二叉搜索树变种，比如AVL树和红黑树，它们通过旋转操作保持树的平衡，保证操作效率稳定在O(log n)。</p>
<h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> TreeNode root;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 二叉搜索树节点类</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">		<span class="type">int</span> val;</span><br><span class="line">		TreeNode left;</span><br><span class="line">		TreeNode right;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.val = val;</span><br><span class="line">			<span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">			<span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">BinarySearchTree</span><span class="params">()</span> &#123;</span><br><span class="line">		root = <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 插入节点</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">		root = insertRecursive(root, value);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> TreeNode <span class="title function_">insertRecursive</span><span class="params">(TreeNode node, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">		<span class="comment">// 如果树为空，创建新节点</span></span><br><span class="line">		<span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(value);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果值小于当前节点，插入左子树</span></span><br><span class="line">		<span class="keyword">if</span> (value &lt; node.val) &#123;</span><br><span class="line">			node.left = insertRecursive(node.left, value);</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="comment">// 如果值大于当前节点，插入右子树</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (value &gt; node.val) &#123;</span><br><span class="line">			node.right = insertRecursive(node.right, value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果值相等，不做任何改变（BST通常不允许重复值）</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 查找节点</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> searchRecursive(root, value);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">searchRecursive</span><span class="params">(TreeNode node, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">		<span class="comment">// 基本情况：树为空或找到目标值</span></span><br><span class="line">		<span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (node.val == value) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果值小于当前节点，搜索左子树</span></span><br><span class="line">		<span class="keyword">if</span> (value &lt; node.val) &#123;</span><br><span class="line">			<span class="keyword">return</span> searchRecursive(node.left, value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果值大于当前节点，搜索右子树</span></span><br><span class="line">		<span class="keyword">return</span> searchRecursive(node.right, value);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 中序遍历（得到排序结果）</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorderTraversal</span><span class="params">()</span> &#123;</span><br><span class="line">		inorderTraversalRecursive(root);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorderTraversalRecursive</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">		</span><br><span class="line">		inorderTraversalRecursive(node.left);</span><br><span class="line">		System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		inorderTraversalRecursive(node.right);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 删除节点</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">		root = deleteRecursive(root, value);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> TreeNode <span class="title function_">deleteRecursive</span><span class="params">(TreeNode node, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">		<span class="comment">// 树为空</span></span><br><span class="line">		<span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 搜索要删除的节点</span></span><br><span class="line">		<span class="keyword">if</span> (value &lt; node.val) &#123;</span><br><span class="line">			node.left = deleteRecursive(node.left, value);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; node.val) &#123;</span><br><span class="line">			node.right = deleteRecursive(node.right, value);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 找到要删除的节点</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 情况1：叶节点（没有子节点）</span></span><br><span class="line">			<span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 情况2：只有一个子节点</span></span><br><span class="line">			<span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> node.right;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> node.left;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 情况3：有两个子节点</span></span><br><span class="line">			<span class="comment">// 找到右子树中的最小值作为替代</span></span><br><span class="line">			node.val = findMin(node.right);</span><br><span class="line">			<span class="comment">// 删除右子树中的最小值节点</span></span><br><span class="line">			node.right = deleteRecursive(node.right, node.val);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 查找树中的最小值</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">minValue</span> <span class="operator">=</span> node.val;</span><br><span class="line">		<span class="keyword">while</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">			minValue = node.left.val;</span><br><span class="line">			node = node.left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> minValue;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 使用示例</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">BinarySearchTree</span> <span class="variable">bst</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinarySearchTree</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 插入节点</span></span><br><span class="line">		bst.insert(<span class="number">50</span>);</span><br><span class="line">		bst.insert(<span class="number">30</span>);</span><br><span class="line">		bst.insert(<span class="number">70</span>);</span><br><span class="line">		bst.insert(<span class="number">20</span>);</span><br><span class="line">		bst.insert(<span class="number">40</span>);</span><br><span class="line">		bst.insert(<span class="number">60</span>);</span><br><span class="line">		bst.insert(<span class="number">80</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;中序遍历 BST（应该是排序的）:&quot;</span>);</span><br><span class="line">		bst.inorderTraversal(); <span class="comment">// 输出: 20 30 40 50 60 70 80</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;</span></span><br><span class="line"><span class="string">查找值 40: &quot;</span> + bst.search(<span class="number">40</span>)); <span class="comment">// 输出: true</span></span><br><span class="line">		System.out.println(<span class="string">&quot;查找值 90: &quot;</span> + bst.search(<span class="number">90</span>)); <span class="comment">// 输出: false</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;删除节点 30 后的中序遍历:&quot;</span>);</span><br><span class="line">		bst.delete(<span class="number">30</span>);</span><br><span class="line">		bst.inorderTraversal(); <span class="comment">// 输出: 20 40 50 60 70 80</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测验-9"><a href="#测验-9" class="headerlink" title="测验"></a>测验</h4><ol>
<li>什么是二叉树？它与其他树结构的主要区别是什么？</li>
<li>二叉树的前序、中序和后序遍历分别是什么顺序？请解释这三种遍历方式的区别。</li>
<li>完全二叉树和满二叉树有什么区别？给出它们的定义。</li>
<li>二叉搜索树的特点是什么？与普通二叉树相比，它在查找操作上有什么优势？</li>
</ol>
<blockquote>
<p>测验答案</p>
<ol>
<li>二叉树是一种每个节点最多有两个子节点的树结构。与一般的树结构相比，二叉树限制了每个节点的子节点数量不超过两个，明确区分了左子节点和右子节点。</li>
<li>前序遍历：根节点-左子树-右子树。中序遍历：左子树-根节点-右子树。后序遍历：左子树-右子树-根节点。它们的区别在于访问根节点的时机：前序是最先访问根节点，中序是访问完左子树后访问根节点，后序是最后访问根节点。</li>
<li>满二叉树：除叶节点外的每个节点都有两个子节点，所有叶节点都在同一层。完全二叉树：除最后一层外的其他层都被填满，且最后一层的节点都集中在左侧。区别在于，满二叉树的所有叶节点必须在同一层，完全二叉树允许最后一层不满，但必须从左到右填充。</li>
<li>二叉搜索树的特点是对于任何节点，其左子树中所有节点的值都小于该节点的值，右子树中所有节点的值都大于该节点的值。与普通二叉树相比，二叉搜索树在查找操作上具有显著优势，平均时间复杂度为O(log n)，而普通二叉树需要O(n)时间进行线性搜索。</li>
</ol>
</blockquote>
<h3 id="二、AVL树"><a href="#二、AVL树" class="headerlink" title="二、AVL树"></a>二、AVL树</h3><p>AVL树是一种自平衡二叉搜索树，其中任何节点的两个子树的高度差最多为1。通过旋转操作保持树的平衡，确保操作的最坏时间复杂度为O(log n)。</p>
<p><code>空间复杂度:O(n)</code></p>
<h5 id="算法讲解-10"><a href="#算法讲解-10" class="headerlink" title="算法讲解"></a>算法讲解</h5><h4 id="AVL树-AVL-Tree"><a href="#AVL树-AVL-Tree" class="headerlink" title="AVL树(AVL Tree)"></a>AVL树(AVL Tree)</h4><h5 id="介绍-10"><a href="#介绍-10" class="headerlink" title="介绍"></a>介绍</h5><p>AVL树是一种自平衡二叉搜索树，它在普通二叉搜索树的基础上增加了平衡因子的概念，保证树的任何节点的左右子树高度差不超过1，保证查找、插入和删除操作的时间复杂度稳定在O(log n)。</p>
<p>AVL树中的几个关键概念：</p>
<ul>
<li>节点（Node）：树的基本组成单元，包含数据、左右子节点指针及高度信息</li>
<li>平衡因子（Balance Factor）：节点左子树高度减去右子树高度的差值</li>
<li>高度（Height）：从节点到其最远叶子节点的路径长度</li>
<li>旋转（Rotation）：保持平衡的核心操作，包括左旋、右旋、左右旋和右左旋</li>
</ul>
<h4 id="核心特性-10"><a href="#核心特性-10" class="headerlink" title="核心特性"></a>核心特性</h4><ol>
<li>自平衡性：任何节点的左右子树高度差不超过1</li>
<li>二叉搜索性质：左子树所有节点值小于父节点，右子树所有节点值大于父节点</li>
<li>平衡因子：每个节点都有-1、0或1的平衡因子</li>
<li>高度为O(log n)：由于严格的平衡要求，树的高度被限制在O(log n)</li>
<li>旋转操作：通过四种旋转操作维持树的平衡性</li>
</ol>
<h4 id="基本操作-9"><a href="#基本操作-9" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="1-查找元素"><a href="#1-查找元素" class="headerlink" title="1. 查找元素"></a>1. 查找元素</h5><ul>
<li>时间复杂度：O(log n)</li>
<li>方法：与普通二叉搜索树相同</li>
</ul>
<h5 id="2-插入元素"><a href="#2-插入元素" class="headerlink" title="2. 插入元素"></a>2. 插入元素</h5><ul>
<li>时间复杂度：O(log n)</li>
<li>步骤：<ol>
<li>执行标准二叉搜索树插入</li>
<li>更新受影响节点的高度</li>
<li>计算平衡因子</li>
<li>如失衡，执行旋转操作恢复平衡</li>
</ol>
</li>
</ul>
<h5 id="3-删除元素"><a href="#3-删除元素" class="headerlink" title="3. 删除元素"></a>3. 删除元素</h5><ul>
<li>时间复杂度：O(log n)</li>
<li>步骤：<ol>
<li>执行标准二叉搜索树删除</li>
<li>更新受影响节点的高度</li>
<li>计算平衡因子</li>
<li>如失衡，执行旋转操作恢复平衡</li>
</ol>
</li>
</ul>
<h5 id="4-旋转操作"><a href="#4-旋转操作" class="headerlink" title="4. 旋转操作"></a>4. 旋转操作</h5><ul>
<li>左旋（LL）：针对右子树高于左子树过多</li>
<li>右旋（RR）：针对左子树高于右子树过多</li>
<li>左右旋（LR）：先对左子树进行左旋，再对节点进行右旋</li>
<li>右左旋（RL）：先对右子树进行右旋，再对节点进行左旋</li>
</ul>
<h4 id="代码实现-10"><a href="#代码实现-10" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AVL树的Java实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AVLTree</span> &#123;</span><br><span class="line">    <span class="comment">// 树节点定义</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> key;        <span class="comment">// 节点值</span></span><br><span class="line">        Node left;      <span class="comment">// 左子节点</span></span><br><span class="line">        Node right;     <span class="comment">// 右子节点</span></span><br><span class="line">        <span class="type">int</span> height;     <span class="comment">// 节点高度</span></span><br><span class="line">        </span><br><span class="line">        Node(<span class="type">int</span> key) &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.height = <span class="number">1</span>; <span class="comment">// 新节点高度初始为1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Node root; <span class="comment">// 根节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取节点高度，空节点高度为0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.height;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取节点的平衡因子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getBalanceFactor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> height(node.left) - height(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateHeight</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node.height = Math.max(height(node.left), height(node.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 右旋转（处理左左情况）</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">rotateRight</span><span class="params">(Node y)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> y.left;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">T2</span> <span class="operator">=</span> x.right;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行旋转</span></span><br><span class="line">        x.right = y;</span><br><span class="line">        y.left = T2;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新高度</span></span><br><span class="line">        updateHeight(y);</span><br><span class="line">        updateHeight(x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x; <span class="comment">// 返回新的根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 左旋转（处理右右情况）</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">rotateLeft</span><span class="params">(Node x)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">y</span> <span class="operator">=</span> x.right;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">T2</span> <span class="operator">=</span> y.left;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行旋转</span></span><br><span class="line">        y.left = x;</span><br><span class="line">        x.right = T2;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新高度</span></span><br><span class="line">        updateHeight(x);</span><br><span class="line">        updateHeight(y);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> y; <span class="comment">// 返回新的根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        root = insertNode(root, key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">insertNode</span><span class="params">(Node node, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 执行标准BST插入</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">            node.left = insertNode(node.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.key) &#123;</span><br><span class="line">            node.right = insertNode(node.right, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 相同键值不做处理，或根据需求更新节点</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 更新节点高度</span></span><br><span class="line">        updateHeight(node);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 获取平衡因子</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> getBalanceFactor(node);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 如果节点失衡，进行旋转调整</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 左左情况 - 右旋</span></span><br><span class="line">        <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(node.left) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rotateRight(node);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 右右情况 - 左旋</span></span><br><span class="line">        <span class="keyword">if</span> (balance &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(node.right) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rotateLeft(node);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 左右情况 - 左右双旋</span></span><br><span class="line">        <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(node.left) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            node.left = rotateLeft(node.left);</span><br><span class="line">            <span class="keyword">return</span> rotateRight(node);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 右左情况 - 右左双旋</span></span><br><span class="line">        <span class="keyword">if</span> (balance &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(node.right) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node.right = rotateRight(node.right);</span><br><span class="line">            <span class="keyword">return</span> rotateLeft(node);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回未变化的节点引用</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找最小值节点</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">findMinNode</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="keyword">while</span> (current.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        root = deleteNode(root, key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">deleteNode</span><span class="params">(Node root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 执行标准BST删除</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (key &lt; root.key) &#123;</span><br><span class="line">            root.left = deleteNode(root.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root.key) &#123;</span><br><span class="line">            root.right = deleteNode(root.right, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 找到要删除的节点</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 情况1：叶子节点或只有一个子节点</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span> || root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> (root.left != <span class="literal">null</span>) ? root.left : root.right;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 没有子节点</span></span><br><span class="line">                <span class="keyword">if</span> (temp == <span class="literal">null</span>) &#123;</span><br><span class="line">                    root = <span class="literal">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 一个子节点</span></span><br><span class="line">                    root = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 情况2：有两个子节点</span></span><br><span class="line">                <span class="comment">// 找到右子树的最小节点（中序后继）</span></span><br><span class="line">                <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> findMinNode(root.right);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 复制中序后继的值到当前节点</span></span><br><span class="line">                root.key = temp.key;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 删除中序后继</span></span><br><span class="line">                root.right = deleteNode(root.right, temp.key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果树只有一个节点，删除后直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 更新高度</span></span><br><span class="line">        updateHeight(root);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 获取平衡因子</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> getBalanceFactor(root);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 进行旋转操作保持平衡</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 左左情况</span></span><br><span class="line">        <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(root.left) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rotateRight(root);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 左右情况</span></span><br><span class="line">        <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(root.left) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            root.left = rotateLeft(root.left);</span><br><span class="line">            <span class="keyword">return</span> rotateRight(root);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 右右情况</span></span><br><span class="line">        <span class="keyword">if</span> (balance &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(root.right) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rotateLeft(root);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 右左情况</span></span><br><span class="line">        <span class="keyword">if</span> (balance &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(root.right) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            root.right = rotateRight(root.right);</span><br><span class="line">            <span class="keyword">return</span> rotateLeft(root);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchNode(root, key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">searchNode</span><span class="params">(Node root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (key == root.key) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (key &lt; root.key) &#123;</span><br><span class="line">            <span class="keyword">return</span> searchNode(root.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> searchNode(root.right, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<h4 id="优缺点-9"><a href="#优缺点-9" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点-9"><a href="#优点-9" class="headerlink" title="优点"></a>优点</h5><ol>
<li>查找效率高：保证O(log n)的查找、插入和删除操作时间复杂度</li>
<li>自平衡：自动调整树的结构，防止最坏情况出现</li>
<li>稳定性：所有操作都有稳定的性能表现</li>
<li>可预测性：树高被严格限制，便于分析性能</li>
</ol>
<h5 id="缺点-8"><a href="#缺点-8" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>实现复杂：相比普通二叉搜索树，实现复杂度高</li>
<li>额外空间：每个节点需要存储高度信息</li>
<li>旋转开销：插入删除过程中的旋转操作增加了额外计算开销</li>
<li>频繁平衡调整：对于高频插入删除的场景，频繁的平衡调整可能影响性能</li>
</ol>
<h4 id="应用场景-10"><a href="#应用场景-10" class="headerlink" title="应用场景"></a>应用场景</h4><p>AVL树是最早被发明的自平衡二叉搜索树之一，适用于许多需要高效查找和维持数据有序性的场景。</p>
<p>比如内存管理器经常使用AVL树跟踪内存块的分配与释放。</p>
<p>在需要频繁执行范围查询的应用中，AVL树也比较适用，常用于实现区间查询功能。</p>
<h4 id="测验-10"><a href="#测验-10" class="headerlink" title="测验"></a>测验</h4><p>1）AVL树的平衡因子是如何定义的？平衡因子的有效范围是什么？</p>
<p>2）在AVL树中，当插入节点导致失衡时，需要几种不同类型的旋转操作来维持平衡？它们分别应对什么情况？</p>
<blockquote>
<p>测验答案</p>
<p>1）AVL树的平衡因子定义为节点的左子树高度减去右子树高度。在一棵合法的AVL树中，每个节点的平衡因子只能是-1、0或1，表示左右子树高度差不超过1。</p>
<p>2）AVL树中有四种旋转操作：</p>
<ul>
<li>左旋（LL旋转）：处理右子树过重的情况</li>
<li>右旋（RR旋转）：处理左子树过重的情况</li>
<li>左右旋（LR旋转）：先对左子节点进行左旋，再对当前节点进行右旋</li>
<li>右左旋（RL旋转）：先对右子节点进行右旋，再对当前节点进行左旋</li>
</ul>
</blockquote>
<h3 id="三、红黑树"><a href="#三、红黑树" class="headerlink" title="三、红黑树"></a>三、红黑树</h3><p>红黑树是一种自平衡的二叉搜索树，通过节点颜色和旋转操作保持树的平衡。它通过确保没有一条路径会比其他路径长两倍来保证查找、插入和删除操作的时间复杂度为O(log n)。</p>
<h5 id="算法讲解-11"><a href="#算法讲解-11" class="headerlink" title="算法讲解"></a>算法讲解</h5><h4 id="红黑树-Red-Black-Tree"><a href="#红黑树-Red-Black-Tree" class="headerlink" title="红黑树(Red-Black Tree)"></a>红黑树(Red-Black Tree)</h4><h5 id="介绍-11"><a href="#介绍-11" class="headerlink" title="介绍"></a>介绍</h5><p>红黑树是一种自平衡二叉搜索树，最初被称为”对称二叉B树”，后来改名为红黑树。因为在每个节点上都增加了一个表示颜色的属性，可以是红色或黑色。红黑树通过着色规则和特定的重新平衡操作（旋转和重新着色）来保持树的平衡。</p>
<p>红黑树中的几个关键概念：</p>
<ul>
<li>节点（Node）：包含数据、左右子节点指针、父节点指针及颜色标记（红/黑）</li>
<li>着色规则：每个节点被标记为红色或黑色，以满足特定的平衡条件</li>
<li>黑高（Black Height）：从任一节点到其后代叶节点的路径上黑色节点的数量</li>
<li>旋转（Rotation）：与AVL树类似的结构调整操作</li>
<li>重新着色（Recoloring）：改变节点颜色，配合旋转实现平衡</li>
</ul>
<h4 id="核心特性-11"><a href="#核心特性-11" class="headerlink" title="核心特性"></a>核心特性</h4><p>红黑树必须满足以下五个性质：</p>
<ol>
<li>每个节点或是红色，或是黑色</li>
<li>根节点必须是黑色</li>
<li>所有叶子节点（NIL节点）都是黑色</li>
<li>如果一个节点是红色，则其两个子节点都是黑色（不能有连续的红色节点）</li>
<li>对于每个节点，从该节点到其所有后代叶子节点的路径上，包含相同数量的黑色节点</li>
</ol>
<p>这些规则保证了红黑树的关键特性：</p>
<ol>
<li>高度平衡：从根到叶子的最长路径不会超过最短路径的两倍</li>
<li>O(log n)性能：查找、插入和删除操作都保证O(log n)时间复杂度</li>
<li>自平衡：通过颜色变换和旋转操作自动调整结构</li>
<li>相对宽松的平衡：比AVL树允许更多的不平衡，减少重新平衡操作</li>
</ol>
<h4 id="基本操作-10"><a href="#基本操作-10" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="1-查找元素-1"><a href="#1-查找元素-1" class="headerlink" title="1. 查找元素"></a>1. 查找元素</h5><ul>
<li>时间复杂度：O(log n)</li>
<li>方法：与普通二叉搜索树相同</li>
</ul>
<h5 id="2-插入元素-1"><a href="#2-插入元素-1" class="headerlink" title="2. 插入元素"></a>2. 插入元素</h5><ul>
<li>时间复杂度：O(log n)</li>
<li>步骤：</li>
</ul>
<ol>
<li>执行标准二叉搜索树插入</li>
<li>将新插入的节点着色为红色</li>
<li>如违反了红黑树性质，进行修复操作</li>
</ol>
<ul>
<li>重新着色</li>
<li>旋转（左旋、右旋）</li>
</ul>
<h5 id="3-删除元素-1"><a href="#3-删除元素-1" class="headerlink" title="3. 删除元素"></a>3. 删除元素</h5><ul>
<li>时间复杂度：O(log n)</li>
<li>步骤：</li>
</ul>
<ol>
<li>执行标准二叉搜索树删除</li>
<li>如被删除节点的替代节点违反红黑树性质，进行修复操作</li>
</ol>
<ul>
<li>重新着色</li>
<li>旋转（左旋、右旋）</li>
</ul>
<h5 id="4-修复操作"><a href="#4-修复操作" class="headerlink" title="4. 修复操作"></a>4. 修复操作</h5><ul>
<li>颜色翻转：更改节点和其子节点的颜色</li>
<li>左旋：右子树过重时使用</li>
<li>右旋：左子树过重时使用</li>
</ul>
<h4 id="代码实现-11"><a href="#代码实现-11" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 红黑树的Java实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedBlackTree</span> &#123;</span><br><span class="line"><span class="comment">// 颜色常量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">RED</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">BLACK</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树节点定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> key; <span class="comment">// 节点值</span></span><br><span class="line">Node left; <span class="comment">// 左子节点</span></span><br><span class="line">Node right; <span class="comment">// 右子节点</span></span><br><span class="line">Node parent; <span class="comment">// 父节点</span></span><br><span class="line"><span class="type">boolean</span> color; <span class="comment">// 节点颜色（true为红，false为黑）</span></span><br><span class="line"></span><br><span class="line">Node(<span class="type">int</span> key) &#123;</span><br><span class="line"><span class="built_in">this</span>.key = key;</span><br><span class="line"><span class="built_in">this</span>.color = RED; <span class="comment">// 新节点默认为红色</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node root; <span class="comment">// 根节点</span></span><br><span class="line"><span class="keyword">private</span> Node NIL; <span class="comment">// 哨兵节点（表示叶子节点）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RedBlackTree</span><span class="params">()</span> &#123;</span><br><span class="line">NIL = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">NIL.color = BLACK;</span><br><span class="line">NIL.left = <span class="literal">null</span>;</span><br><span class="line">NIL.right = <span class="literal">null</span>;</span><br><span class="line">root = NIL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取节点颜色，空节点视为黑色</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">colorOf</span><span class="params">(Node node)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> node == NIL ? BLACK : node.color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断节点是否为红色</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isRed</span><span class="params">(Node node)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> colorOf(node) == RED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断节点是否为黑色</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isBlack</span><span class="params">(Node node)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> colorOf(node) == BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置节点颜色</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(Node node, <span class="type">boolean</span> color)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (node != NIL) &#123;</span><br><span class="line">node.color = color;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左旋操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">leftRotate</span><span class="params">(Node x)</span> &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">y</span> <span class="operator">=</span> x.right; <span class="comment">// 设置y为x的右子节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将y的左子树设为x的右子树</span></span><br><span class="line">x.right = y.left;</span><br><span class="line"><span class="keyword">if</span> (y.left != NIL) &#123;</span><br><span class="line">y.left.parent = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置y的父节点</span></span><br><span class="line">y.parent = x.parent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置x的父节点关系</span></span><br><span class="line"><span class="keyword">if</span> (x.parent == <span class="literal">null</span>) &#123;</span><br><span class="line">root = y;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == x.parent.left) &#123;</span><br><span class="line">x.parent.left = y;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">x.parent.right = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成旋转</span></span><br><span class="line">y.left = x;</span><br><span class="line">x.parent = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右旋操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rightRotate</span><span class="params">(Node y)</span> &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> y.left; <span class="comment">// 设置x为y的左子节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将x的右子树设为y的左子树</span></span><br><span class="line">y.left = x.right;</span><br><span class="line"><span class="keyword">if</span> (x.right != NIL) &#123;</span><br><span class="line">x.right.parent = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置x的父节点</span></span><br><span class="line">x.parent = y.parent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置y的父节点关系</span></span><br><span class="line"><span class="keyword">if</span> (y.parent == <span class="literal">null</span>) &#123;</span><br><span class="line">root = x;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == y.parent.left) &#123;</span><br><span class="line">y.parent.left = x;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">y.parent.right = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成旋转</span></span><br><span class="line">x.right = y;</span><br><span class="line">y.parent = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key);</span><br><span class="line">node.left = NIL;</span><br><span class="line">node.right = NIL;</span><br><span class="line"></span><br><span class="line"><span class="type">Node</span> <span class="variable">y</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> <span class="built_in">this</span>.root;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到插入位置</span></span><br><span class="line"><span class="keyword">while</span> (x != NIL) &#123;</span><br><span class="line">y = x;</span><br><span class="line"><span class="keyword">if</span> (node.key &lt; x.key) &#123;</span><br><span class="line">x = x.left;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">x = x.right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置node的父节点</span></span><br><span class="line">node.parent = y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置node为根节点或者是父节点的左/右孩子</span></span><br><span class="line"><span class="keyword">if</span> (y == <span class="literal">null</span>) &#123;</span><br><span class="line">root = node;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.key &lt; y.key) &#123;</span><br><span class="line">y.left = node;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">y.right = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果新节点是根节点，则将其设为黑色</span></span><br><span class="line"><span class="keyword">if</span> (node.parent == <span class="literal">null</span>) &#123;</span><br><span class="line">node.color = BLACK;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果新节点的祖父节点为空，则不需要修复</span></span><br><span class="line"><span class="keyword">if</span> (node.parent.parent == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修复红黑树性质</span></span><br><span class="line">fixInsert(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修复插入后的红黑树性质</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fixInsert</span><span class="params">(Node k)</span> &#123;</span><br><span class="line">Node u;</span><br><span class="line"><span class="keyword">while</span> (isRed(k.parent)) &#123;</span><br><span class="line"><span class="comment">// 父节点是祖父节点的右子节点</span></span><br><span class="line"><span class="keyword">if</span> (k.parent == k.parent.parent.right) &#123;</span><br><span class="line">u = k.parent.parent.left; <span class="comment">// 叔叔节点</span></span><br><span class="line"><span class="comment">// 情况1：叔叔节点是红色</span></span><br><span class="line"><span class="keyword">if</span> (isRed(u)) &#123;</span><br><span class="line">u.color = BLACK;</span><br><span class="line">k.parent.color = BLACK;</span><br><span class="line">k.parent.parent.color = RED;</span><br><span class="line">k = k.parent.parent;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 情况2：叔叔节点是黑色，当前节点是左子节点</span></span><br><span class="line"><span class="keyword">if</span> (k == k.parent.left) &#123;</span><br><span class="line">k = k.parent;</span><br><span class="line">rightRotate(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 情况3：叔叔节点是黑色，当前节点是右子节点</span></span><br><span class="line">k.parent.color = BLACK;</span><br><span class="line">k.parent.parent.color = RED;</span><br><span class="line">leftRotate(k.parent.parent);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 父节点是祖父节点的左子节点</span></span><br><span class="line">u = k.parent.parent.right; <span class="comment">// 叔叔节点</span></span><br><span class="line"><span class="comment">// 情况1：叔叔节点是红色</span></span><br><span class="line"><span class="keyword">if</span> (isRed(u)) &#123;</span><br><span class="line">u.color = BLACK;</span><br><span class="line">k.parent.color = BLACK;</span><br><span class="line">k.parent.parent.color = RED;</span><br><span class="line">k = k.parent.parent;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 情况2：叔叔节点是黑色，当前节点是右子节点</span></span><br><span class="line"><span class="keyword">if</span> (k == k.parent.right) &#123;</span><br><span class="line">k = k.parent;</span><br><span class="line">leftRotate(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 情况3：叔叔节点是黑色，当前节点是左子节点</span></span><br><span class="line">k.parent.color = BLACK;</span><br><span class="line">k.parent.parent.color = RED;</span><br><span class="line">rightRotate(k.parent.parent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果k是根节点，退出循环</span></span><br><span class="line"><span class="keyword">if</span> (k == root) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 确保根节点是黑色</span></span><br><span class="line">root.color = BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找最小值节点</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">minimum</span><span class="params">(Node node)</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (node.left != NIL) &#123;</span><br><span class="line">node = node.left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用v替换u</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">transplant</span><span class="params">(Node u, Node v)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (u.parent == <span class="literal">null</span>) &#123;</span><br><span class="line">root = v;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (u === u.parent.left) &#123;</span><br><span class="line">u.parent.left = v;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">u.parent.right = v;</span><br><span class="line">&#125;</span><br><span class="line">v.parent = u.parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">z</span> <span class="operator">=</span> search(root, key);</span><br><span class="line"><span class="keyword">if</span> (z == NIL) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Key &quot;</span> + key + <span class="string">&quot; not found in the tree&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Node</span> <span class="variable">y</span> <span class="operator">=</span> z;</span><br><span class="line">Node x;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">yOriginalColor</span> <span class="operator">=</span> y.color;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (z.left == NIL) &#123;</span><br><span class="line">x = z.right;</span><br><span class="line">transplant(z, z.right);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (z.right == NIL) &#123;</span><br><span class="line">x = z.left;</span><br><span class="line">transplant(z, z.left);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">y = minimum(z.right);</span><br><span class="line">yOriginalColor = y.color;</span><br><span class="line">x = y.right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (y.parent === z) &#123;</span><br><span class="line">x.parent = y;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">transplant(y, y.right);</span><br><span class="line">y.right = z.right;</span><br><span class="line">y.right.parent = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">transplant(z, y);</span><br><span class="line">y.left = z.left;</span><br><span class="line">y.left.parent = y;</span><br><span class="line">y.color = z.color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果原始颜色是黑色，需要修复</span></span><br><span class="line"><span class="keyword">if</span> (yOriginalColor == BLACK) &#123;</span><br><span class="line">fixDelete(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修复删除后的红黑树性质</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fixDelete</span><span class="params">(Node x)</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (x != root &amp;&amp; isBlack(x)) &#123;</span><br><span class="line"><span class="keyword">if</span> (x == x.parent.left) &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">w</span> <span class="operator">=</span> x.parent.right;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况1：兄弟节点是红色</span></span><br><span class="line"><span class="keyword">if</span> (isRed(w)) &#123;</span><br><span class="line">w.color = BLACK;</span><br><span class="line">x.parent.color = RED;</span><br><span class="line">leftRotate(x.parent);</span><br><span class="line">w = x.parent.right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况2：兄弟节点是黑色，且两个子节点都是黑色</span></span><br><span class="line"><span class="keyword">if</span> (isBlack(w.left) &amp;&amp; isBlack(w.right)) &#123;</span><br><span class="line">w.color = RED;</span><br><span class="line">x = x.parent;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 情况3：兄弟节点是黑色，左子节点是红色，右子节点是黑色</span></span><br><span class="line"><span class="keyword">if</span> (isBlack(w.right)) &#123;</span><br><span class="line">w.left.color = BLACK;</span><br><span class="line">w.color = RED;</span><br><span class="line">rightRotate(w);</span><br><span class="line">w = x.parent.right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况4：兄弟节点是黑色，右子节点是红色</span></span><br><span class="line">w.color = x.parent.color;</span><br><span class="line">x.parent.color = BLACK;</span><br><span class="line">w.right.color = BLACK;</span><br><span class="line">leftRotate(x.parent);</span><br><span class="line">x = root;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// x是右子节点</span></span><br><span class="line"><span class="type">Node</span> <span class="variable">w</span> <span class="operator">=</span> x.parent.left;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况1：兄弟节点是红色</span></span><br><span class="line"><span class="keyword">if</span> (isRed(w)) &#123;</span><br><span class="line">w.color = BLACK;</span><br><span class="line">x.parent.color = RED;</span><br><span class="line">rightRotate(x.parent);</span><br><span class="line">w = x.parent.left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况2：兄弟节点是黑色，且两个子节点都是黑色</span></span><br><span class="line"><span class="keyword">if</span> (isBlack(w.right) &amp;&amp; isBlack(w.left)) &#123;</span><br><span class="line">w.color = RED;</span><br><span class="line">x = x.parent;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 情况3：兄弟节点是黑色，右子节点是红色，左子节点是黑色</span></span><br><span class="line"><span class="keyword">if</span> (isBlack(w.left)) &#123;</span><br><span class="line">w.right.color = BLACK;</span><br><span class="line">w.color = RED;</span><br><span class="line">leftRotate(w);</span><br><span class="line">w = x.parent.left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况4：兄弟节点是黑色，左子节点是红色</span></span><br><span class="line">w.color = x.parent.color;</span><br><span class="line">x.parent.color = BLACK;</span><br><span class="line">w.left.color = BLACK;</span><br><span class="line">rightRotate(x.parent);</span><br><span class="line">x = root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将x设为黑色</span></span><br><span class="line">x.color = BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找节点</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">search</span><span class="params">(Node root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (root == NIL || key == root.key) &#123;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (key &lt; root.key) &#123;</span><br><span class="line"><span class="keyword">return</span> search(root.left, key);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> search(root.right, key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公开的查找方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> search(root, key) != NIL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorderTraversal</span><span class="params">()</span> &#123;</span><br><span class="line">inorder(root);</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(Node node)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (node != NIL) &#123;</span><br><span class="line">inorder(node.left);</span><br><span class="line">System.out.print(node.key +</span><br><span class="line">(node.color == RED ? <span class="string">&quot;(R) &quot;</span> : <span class="string">&quot;(B) &quot;</span>));</span><br><span class="line">inorder(node.right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取树的黑高</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">blackHeight</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> calculateBlackHeight(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calculateBlackHeight</span><span class="params">(Node node)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (node == NIL) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> calculateBlackHeight(node.left);</span><br><span class="line"><span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> calculateBlackHeight(node.right);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证左右子树黑高是否相同</span></span><br><span class="line"><span class="keyword">if</span> (leftHeight != rightHeight) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Red-Black Tree property violation: Unequal black heights&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算当前节点到叶子节点的黑色节点数</span></span><br><span class="line"><span class="keyword">return</span> isBlack(node) ? leftHeight + <span class="number">1</span> : leftHeight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<p>这两个实现与Java版本保持一致的功能：</p>
<ul>
<li>均包含插入、删除、查找操作</li>
<li>插入和删除后的红黑树性质修复</li>
<li>左旋和右旋操作</li>
<li>中序遍历</li>
<li>黑高计算</li>
</ul>
<p>Go版本使用了更符合Go语言习惯的结构，包括导出方法的大写命名和返回错误而非抛出异常。C++版本增加了内存管理（析构函数）以避免内存泄漏。两个实现都遵循了对应语言的代码风格和习惯。</p>
<h4 id="优缺点-10"><a href="#优缺点-10" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点-10"><a href="#优点-10" class="headerlink" title="优点"></a>优点</h5><ol>
<li>查找效率高：O(log n)的查找、插入和删除操作时间复杂度</li>
<li>自平衡：通过颜色规则和旋转操作自动维持平衡</li>
<li>插入删除效率：比AVL树需要更少的旋转操作，平均性能更好</li>
<li>内存占用少：每个节点只需额外一个比特存储颜色信息</li>
<li>实际应用广泛：被广泛用于实际系统中，比如Java TreeMap、C++ STL中的map/set等</li>
</ol>
<h5 id="缺点-9"><a href="#缺点-9" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>实现复杂：规则多，调整操作复杂，实现难度大</li>
<li>删除操作尤其复杂：需要处理多种情况的平衡修复</li>
<li>不严格平衡：虽然路径长度不会超过最短路径的两倍，但比AVL树的平衡性稍差</li>
<li>旋转操作开销：虽然比AVL树少，但仍有调整开销</li>
</ol>
<h4 id="应用场景-11"><a href="#应用场景-11" class="headerlink" title="应用场景"></a>应用场景</h4><p>红黑树在众多系统和场景中有广泛应用，其平衡性能和实现效率使其成为许多高性能应用的首选数据结构。</p>
<p>在操作系统内核中，红黑树经常被用于实现各种调度器和资源管理器。例如，Linux内核使用红黑树来管理进程调度、内存管理和文件系统中的目录结构，它能在保持较好平衡的同时减少重新平衡操作的频率。</p>
<p>许多高级编程语言的标准库也选择红黑树作为有序映射和集合的底层实现。Java中的TreeMap和TreeSet，C++的std::map和std::set，以及C#的SortedDictionary等，都基于红黑树实现。这些数据结构需要保持元素的有序性，同时又要求高效的查找、插入和删除操作，这些需求红黑树都满足。</p>
<h4 id="扩展：与AVL树的比较"><a href="#扩展：与AVL树的比较" class="headerlink" title="扩展：与AVL树的比较"></a>扩展：与AVL树的比较</h4><ol>
<li>平衡性：AVL树的平衡条件更严格，要求任何节点的左右子树高度差不超过1，而红黑树允许左右子树的”黑高度”相同，但整体高度可能相差两倍。</li>
<li>旋转频率：AVL树为了维持严格平衡，在插入和删除操作中可能需要更多的旋转操作，而红黑树由于平衡条件较为宽松，通常需要的旋转次数更少。</li>
<li>使用场景：</li>
</ol>
<ul>
<li>AVL树更适合读操作频繁、写操作较少的场景</li>
<li>红黑树更适合写操作频繁的场景，如频繁的插入、删除操作</li>
</ul>
<ol>
<li>实际应用：</li>
</ol>
<ul>
<li>大多数语言的标准库实现（如Java的TreeMap、C++的map）采用红黑树</li>
<li>数据库索引通常偏向使用B树或B+树，这些是AVL树和红黑树思想的多路扩展</li>
</ul>
<h4 id="测验-11"><a href="#测验-11" class="headerlink" title="测验"></a>测验</h4><p>1）红黑树的五个基本性质是什么？哪一条保证了树的高度是O(log n)？</p>
<p>2）在红黑树中插入一个新节点后，可能会违反哪些红黑树性质？初始默认将新节点设置为什么颜色？</p>
<p>3）在红黑树中，如果一个节点的叔叔节点是红色，在插入修复过程中通常采取什么操作？</p>
<p>4）红黑树相比AVL树，在执行插入操作时平均需要的旋转次数更多还是更少？为什么？</p>
<blockquote>
<p>测验答案</p>
<p>1）红黑树的五个基本性质是：</p>
<ul>
<li>每个节点或是红色，或是黑色</li>
<li>根节点必须是黑色</li>
<li>所有叶子节点（NIL节点）都是黑色</li>
<li>如果一个节点是红色，则其两个子节点都是黑色</li>
<li>对于每个节点，从该节点到其所有后代叶子节点的路径上，包含相同数量的黑色节点</li>
</ul>
<p>第五条性质结合第四条性质保证了树的高度是O(log n)，因为它限制了任何路径上黑色节点数量相同，且不能有连续的红色节点，因此最长路径不会超过最短路径的两倍。</p>
<p>2）插入新节点后可能违反的性质主要是：</p>
<ul>
<li>性质2：如果新节点成为根，但它是红色</li>
<li>性质4：如果新节点是红色，且其父节点也是红色</li>
</ul>
<p>在红黑树中，新插入的节点默认设置为红色，这样可以减少违反性质5的可能性。</p>
<p>3）当一个节点的叔叔节点是红色时，插入修复过程通常采取颜色翻转操作：</p>
<ul>
<li>将父节点设为黑色</li>
<li>将叔叔节点设为黑色</li>
<li>将祖父节点设为红色（如果祖父是根节点，则最后重新设为黑色）</li>
</ul>
<p>4）更少。AVL树要求更严格的平衡（左右子树高度差不超过1），因此在插入时可能需要多次旋转来维持平衡。而红黑树的平衡条件较为宽松，允许树有一定程度的不平衡，所以在插入和删除时需要的旋转操作通常更少，这也是红黑树在实际应用中更常用的原因之一。</p>
</blockquote>
<h3 id="四、二叉搜索树"><a href="#四、二叉搜索树" class="headerlink" title="四、二叉搜索树"></a>四、二叉搜索树</h3><p>二叉搜索树是一种二叉树，其中每个节点的左子树中的值都小于该节点的值，右子树中的值都大于该节点的值。这种特性使得二叉搜索树在查找、插入和删除操作上具有较高的效率。</p>
<p><code>空间复杂度:O(n)</code></p>
<h5 id="算法讲解-12"><a href="#算法讲解-12" class="headerlink" title="算法讲解"></a>算法讲解</h5><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><h5 id="介绍-12"><a href="#介绍-12" class="headerlink" title="介绍"></a>介绍</h5><p>二叉搜索树（Binary Search Tree，简称BST）是一种特殊的二叉树数据结构，它具有以下特点：对于树中的每个节点，其左子树中所有节点的值都小于该节点的值，右子树中所有节点的值都大于该节点的值。</p>
<h4 id="核心特性-12"><a href="#核心特性-12" class="headerlink" title="核心特性"></a>核心特性</h4><ol>
<li>有序性：左子树上所有节点的值都小于根节点的值，右子树上所有节点的值都大于根节点的值</li>
<li>唯一性：树中不存在值相同的节点（标准实现中）</li>
<li>平均时间复杂度：查找、插入和删除操作的平均时间复杂度为O(log n)，n是节点数量</li>
<li>最坏时间复杂度：如果树不平衡（比如形成链表），最坏情况下时间复杂度为O(n)</li>
<li>递归定义：每个子树也是一个二叉搜索树</li>
</ol>
<h4 id="基本操作-11"><a href="#基本操作-11" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h5><ol>
<li>从根节点开始</li>
<li>如果目标值等于当前节点值，则找到目标</li>
<li>如果目标值小于当前节点值，则在左子树中继续查找</li>
<li>如果目标值大于当前节点值，则在右子树中继续查找</li>
<li>如果到达叶节点仍未找到，则目标不存在</li>
</ol>
<h5 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h5><ol>
<li>从根节点开始</li>
<li>如果树为空，创建新节点作为根节点</li>
<li>如果新值小于当前节点值，则在左子树中继续（如果左子树为空，则创建新节点）</li>
<li>如果新值大于当前节点值，则在右子树中继续（如果右子树为空，则创建新节点）</li>
<li>如果新值等于当前节点值，根据实现可以选择忽略或更新节点</li>
</ol>
<h5 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h5><p>删除操作较为复杂，需要考虑三种情况：</p>
<ol>
<li>删除叶节点：直接移除</li>
<li>删除有一个子节点的节点：用子节点替换被删除的节点</li>
<li>删除有两个子节点的节点：<ul>
<li>找到右子树中的最小值节点（中序后继）</li>
<li>用该节点的值替换要删除的节点值</li>
<li>删除中序后继节点</li>
</ul>
</li>
</ol>
<h4 id="代码实现-12"><a href="#代码实现-12" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line">    <span class="comment">// 定义节点类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> value;      <span class="comment">// 节点值</span></span><br><span class="line">        Node left;      <span class="comment">// 左子节点</span></span><br><span class="line">        Node right;     <span class="comment">// 右子节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Node root;  <span class="comment">// 根节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinarySearchTree</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        root = insertRecursive(root, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">insertRecursive</span><span class="params">(Node current, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点为空，创建新节点</span></span><br><span class="line">        <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归插入到合适位置</span></span><br><span class="line">        <span class="keyword">if</span> (value &lt; current.value) &#123;</span><br><span class="line">            current.left = insertRecursive(current.left, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; current.value) &#123;</span><br><span class="line">            current.right = insertRecursive(current.right, value);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 值已存在，不做任何操作</span></span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchRecursive(root, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">searchRecursive</span><span class="params">(Node current, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">// 空树或到达叶节点</span></span><br><span class="line">        <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到目标值</span></span><br><span class="line">        <span class="keyword">if</span> (value == current.value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在左子树或右子树中查找</span></span><br><span class="line">        <span class="keyword">if</span> (value &lt; current.value) &#123;</span><br><span class="line">            <span class="keyword">return</span> searchRecursive(current.left, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> searchRecursive(current.right, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        root = deleteRecursive(root, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">deleteRecursive</span><span class="params">(Node current, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">// 树为空或未找到要删除的值</span></span><br><span class="line">        <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (value == current.value) &#123;</span><br><span class="line">            <span class="comment">// 情况1：叶节点</span></span><br><span class="line">            <span class="keyword">if</span> (current.left == <span class="literal">null</span> &amp;&amp; current.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 情况2：只有一个子节点</span></span><br><span class="line">            <span class="keyword">if</span> (current.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> current.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (current.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> current.left;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 情况3：有两个子节点</span></span><br><span class="line">            <span class="comment">// 查找右子树中的最小值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">smallestValue</span> <span class="operator">=</span> findSmallestValue(current.right);</span><br><span class="line">            current.value = smallestValue;</span><br><span class="line">            <span class="comment">// 删除右子树中的最小值节点</span></span><br><span class="line">            current.right = deleteRecursive(current.right, smallestValue);</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 继续在左子树或右子树中查找</span></span><br><span class="line">        <span class="keyword">if</span> (value &lt; current.value) &#123;</span><br><span class="line">            current.left = deleteRecursive(current.left, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current.right = deleteRecursive(current.right, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找子树中的最小值（最左侧节点）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findSmallestValue</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> findSmallestValue(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<h4 id="优缺点-11"><a href="#优缺点-11" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点-11"><a href="#优点-11" class="headerlink" title="优点"></a>优点</h5><ol>
<li>查找效率高：在平衡状态下，查找、插入和删除的时间复杂度为O(log n)</li>
<li>有序性：中序遍历可以得到有序序列</li>
<li>范围查询：支持高效的范围查询操作</li>
<li>实现简单：相比其他高级树结构，实现较为简单直观</li>
<li>动态性：支持动态添加和删除元素</li>
</ol>
<h5 id="缺点-10"><a href="#缺点-10" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>不自平衡：在最坏情况下（如顺序插入），可能退化为链表，性能下降到O(n)</li>
<li>空间开销：每个节点需要额外的指针空间</li>
<li>实际应用受限：在需要保证最坏情况性能的场景下，需要使用自平衡树变种（如AVL树、红黑树）</li>
<li>不适合频繁修改：频繁增删节点可能导致树失去平衡</li>
</ol>
<h4 id="扩展：自平衡二叉搜索树"><a href="#扩展：自平衡二叉搜索树" class="headerlink" title="扩展：自平衡二叉搜索树"></a>扩展：自平衡二叉搜索树</h4><p>为了解决普通二叉搜索树可能失衡的问题，人们实现了多种自平衡二叉搜索树：</p>
<ol>
<li>AVL树：通过旋转操作保持树的平衡，每个节点的左右子树高度差不超过1</li>
<li>红黑树：通过颜色标记和旋转操作保持近似平衡，广泛应用于许多编程语言的标准库中</li>
<li>伸展树（Splay Tree）：在访问节点后通过旋转将其移至根部，适合有访问局部性的应用</li>
<li>B树和B+树：多路搜索树，主要用于数据库和文件系统</li>
</ol>
<h4 id="测验-12"><a href="#测验-12" class="headerlink" title="测验"></a>测验</h4><ol>
<li>在一个包含1000个节点的平衡二叉搜索树中，最多需要多少次比较才能找到一个特定的值？在最坏情况下呢？</li>
<li>如果按照升序插入元素 1, 2, 3, 4, 5, 6, 7 到一个空的二叉搜索树中，会形成什么样的树结构？这种结构有什么问题？</li>
<li>当删除一个有两个子节点的节点时，为什么要用后继节点（右子树中的最小值）来替换？是否可以使用前驱节点（左子树中的最大值）？</li>
</ol>
<blockquote>
<p>测验答案</p>
<ol>
<li>最多需要约log₂1000 ≈ 10次比较就能找到目标值。在最坏情况下（如果树完全失衡成为链表），需要1000次比较。</li>
<li>按照升序插入元素会形成一个右斜树（实际上是一个链表），这种结构失去了二叉搜索树的查找效率优势，所有操作的时间复杂度都退化为O(n)。</li>
<li>使用后继节点替换是为了保持二叉搜索树的性质。后继节点是大于当前节点的最小节点，它保证比当前节点的左子树中的所有节点大，同时比右子树中其他节点小。前驱节点（左子树中的最大值）也可以用来替换，因为它比当前节点的左子树中其他节点大，同时比当前节点的右子树中所有节点小。两种方法都能维持二叉搜索树的特性。选择使用哪一种通常取决于实现偏好或特定应用需求。</li>
</ol>
</blockquote>
<h3 id="五、二叉堆"><a href="#五、二叉堆" class="headerlink" title="五、二叉堆"></a>五、二叉堆</h3><p>二叉堆是一种特殊的完全二叉树，常用于实现优先队列。最小堆的每个节点的值都小于或等于其子节点的值，最大堆的每个节点的值都大于或等于其子节点的值。二叉堆支持高效的插入、删除最值和构建操作。</p>
<p><code>空间复杂度:O(n)</code></p>
<h5 id="算法讲解-13"><a href="#算法讲解-13" class="headerlink" title="算法讲解"></a>算法讲解</h5><h4 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h4><h5 id="介绍-13"><a href="#介绍-13" class="headerlink" title="介绍"></a>介绍</h5><p>二叉堆是一种特殊的完全二叉树数据结构，它满足堆属性。完全二叉树是指除了最后一层外，其他层的节点都是满的，而最后一层的节点都靠左排列。二叉堆主要有两种类型：</p>
<ul>
<li>最大堆：每个父节点的值都大于或等于其子节点的值</li>
<li>最小堆：每个父节点的值都小于或等于其子节点的值</li>
</ul>
<p>二叉堆的这种特殊结构使得它可以高效地找到最大值或最小值，所以也常被用来实现优先队列。</p>
<h4 id="核心特性-13"><a href="#核心特性-13" class="headerlink" title="核心特性"></a>核心特性</h4><ol>
<li>完全二叉树结构：除最底层外，每层都填满，且最底层从左到右填充</li>
<li>堆序性质：<ul>
<li>最大堆：父节点值 ≥ 子节点值</li>
<li>最小堆：父节点值 ≤ 子节点值</li>
</ul>
</li>
<li>高效的顶部元素访问：可以在O(1)时间内获取最大/最小元素</li>
<li>数组表示：虽然概念上是树结构，但通常用数组实现，这样可以节省指针开销并提高内存局部性</li>
</ol>
<h4 id="基本操作-12"><a href="#基本操作-12" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="插入元素（Insert）"><a href="#插入元素（Insert）" class="headerlink" title="插入元素（Insert）"></a>插入元素（Insert）</h5><p>向堆中添加一个新元素：</p>
<ul>
<li>首先将新元素添加到堆的末尾</li>
<li>然后通过”上浮”操作调整堆，直到满足堆性质</li>
</ul>
<h5 id="删除顶部元素（Extract-Max-Min）"><a href="#删除顶部元素（Extract-Max-Min）" class="headerlink" title="删除顶部元素（Extract-Max/Min）"></a>删除顶部元素（Extract-Max/Min）</h5><p>移除并返回堆顶元素（最大/最小值）：</p>
<ul>
<li>取出堆顶元素</li>
<li>将堆的最后一个元素移到堆顶</li>
<li>通过”下沉”操作调整堆，直到满足堆性质</li>
</ul>
<h5 id="上浮（Heapify-Up）"><a href="#上浮（Heapify-Up）" class="headerlink" title="上浮（Heapify-Up）"></a>上浮（Heapify-Up）</h5><p>将一个元素向上移动到合适位置的过程：</p>
<ul>
<li>比较当前元素与其父节点</li>
<li>如果不满足堆性质，则交换它们</li>
<li>重复此过程直到满足堆性质</li>
</ul>
<h5 id="下沉（Heapify-Down）"><a href="#下沉（Heapify-Down）" class="headerlink" title="下沉（Heapify-Down）"></a>下沉（Heapify-Down）</h5><p>将一个元素向下移动到合适位置的过程：</p>
<ul>
<li>比较当前元素与其最大（或最小）的子节点</li>
<li>如果不满足堆性质，则交换它们</li>
<li>重复此过程直到满足堆性质</li>
</ul>
<h4 id="代码实现-13"><a href="#代码实现-13" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinHeap</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] heap;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinHeap</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.heap = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取父节点索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">parent</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取左子节点索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">leftChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取右子节点索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">rightChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换两个节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> heap[i];</span><br><span class="line">        heap[i] = heap[j];</span><br><span class="line">        heap[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == capacity) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;堆已满，无法插入&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先将新元素插入到堆的末尾</span></span><br><span class="line">        heap[size] = key;</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> size;</span><br><span class="line">        size++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上浮操作：将元素向上移动到合适位置</span></span><br><span class="line">        <span class="keyword">while</span> (current &gt; <span class="number">0</span> &amp;&amp; heap[current] &lt; heap[parent(current)]) &#123;</span><br><span class="line">            swap(current, parent(current));</span><br><span class="line">            current = parent(current);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最小元素（不删除）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;堆为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除并返回最小元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">extractMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;堆为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">return</span> heap[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储根节点（最小值）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> heap[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将最后一个元素放到根位置</span></span><br><span class="line">        heap[<span class="number">0</span>] = heap[size - <span class="number">1</span>];</span><br><span class="line">        size--;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 下沉操作：将根元素向下移动到合适位置</span></span><br><span class="line">        heapifyDown(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下沉操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapifyDown</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">smallest</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> leftChild(i);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> rightChild(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出当前节点、左子节点和右子节点中的最小值</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; size &amp;&amp; heap[left] &lt; heap[smallest]) &#123;</span><br><span class="line">            smallest = left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; heap[right] &lt; heap[smallest]) &#123;</span><br><span class="line">            smallest = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果最小值不是当前节点，则交换并继续下沉</span></span><br><span class="line">        <span class="keyword">if</span> (smallest != i) &#123;</span><br><span class="line">            swap(i, smallest);</span><br><span class="line">            heapifyDown(smallest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印堆</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printHeap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            System.out.print(heap[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MinHeap</span> <span class="variable">minHeap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MinHeap</span>(<span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        minHeap.insert(<span class="number">5</span>);</span><br><span class="line">        minHeap.insert(<span class="number">3</span>);</span><br><span class="line">        minHeap.insert(<span class="number">8</span>);</span><br><span class="line">        minHeap.insert(<span class="number">1</span>);</span><br><span class="line">        minHeap.insert(<span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;构建的堆：&quot;</span>);</span><br><span class="line">        minHeap.printHeap();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;最小元素：&quot;</span> + minHeap.peek());</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;提取最小元素：&quot;</span> + minHeap.extractMin());</span><br><span class="line">        System.out.println(<span class="string">&quot;提取后的堆：&quot;</span>);</span><br><span class="line">        minHeap.printHeap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<p>这两个实现都保持了二叉堆的基本操作和性能特性，但分别采用了Go和C++语言的特定语法和风格。</p>
<p>Go实现使用了Go语言的特性，如方法接收器和多返回值交换，而C++实现则利用了面向对象特性和STL容器（vector）来存储堆元素。两者都实现了相同的功能：创建堆、插入元素、获取最小元素、提取最小元素等操作。</p>
<h4 id="优缺点-12"><a href="#优缺点-12" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点-12"><a href="#优点-12" class="headerlink" title="优点"></a>优点</h5><ol>
<li>高效的优先级操作：O(1) 时间复杂度查找最大/最小元素</li>
<li>相对较快的插入和删除：O(log n) 时间复杂度</li>
<li>空间效率高：数组实现不需要额外的指针开销</li>
<li>实现简单：相比其他高级数据结构，二叉堆实现相对简单</li>
<li>内存局部性好：连续内存存储提高缓存命中率</li>
</ol>
<h5 id="缺点-11"><a href="#缺点-11" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>有限的操作集：只支持查找最值，不支持高效的搜索、删除任意元素等操作</li>
<li>不支持快速合并：合并两个堆的操作较为复杂</li>
<li>不稳定性：相同优先级的元素，其相对顺序可能改变</li>
<li>对缓存不友好的访问模式：特别是在堆较大时，父子节点间的跳跃访问可能导致缓存未命中</li>
</ol>
<h4 id="应用场景-12"><a href="#应用场景-12" class="headerlink" title="应用场景"></a>应用场景</h4><p>二叉堆广泛应用于各种算法和系统中：</p>
<ol>
<li>优先队列实现：当需要频繁获取最大或最小元素时，二叉堆是最常用的数据结构。操作系统中的进程调度、网络路由算法都会使用优先队列来确定下一个处理的任务。</li>
<li>排序算法：堆排序利用二叉堆的特性，能够以O(n log n)的时间复杂度对数据进行排序，且空间复杂度为O(1)，适合大数据排序。</li>
<li>图算法：许多图算法如Dijkstra最短路径、Prim最小生成树算法都使用优先队列来选择下一个处理的节点，二叉堆是其高效实现。</li>
<li>中位数和百分位数计算：通过维护两个堆（最大堆和最小堆），可以高效地跟踪数据流的中位数和其他统计值。</li>
<li>事件模拟：在离散事件模拟中，事件按时间顺序处理，优先队列可以确保按正确顺序处理事件。</li>
<li>数据流处理：在处理大量数据流时，如果只需要关注”最重要”的k个元素，可以维护一个大小为k的堆。</li>
</ol>
<h4 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h4><h5 id="Java标准库中的堆实现"><a href="#Java标准库中的堆实现" class="headerlink" title="Java标准库中的堆实现"></a>Java标准库中的堆实现</h5><p>Java 提供了 <code>PriorityQueue</code> 类，它基于二叉堆实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueueExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 默认是最小堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        minHeap.add(<span class="number">5</span>);</span><br><span class="line">        minHeap.add(<span class="number">3</span>);</span><br><span class="line">        minHeap.add(<span class="number">8</span>);</span><br><span class="line">        minHeap.add(<span class="number">1</span>);</span><br><span class="line">        minHeap.add(<span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;优先队列内容：&quot;</span> + minHeap);</span><br><span class="line">        System.out.println(<span class="string">&quot;最小元素：&quot;</span> + minHeap.peek());</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;提取最小元素：&quot;</span> + minHeap.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;提取后的优先队列：&quot;</span> + minHeap);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建最大堆（通过自定义比较器）</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line">        </span><br><span class="line">        maxHeap.add(<span class="number">5</span>);</span><br><span class="line">        maxHeap.add(<span class="number">3</span>);</span><br><span class="line">        maxHeap.add(<span class="number">8</span>);</span><br><span class="line">        maxHeap.add(<span class="number">1</span>);</span><br><span class="line">        maxHeap.add(<span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;最大堆内容：&quot;</span> + maxHeap);</span><br><span class="line">        System.out.println(<span class="string">&quot;最大元素：&quot;</span> + maxHeap.peek());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="堆的变种"><a href="#堆的变种" class="headerlink" title="堆的变种"></a>堆的变种</h5><p>除了基本的二叉堆，还有几种重要的堆变种：</p>
<ol>
<li>d叉堆（d-ary Heap）：每个节点最多有d个子节点，而不是2个。增加d值可以减少堆的高度，在某些应用中可以提高性能。</li>
<li>斐波那契堆（Fibonacci Heap）：一种更复杂的堆结构，提供了更高效的合并操作和摊销时间复杂度。许多高级图算法使用斐波那契堆来提高性能。</li>
<li>左偏树（Leftist Heap）：一种支持高效合并操作的堆，常用于并行计算和分布式系统。</li>
<li>配对堆（Pairing Heap）：结构简单但性能优异的堆实现，特别适合需要频繁合并和减小键值的应用。</li>
</ol>
<h4 id="测验-13"><a href="#测验-13" class="headerlink" title="测验"></a>测验</h4><ol>
<li>二叉堆是一种什么样的数据结构？它有哪两种主要类型？</li>
<li>如果一个最小堆的数组表示为 [3, 5, 8, 6, 9, 10, 12]，那么元素5的左右子节点分别是什么？</li>
<li>在一个包含n个元素的二叉堆中，查找最大/最小元素、插入新元素和删除堆顶元素的时间复杂度分别是多少？</li>
<li>如果要将一个无序数组转换为堆，最坏情况下的时间复杂度是多少？</li>
<li>为什么二叉堆通常使用数组而不是链表来实现？</li>
</ol>
<blockquote>
<h5 id="测验答案-3"><a href="#测验答案-3" class="headerlink" title="测验答案"></a>测验答案</h5><ol>
<li>二叉堆是一种特殊的完全二叉树数据结构，它满足堆属性。主要有两种类型：最大堆（父节点值大于等于子节点值）和最小堆（父节点值小于等于子节点值）。</li>
<li>在数组表示的堆中，如果一个节点的索引是i，那么它的左子节点索引是2i+1，右子节点索引是2i+2。元素5的索引是1，所以它的左子节点是索引为3的元素6，右子节点是索引为4的元素9。</li>
<li>1）查找最大/最小元素：O(1) 2）插入新元素：O(log n) 3）删除堆顶元素：O(log n)</li>
<li>将无序数组转换为堆的时间复杂度是O(n)，这比直观预期的O(n log n)要好。因为使用了自底向上的建堆方法，对大多数节点只需要很少的下沉操作。</li>
<li>二叉堆使用数组实现有几个优点：1) 不需要额外的指针开销，节省内存；2) 利用索引公式可以直接计算父子节点位置，无需存储额外引用；3) 数组的连续内存分配提供了更好的内存局部性，有利于缓存性能；4) 实现简单，易于理解和维护。</li>
</ol>
</blockquote>
<h3 id="六、B树"><a href="#六、B树" class="headerlink" title="六、B树"></a>六、B树</h3><p>B树是一种自平衡的多路搜索树，常用于数据库和文件系统中的索引结构。它可以在内部节点和叶子节点存储数据，并且所有节点的高度保持平衡，有效减少了访问次数。</p>
<h5 id="算法讲解-14"><a href="#算法讲解-14" class="headerlink" title="算法讲解"></a>算法讲解</h5><h4 id="B树教程"><a href="#B树教程" class="headerlink" title="B树教程"></a>B树教程</h4><h5 id="介绍-14"><a href="#介绍-14" class="headerlink" title="介绍"></a>介绍</h5><p>B树是一种自平衡的多路搜索树，它是二叉搜索树的扩展，专为磁盘或其他外部存储设备设计。B树的每个节点拥有更多的子节点，这使树的高度更低，减少访问磁盘的次数。</p>
<p>B树中的几个关键概念：</p>
<ul>
<li>阶（Order）：定义了一个B树节点最多可以有多少个子节点。具有阶为m的B树也称为m阶B树。</li>
<li>内部节点（Internal Node）：除根节点和叶节点外的所有节点。</li>
<li>叶节点（Leaf Node）：没有子节点的节点。</li>
<li>键（Key）：存储在节点中的值，用于指导搜索过程。</li>
<li>子节点（Child）：节点的直接后代。</li>
</ul>
<p>一个阶为m的B树满足以下性质：</p>
<ol>
<li>每个节点最多有m个子节点</li>
<li>除了根节点和叶节点，每个节点至少有⌈m/2⌉个子节点</li>
<li>如果根节点不是叶节点，则至少有两个子节点</li>
<li>所有叶节点都在同一层</li>
<li>具有k个子节点的非叶节点包含k-1个键</li>
</ol>
<h4 id="核心特性-14"><a href="#核心特性-14" class="headerlink" title="核心特性"></a>核心特性</h4><ol>
<li>自平衡性：B树通过分裂和合并操作保持平衡，确保所有操作的对数时间复杂度。</li>
<li>多路分支：每个节点可以有多个子节点，而不仅仅是二叉树的两个，这降低了树的高度。</li>
<li>有序特性：B树中的键是有序存储的，使得搜索、插入和删除操作高效。</li>
<li>适合外部存储：B树的设计是为了最小化磁盘访问次数，特别适合处理大量数据时。</li>
<li>分块存储：键和指针组织在块中，这种结构与磁盘页面或数据块的物理特性匹配。</li>
</ol>
<h4 id="基本操作-13"><a href="#基本操作-13" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="搜索操作"><a href="#搜索操作" class="headerlink" title="搜索操作"></a>搜索操作</h5><p>搜索B树中的键与搜索二叉搜索树类似，但需要在每个节点中遍历多个键：</p>
<ul>
<li>从根节点开始</li>
<li>在当前节点内部按顺序查找目标键</li>
<li>如果找到，返回结果</li>
<li>如果未找到且节点是叶节点，则键不存在</li>
<li>否则，根据键的大小选择合适的子树继续搜索</li>
</ul>
<h5 id="插入操作-1"><a href="#插入操作-1" class="headerlink" title="插入操作"></a>插入操作</h5><ul>
<li>找到合适的叶节点位置</li>
<li>将键插入到叶节点中</li>
<li>如果插入导致节点超出最大容量，则分裂节点：<ul>
<li>选择中间键</li>
<li>将中间键上移到父节点</li>
<li>将原节点分为两个节点</li>
<li>如果父节点也超出容量，则继续向上分裂</li>
</ul>
</li>
</ul>
<h5 id="删除操作-1"><a href="#删除操作-1" class="headerlink" title="删除操作"></a>删除操作</h5><ul>
<li>找到包含要删除键的节点</li>
<li>如果节点是叶节点，直接删除</li>
<li>如果节点是内部节点，用前驱或后继替换要删除的键</li>
<li>如果删除导致节点键数量少于最小要求：<ul>
<li>尝试从兄弟节点借一个键</li>
<li>如果无法借用，则合并节点</li>
</ul>
</li>
</ul>
<h4 id="优缺点-13"><a href="#优缺点-13" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点-13"><a href="#优点-13" class="headerlink" title="优点"></a>优点</h5><ol>
<li>减少磁盘访问：B树的高度通常很低，即使存储大量数据也只需要少量磁盘访问。</li>
<li>适合大数据量：因为每个节点可以包含多个键，B树可以有效地存储和检索大量数据。</li>
<li>平衡性保证：B树始终保持平衡，没有最坏情况性能下降的问题。</li>
<li>高效的范围查询：由于键是有序的，B树支持高效的范围查询操作。</li>
<li>适合外部存储：B树的结构非常适合磁盘等外部存储系统，使其成为数据库索引的理想选择。</li>
</ol>
<h5 id="缺点-12"><a href="#缺点-12" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>实现复杂：与二叉树相比，B树的实现更为复杂，特别是删除操作。</li>
<li>空间利用率：B树节点可能未被完全填充，导致一定程度的空间浪费。</li>
<li>不适合内存操作：对于完全在内存中的数据结构，B树的优势不明显，可能比其他平衡树（如红黑树）效率低。</li>
<li>更新开销：插入和删除操作可能导致级联的节点分裂或合并，增加了操作的复杂性。</li>
</ol>
<h4 id="应用场景-13"><a href="#应用场景-13" class="headerlink" title="应用场景"></a>应用场景</h4><p>数据库系统是B树最主要的应用领域。几乎所有主流关系数据库都使用B树或其变种来实现索引。数据库引擎通过B树索引可以快速定位到数据所在的页面，极大提升查询性能。例如，MySQL的InnoDB存储引擎使用B+树（B树的变种）来构建其索引结构。</p>
<p>文件系统也广泛采用B树来组织文件和目录。如NTFS、HFS+等文件系统都使用B树或其变种来管理文件分配表和目录结构，有效地支持大型存储系统中的文件检索。</p>
<p>时间序列数据库或地理信息系统中，经常需要检索特定范围内的数据点，B树的有序特性使这类操作变得高效。</p>
<p>键值存储系统如Redis、LevelDB等也借鉴了B树的设计理念。虽然它们可能使用了不同的变种或混合结构，但基本思想源自B树的高效查找和范围操作特性。</p>
<h4 id="扩展：B树的变种"><a href="#扩展：B树的变种" class="headerlink" title="扩展：B树的变种"></a>扩展：B树的变种</h4><h5 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h5><p>B+树是B树的一个重要变种，它在数据库系统中更为常用：</p>
<ul>
<li>所有数据都存储在叶节点</li>
<li>内部节点仅包含键，不包含数据</li>
<li>叶节点通过链表连接，支持更高效的顺序访问</li>
<li>适合范围查询和顺序扫描</li>
</ul>
<h5 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h5><p>B*树对B树进行了进一步优化：</p>
<ul>
<li>非根节点至少2/3满（而不是1/2）</li>
<li>在节点分裂前先尝试与兄弟节点重新分配</li>
<li>分裂时涉及两个节点变为三个节点</li>
<li>提高了空间利用率</li>
</ul>
<h4 id="测验-14"><a href="#测验-14" class="headerlink" title="测验"></a>测验</h4><ol>
<li>什么是B树的阶（Order）？一个5阶B树的节点最多能有多少个键和多少个子节点？</li>
<li>B树和二叉搜索树的主要区别是什么？为什么B树更适合磁盘存储？</li>
</ol>
<blockquote>
<p>测验答案</p>
<ol>
<li>B树的阶（Order）定义了一个节点最多可以有多少个子节点。一个5阶B树的节点最多可以有5个子节点和4个键（一般来说，m阶B树节点最多有m个子节点和m-1个键）。</li>
<li>B树与二叉搜索树的主要区别是：B树每个节点可以有多个键和子节点（不仅仅是两个）。这使B树的高度显著降低，减少访问磁盘的次数。B树特别适合磁盘存储是因为它的结构设计考虑了磁盘的访问特性，通过减少I/O操作次数来提高性能。每个节点的大小通常设计为与磁盘块的大小匹配，这样一次磁盘读取就可以获取一个完整节点。</li>
</ol>
</blockquote>
<h3 id="七、B-树"><a href="#七、B-树" class="headerlink" title="七、B+树"></a>七、B+树</h3><p>B+树是一种平衡的多路搜索树，常用于数据库和文件系统中的索引结构。它的所有数据记录都存储在叶子节点，叶子节点之间通过指针连接形成有序链表，非叶子节点仅用于索引。</p>
<h5 id="算法讲解-15"><a href="#算法讲解-15" class="headerlink" title="算法讲解"></a>算法讲解</h5><h4 id="B-树-2"><a href="#B-树-2" class="headerlink" title="B+树"></a>B+树</h4><h5 id="介绍-15"><a href="#介绍-15" class="headerlink" title="介绍"></a>介绍</h5><p>B+树是一种平衡树数据结构，是B树的变种，被广泛应用于数据库索引和文件系统中。B+树保持数据有序，而且能够高效地进行查找、顺序访问、插入和删除操作。</p>
<p>B+树的主要组成部分包括：</p>
<ul>
<li>节点：B+树中的基本单元，分为内部节点和叶子节点</li>
<li>内部节点：只存储键值和指向子节点的指针，不存储数据</li>
<li>叶子节点：存储键值和真实数据（或指向数据的指针）</li>
<li>阶数（order）：表示一个节点最多可以有多少个子节点，通常用m表示</li>
<li>链表：所有叶子节点形成一个有序链表，方便范围查询</li>
</ul>
<blockquote>
<p>面试鸭上也有很多关于 B+ 树的内容：<a target="_blank" rel="noopener" href="https://www.mianshiya.com/search/all?searchText=B%2B树">https://www.mianshiya.com/search/all?searchText=B%2B%E6%A0%91</a></p>
</blockquote>
<h4 id="核心特性-15"><a href="#核心特性-15" class="headerlink" title="核心特性"></a>核心特性</h4><ol>
<li>所有数据都存储在叶子节点上：内部节点只存储键值和指针，不存储实际数据</li>
<li>所有叶子节点通过指针连接成有序链表：便于范围查询和顺序遍历</li>
<li>平衡树结构：所有叶子节点到根节点的距离相同</li>
<li>高扇出性（High Fan-out）：每个节点可以包含多个键值和指针，减少树的高度</li>
<li>自平衡：在插入和删除操作后自动调整以保持平衡</li>
</ol>
<h4 id="基本操作-14"><a href="#基本操作-14" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="查找操作-1"><a href="#查找操作-1" class="headerlink" title="查找操作"></a>查找操作</h5><ol>
<li>从根节点开始，根据键值比较确定应该查找哪个子节点</li>
<li>递归向下查找，直到到达叶子节点</li>
<li>在叶子节点中查找目标数据</li>
</ol>
<h5 id="插入操作-2"><a href="#插入操作-2" class="headerlink" title="插入操作"></a>插入操作</h5><ol>
<li>找到应插入的叶子节点</li>
<li>将数据插入到该叶子节点</li>
<li>如果叶子节点溢出（超过最大容量）：<ul>
<li>分裂节点为两部分</li>
<li>选择一个键值上升到父节点</li>
<li>如有必要，递归向上分裂</li>
</ul>
</li>
</ol>
<h5 id="删除操作-2"><a href="#删除操作-2" class="headerlink" title="删除操作"></a>删除操作</h5><ol>
<li>找到包含目标数据的叶子节点</li>
<li>从叶子节点中删除数据</li>
<li>如果节点下溢（低于最小容量要求）：<ul>
<li>尝试从相邻节点借用数据</li>
<li>如果无法借用，则合并节点</li>
<li>如有必要，递归向上调整</li>
</ul>
</li>
</ol>
<h4 id="优缺点-14"><a href="#优缺点-14" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点-14"><a href="#优点-14" class="headerlink" title="优点"></a>优点</h5><ol>
<li>高效的范围查询：叶子节点构成链表，可以快速进行范围查询</li>
<li>更少的IO操作：高扇出性使树高度较低，减少磁盘访问次数</li>
<li>适合外部存储：节点可以映射到磁盘块，优化磁盘IO</li>
<li>动态平衡：插入删除后自动维持平衡状态</li>
<li>较大的分支因子：每个节点可以存储更多键值，减少树的高度</li>
</ol>
<h5 id="缺点-13"><a href="#缺点-13" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>实现复杂：相比简单的树结构，实现较为复杂</li>
<li>修改开销大：插入和删除操作可能导致节点分裂或合并，级联影响多个节点</li>
<li>空间利用率：内部节点不存储数据，可能导致空间利用率不如其他结构</li>
<li>不适合频繁更新的场景：频繁的插入删除操作会导致频繁的树结构调整</li>
</ol>
<h4 id="应用场景-14"><a href="#应用场景-14" class="headerlink" title="应用场景"></a>应用场景</h4><p>B+树在数据库系统和文件系统中得到了广泛应用。在数据库领域，几乎所有主流关系型数据库的索引结构都采用了B+树或其变种。MySQL的InnoDB存储引擎使用B+树作为其主要索引结构，通过将数据按主键顺序组织在叶子节点中，实现了高效的查询和范围扫描操作。</p>
<p>在文件系统中，B+树被用于管理文件的目录结构和索引，比如NTFS、ext4等现代文件系统。由于B+树能够高效地处理大量数据，同时保持较低的树高度，使文件系统能够快速定位和访问文件。</p>
<p>B+树还被广泛应用于地理信息系统(GIS)中的空间索引，快速查找特定地理区域内的对象。</p>
<h4 id="测验-15"><a href="#测验-15" class="headerlink" title="测验"></a>测验</h4><ol>
<li>B+树与普通B树的主要区别是什么？</li>
<li>为什么数据库索引普遍使用B+树而不是其他平衡树结构（如红黑树）？</li>
<li>一个阶为5的B+树，其内部节点最多可以有多少个键和多少个子节点？叶子节点最多可以存储多少对键值对？</li>
<li>在B+树中进行范围查询（如查找10-50之间的所有值）的基本过程是什么？</li>
</ol>
<blockquote>
<h5 id="测验答案-4"><a href="#测验答案-4" class="headerlink" title="测验答案"></a>测验答案</h5><ol>
<li>B+树与普通B树的主要区别：<ul>
<li>B+树所有数据记录都存储在叶子节点，内部节点只存储键值</li>
<li>B+树所有叶子节点通过指针连接形成有序链表</li>
<li>B+树内部节点的键值在叶子节点中也会重复出现</li>
</ul>
</li>
<li>数据库索引使用B+树的原因：<ul>
<li>B+树高扇出性能导致树高度低，减少磁盘IO次数</li>
<li>所有叶子节点形成链表，支持高效的范围查询</li>
<li>节点设计能够很好地映射到磁盘块，优化物理存储</li>
<li>相比红黑树等二叉树，B+树的多路分支特性使其在外存环境下性能更优</li>
</ul>
</li>
<li>阶为5的B+树：<ul>
<li>内部节点最多有4个键（m-1）和5个子节点（m）</li>
<li>叶子节点最多可以存储4对键值对（m-1）</li>
</ul>
</li>
<li>B+树范围查询过程：<ul>
<li>首先通过树的查找操作找到包含起始值（这里是10）的叶子节点</li>
<li>在该叶子节点中找到起始值的位置</li>
<li>从该位置开始，沿着叶子节点链表顺序访问后续元素</li>
<li>持续收集满足条件的值（10-50之间的值），直到找到大于结束值（50）的元素或遍历完所有叶子节点</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="八、Trie树（字典树）"><a href="#八、Trie树（字典树）" class="headerlink" title="八、Trie树（字典树）"></a>八、Trie树（字典树）</h3><p>Trie树是一种特殊的前缀树结构，常用于字符串检索和匹配。每个节点代表一个字符，从根节点到任意节点的路径表示一个字符串。它特别适合用于实现字典查找、自动补全和拼写检查等功能。</p>
<h5 id="算法讲解-16"><a href="#算法讲解-16" class="headerlink" title="算法讲解"></a>算法讲解</h5><h4 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h4><h5 id="介绍-16"><a href="#介绍-16" class="headerlink" title="介绍"></a>介绍</h5><p>Trie树，也称为前缀树或字典树，是一种树形数据结构，专门用于高效存储和检索字符串集合。Trie这个名字来源于”retrieval”（检索）一词，反映了它的主要用途。</p>
<p>在Trie树中，每个节点代表一个字符，从根节点到某一节点的路径上经过的字符连接起来，就是该节点对应的字符串。Trie树的关键特点是，所有拥有相同前缀的字符串，在树中共享这个前缀的存储空间。</p>
<h4 id="核心特性-16"><a href="#核心特性-16" class="headerlink" title="核心特性"></a>核心特性</h4><ol>
<li>前缀共享: 具有相同前缀的字符串在Trie树中共享存储空间，大大节省了内存</li>
<li>快速查找: 查找一个长度为k的字符串的时间复杂度为O(k)，与Trie树中存储的字符串总数无关</li>
<li>词汇关联: 通过前缀可以轻松找到所有具有该前缀的单词</li>
<li>有序性: Trie树天然地保持了字典序</li>
</ol>
<h4 id="基本操作-15"><a href="#基本操作-15" class="headerlink" title="基本操作"></a>基本操作</h4><p>Trie树支持以下基本操作：</p>
<ol>
<li>插入(Insert): 将一个字符串添加到Trie树中</li>
<li>查找(Search): 检查一个完整的字符串是否存在于Trie树中</li>
<li>前缀查找(StartsWith): 检查Trie树中是否有以给定前缀开头的字符串</li>
<li>删除(Delete): 从Trie树中删除一个字符串（相对复杂）</li>
</ol>
<h4 id="代码实现-14"><a href="#代码实现-14" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trie树的节点结构</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">        <span class="comment">// 子节点，使用数组实现（假设只包含小写字母a-z）</span></span><br><span class="line">        <span class="keyword">private</span> TrieNode[] children;</span><br><span class="line">        <span class="comment">// 标记该节点是否为某个单词的结尾</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> isEndOfWord;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">            children = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>]; <span class="comment">// 26个英文字母</span></span><br><span class="line">            isEndOfWord = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 初始化Trie树 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 向Trie树中插入单词 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 将字符转换为索引</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果当前字符的节点不存在，创建一个新节点</span></span><br><span class="line">            <span class="keyword">if</span> (current.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                current.children[index] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 移动到下一个节点</span></span><br><span class="line">            current = current.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 标记单词结束</span></span><br><span class="line">        current.isEndOfWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 查找Trie树中是否存在完整单词 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> searchPrefix(word);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 节点存在且是单词结尾</span></span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">null</span> &amp;&amp; node.isEndOfWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 查找Trie树中是否存在指定前缀 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="comment">// 只需要节点存在即可</span></span><br><span class="line">        <span class="keyword">return</span> searchPrefix(prefix) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 查找前缀对应的节点 */</span></span><br><span class="line">    <span class="keyword">private</span> TrieNode <span class="title function_">searchPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> prefix.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果当前字符的节点不存在，返回null</span></span><br><span class="line">            <span class="keyword">if</span> (current.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            current = current.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 从Trie树中删除单词（较复杂的操作） */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        delete(root, word, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(TrieNode current, String word, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">// 已经处理完所有字符</span></span><br><span class="line">        <span class="keyword">if</span> (index == word.length()) &#123;</span><br><span class="line">            <span class="comment">// 如果不是单词结尾，单词不存在</span></span><br><span class="line">            <span class="keyword">if</span> (!current.isEndOfWord) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 取消标记单词结尾</span></span><br><span class="line">            current.isEndOfWord = <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果节点没有子节点，可以删除</span></span><br><span class="line">            <span class="keyword">return</span> hasNoChildren(current);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> word.charAt(index);</span><br><span class="line">        <span class="type">int</span> <span class="variable">childIndex</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">child</span> <span class="operator">=</span> current.children[childIndex];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果字符对应的节点不存在，单词不存在</span></span><br><span class="line">        <span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归删除子节点</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">shouldDeleteChild</span> <span class="operator">=</span> delete(child, word, index + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果子节点应该被删除</span></span><br><span class="line">        <span class="keyword">if</span> (shouldDeleteChild) &#123;</span><br><span class="line">            current.children[childIndex] = <span class="literal">null</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果当前节点不是单词结尾且没有其他子节点，则它也可以被删除</span></span><br><span class="line">            <span class="keyword">return</span> !current.isEndOfWord &amp;&amp; hasNoChildren(current);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasNoChildren</span><span class="params">(TrieNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (TrieNode child : node.children) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<h4 id="优缺点-15"><a href="#优缺点-15" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点-15"><a href="#优点-15" class="headerlink" title="优点"></a>优点</h5><ol>
<li>高效的字符串检索：查找、插入和删除操作的时间复杂度与字符串长度成正比(O(k))，而与存储的字符串总数无关</li>
<li>节省空间：通过共享前缀，减少了重复存储</li>
<li>支持按字典序遍历：可以方便地按字典序输出所有字符串</li>
<li>前缀匹配高效：特别适合前缀查询和自动补全功能</li>
</ol>
<h5 id="缺点-14"><a href="#缺点-14" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>内存消耗：对于不共享前缀的字符串集合，Trie树可能消耗大量内存</li>
<li>空间复杂度高：每个节点需要存储所有可能字符的引用（如上例中每个节点存储26个子节点引用）</li>
<li>不适合单次查询：如果只需要进行单次的精确字符串查询，哈希表可能是更好的选择</li>
<li>实现较为复杂：特别是删除操作，需要额外的逻辑来处理节点的清理</li>
</ol>
<h4 id="应用场景-15"><a href="#应用场景-15" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>自动补全和拼写检查：当用户在搜索框中输入时，Trie树可以快速找到所有以当前输入为前缀的单词，提供智能提示。输入法和文本编辑器通常利用这一特性实现单词补全功能。</li>
<li>IP路由表：网络路由器使用类似Trie的结构来存储IP地址，实现高效的最长前缀匹配。</li>
<li>字典和词汇表：电子字典应用可以使用Trie树来存储词汇，支持快速查找和前缀搜索。</li>
<li>文本分析：在自然语言处理中，Trie树可以用于单词频率统计、关键词提取等任务。</li>
<li>电话号码簿：通讯录应用可以使用Trie树来存储联系人信息，支持按号码前缀搜索。</li>
</ul>
<h4 id="测验-16"><a href="#测验-16" class="headerlink" title="测验"></a>测验</h4><p>1）一个包含10000个单词的Trie树，查找一个长度为15的单词的时间复杂度是多少？为什么？</p>
<p>2）Trie树与哈希表相比，在字符串存储和检索方面有什么优势和劣势？</p>
<p>3）如果要在Trie树中存储的不是26个小写英文字母，而是所有ASCII字符（共128个），应该如何修改Trie节点的实现？这种修改会带来什么问题？</p>
<p>4）描述在Trie树中删除一个单词的过程中可能遇到的复杂情况，以及如何处理这些情况。</p>
<blockquote>
<p>测验答案</p>
<p>1）时间复杂度是O(15)，即O(k)，其中k是单词长度。因为在Trie树中查找一个单词的时间复杂度只与单词长度有关，与树中存储的单词总数无关。查找过程就是沿着单词的每个字符在树中遍历，共需要15步。</p>
<p>2）</p>
<ul>
<li>优势：Trie树支持按前缀查找；保持字符串的有序性；对于有共同前缀的字符串集合更节省空间；查找时间与字符串总数无关。</li>
<li>劣势：Trie树的空间消耗可能较大，特别是当字符集较大时；实现更复杂；对于单次精确查询，哈希表通常更快。</li>
</ul>
<p>3）需要将TrieNode类中的children数组大小从26改为128，即<code>children = new TrieNode[128]</code>，并且修改索引计算逻辑为<code>int index = ch</code>，不再需要减去’a’。这种修改会使每个节点占用更多内存，因为即使只用到少数几个字符，每个节点仍需要为所有128个可能的字符分配空间，导致内存使用效率降低。</p>
<p>4）</p>
<ul>
<li>要删除的单词是另一个单词的前缀：这种情况下，只需将该单词的终止标记设为false，而不删除任何节点。</li>
<li>要删除的单词包含其他单词的前缀：需要仅删除不影响其他单词的节点。删除应从单词末尾向上进行，当遇到被标记为单词结尾的节点或有多个子节点的节点时停止。</li>
<li>需要使用递归或自底向上的方法，确保只删除不再需要的节点，保留其他单词所需的节点。</li>
</ul>
</blockquote>
<h3 id="九、树状数组"><a href="#九、树状数组" class="headerlink" title="九、树状数组"></a>九、树状数组</h3><p>树状数组(Binary Indexed Tree或Fenwick Tree)是一种用于高效处理数组前缀和的数据结构，利用二进制特性支持O(log n)时间的单点更新和区间查询操作。</p>
<h5 id="算法讲解-17"><a href="#算法讲解-17" class="headerlink" title="算法讲解"></a>算法讲解</h5><h4 id="树状数组（Binary-Indexed-Tree）数据结构"><a href="#树状数组（Binary-Indexed-Tree）数据结构" class="headerlink" title="树状数组（Binary Indexed Tree）数据结构"></a>树状数组（Binary Indexed Tree）数据结构</h4><p>树状数组（Binary Indexed Tree），也称为Fenwick Tree，是一种支持高效的前缀和计算和单点更新的数据结构。它的核心思想是利用二进制的性质来维护数据间的层级关系，从而在O(log n)的时间内完成查询和更新操作。</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>树状数组的关键概念是”父子关系”，这种关系是通过二进制表示中的最低位1来确定的。对于任意一个节点i，它的父节点是i + (i &amp; -i)，它的子节点是i - (i &amp; -i)。</p>
<ul>
<li>i &amp; -i 表达式计算的是i的二进制表示中的最低位1对应的值</li>
<li>例如：6的二进制是110，6&amp;(-6) = 6&amp;(010) = 2</li>
</ul>
<h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>树状数组通常使用一个一维数组表示，采用1-indexed（即从索引1开始存储有效数据）的方式：</p>
<ul>
<li>BIT[i]存储了原始数组中某个区间的和</li>
<li>每个BIT[i]负责管理的区间长度由i &amp; -i决定</li>
<li>例如，BIT[6]管理的区间长度是2，包含原始数组中的A[5]和A[6]</li>
</ul>
<h4 id="核心操作"><a href="#核心操作" class="headerlink" title="核心操作"></a>核心操作</h4><h5 id="1-更新操作（update）"><a href="#1-更新操作（update）" class="headerlink" title="1. 更新操作（update）"></a>1. 更新操作（update）</h5><p>更新原始数组中索引i的值时，需要更新树状数组中所有包含该索引的节点。</p>
<p>更新步骤：</p>
<ol>
<li>从索引i开始</li>
<li>不断地加上i &amp; -i，直到超出数组范围</li>
<li>在每一步都更新对应的树状数组值</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">▼<span class="title class_">Javascript</span>复制代码<span class="keyword">function</span> <span class="title function_">update</span>(<span class="params">i, delta</span>) &#123;</span><br><span class="line">  i = i + <span class="number">1</span>; <span class="comment">// 转为1-indexed</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">    bit[i] += delta;</span><br><span class="line">    i += i &amp; -i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-查询前缀和（query）"><a href="#2-查询前缀和（query）" class="headerlink" title="2. 查询前缀和（query）"></a>2. 查询前缀和（query）</h5><p>查询从1到i的所有元素的和。</p>
<p>查询步骤：</p>
<ol>
<li>从索引i开始</li>
<li>不断地减去i &amp; -i，直到i变为0</li>
<li>在每一步都累加对应的树状数组值</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">▼<span class="title class_">Javascript</span>复制代码<span class="keyword">function</span> <span class="title function_">query</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  i = i + <span class="number">1</span>; <span class="comment">// 转为1-indexed</span></span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    sum += bit[i];</span><br><span class="line">    i -= i &amp; -i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul>
<li>初始化：O(n log n)</li>
<li>单点更新：O(log n)</li>
<li>前缀和查询：O(log n)</li>
<li>区间查询：O(log n)</li>
</ul>
<h4 id="应用场景-16"><a href="#应用场景-16" class="headerlink" title="应用场景"></a>应用场景</h4><p>树状数组在以下场景中特别有用：</p>
<ol>
<li><strong>频繁的区间查询和单点更新</strong>：如果需要经常计算前缀和并且数组中的值会频繁变化，树状数组是一个很好的选择。</li>
<li><strong>计数应用</strong>：如逆序对计数、区间统计等。</li>
<li><strong>2D/多维前缀和</strong>：树状数组可以很容易地扩展到多维空间，处理二维甚至多维的前缀和查询。</li>
<li><strong>动态排名统计</strong>：通过树状数组可以维护一个动态的排名统计。</li>
</ol>
<h5 id="树状数组的优势"><a href="#树状数组的优势" class="headerlink" title="树状数组的优势"></a>树状数组的优势</h5><ul>
<li><strong>实现简单</strong>：相比于线段树，树状数组的代码更加简洁。</li>
<li><strong>常数因子小</strong>：在实际应用中，树状数组通常比线段树更快，因为它的常数因子更小。</li>
<li><strong>空间效率高</strong>：树状数组只需要与原始数组相同大小的空间。</li>
</ul>
<h4 id="扩展：区间更新"><a href="#扩展：区间更新" class="headerlink" title="扩展：区间更新"></a>扩展：区间更新</h4><p>通过差分数组技术，树状数组可以支持区间更新，但查询变为单点查询，这样就能在O(log n)时间内完成区间更新操作。</p>
<h5 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个树状数组</span></span><br><span class="line"><span class="keyword">const</span> bit = <span class="keyword">new</span> <span class="title class_">BinaryIndexedTree</span>([<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询前缀和</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bit.<span class="title function_">query</span>(<span class="number">2</span>)); <span class="comment">// 索引0到2的和: 2+1+4=7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新元素值</span></span><br><span class="line">bit.<span class="title function_">update</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 将索引1的元素增加2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bit.<span class="title function_">query</span>(<span class="number">2</span>)); <span class="comment">// 现在索引0到2的和: 2+(1+2)+4=9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间查询</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bit.<span class="title function_">rangeQuery</span>(<span class="number">1</span>, <span class="number">3</span>)); <span class="comment">// 索引1到3的和: (1+2)+4+3=10</span></span><br></pre></td></tr></table></figure>
<p>树状数组是一种优雅而高效的数据结构，尤其在需要频繁执行前缀和操作和单点更新的场景中，它比简单数组更高效，比线段树更简洁。理解了其背后的二进制原理，可以帮助我们写出更高效的算法。</p>
<h3 id="十、线段树"><a href="#十、线段树" class="headerlink" title="十、线段树"></a>十、线段树</h3><p>线段树是一种树形数据结构，用于存储区间或线段，并且允许快速查询区间信息（如求和、最大值、最小值等）以及进行区间更新。线段树特别适合解决区间查询问题，其查询和更新操作的时间复杂度都是O(log n)。</p>
<p><code>空间复杂度:O(n)</code></p>
<h5 id="算法讲解-18"><a href="#算法讲解-18" class="headerlink" title="算法讲解"></a>算法讲解</h5><h4 id="线段树（Segment-Tree）"><a href="#线段树（Segment-Tree）" class="headerlink" title="线段树（Segment Tree）"></a>线段树（Segment Tree）</h4><h5 id="介绍-17"><a href="#介绍-17" class="headerlink" title="介绍"></a>介绍</h5><p>线段树（Segment Tree）是一种高效的数据结构，专门用于解决区间查询和区间修改问题。与树状数组相比，线段树功能更加强大，可以支持更多种类的区间操作。</p>
<p>线段树的核心思想是通过分治法将一个区间划分为多个子区间，并用树的形式组织这些区间的信息。在这棵树中，每个节点代表一个区间，根节点代表整个数组区间，叶子节点代表单个元素。</p>
<p>核心概念解释：</p>
<ul>
<li>区间查询：查询数组中某个区间的聚合信息（如区间和、最大值、最小值等）</li>
<li>区间修改：修改数组中某个区间内所有元素的值</li>
<li>懒惰标记（Lazy Propagation）：延迟更新策略，用于提高区间修改的效率</li>
<li>树节点：每个节点存储其对应区间的信息，如区间和、最大值等</li>
</ul>
<h4 id="核心特性-17"><a href="#核心特性-17" class="headerlink" title="核心特性"></a>核心特性</h4><ol>
<li>灵活的区间操作：支持各种区间查询（和、最大值、最小值、异或和等）和区间修改</li>
<li>高效的时间复杂度：查询和修改的时间复杂度均为O(log n)</li>
<li>强大的扩展性：可以根据需求自定义区间操作的类型</li>
<li>适应动态变化：能够处理数组内容频繁变化的情况</li>
</ol>
<h4 id="基本操作-16"><a href="#基本操作-16" class="headerlink" title="基本操作"></a>基本操作</h4><ol>
<li>构建（build）：根据初始数组构建线段树</li>
<li>区间查询（query）：查询某个区间的聚合信息</li>
<li>单点修改（update）：修改单个元素的值</li>
<li>区间修改（updateRange）：修改一段区间内所有元素的值（通常使用懒惰标记实现）</li>
</ol>
<p>下面是线段树的基础实现（以区间和为例）：</p>
<h4 id="代码实现-15"><a href="#代码实现-15" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] tree;   <span class="comment">// 存储线段树节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] lazy;   <span class="comment">// 懒惰标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] nums;   <span class="comment">// 原始数组的副本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;        <span class="comment">// 原始数组长度</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SegmentTree</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        n = array.length;</span><br><span class="line">        <span class="comment">// 线段树数组大小一般为原数组大小的4倍</span></span><br><span class="line">        tree = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * n];</span><br><span class="line">        lazy = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * n];</span><br><span class="line">        nums = array.clone();</span><br><span class="line">        build(<span class="number">0</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建线段树</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            <span class="comment">// 叶子节点，存储单个元素</span></span><br><span class="line">            tree[node] = nums[start];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftNode</span> <span class="operator">=</span> <span class="number">2</span> * node + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightNode</span> <span class="operator">=</span> <span class="number">2</span> * node + <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归构建左右子树</span></span><br><span class="line">        build(leftNode, start, mid);</span><br><span class="line">        build(rightNode, mid + <span class="number">1</span>, end);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 合并子节点的信息</span></span><br><span class="line">        tree[node] = tree[leftNode] + tree[rightNode];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单点修改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 计算与原值的差值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> val - nums[index];</span><br><span class="line">        nums[index] = val;</span><br><span class="line">        updateSingle(<span class="number">0</span>, <span class="number">0</span>, n - <span class="number">1</span>, index, diff);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateSingle</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> index, <span class="type">int</span> diff)</span> &#123;</span><br><span class="line">        <span class="comment">// 检查索引是否在当前节点范围内</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; start || index &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新当前节点的值</span></span><br><span class="line">        tree[node] += diff;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (start != end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">leftNode</span> <span class="operator">=</span> <span class="number">2</span> * node + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rightNode</span> <span class="operator">=</span> <span class="number">2</span> * node + <span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 递归更新子节点</span></span><br><span class="line">            updateSingle(leftNode, start, mid, index, diff);</span><br><span class="line">            updateSingle(rightNode, mid + <span class="number">1</span>, end, index, diff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 区间查询</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queryRange(<span class="number">0</span>, <span class="number">0</span>, n - <span class="number">1</span>, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">queryRange</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点的区间完全在查询区间外</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; start || left &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前节点的区间完全在查询区间内</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt;= start &amp;&amp; end &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> tree[node];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理懒惰标记</span></span><br><span class="line">        <span class="keyword">if</span> (lazy[node] != <span class="number">0</span>) &#123;</span><br><span class="line">            tree[node] += (end - start + <span class="number">1</span>) * lazy[node];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (start != end) &#123;</span><br><span class="line">                lazy[<span class="number">2</span> * node + <span class="number">1</span>] += lazy[node];</span><br><span class="line">                lazy[<span class="number">2</span> * node + <span class="number">2</span>] += lazy[node];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            lazy[node] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查询范围部分覆盖当前节点的区间，需要分别查询左右子节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSum</span> <span class="operator">=</span> queryRange(<span class="number">2</span> * node + <span class="number">1</span>, start, mid, left, right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightSum</span> <span class="operator">=</span> queryRange(<span class="number">2</span> * node + <span class="number">2</span>, mid + <span class="number">1</span>, end, left, right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> leftSum + rightSum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 区间修改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        updateRangeTree(<span class="number">0</span>, <span class="number">0</span>, n - <span class="number">1</span>, left, right, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateRangeTree</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理当前节点的懒惰标记</span></span><br><span class="line">        <span class="keyword">if</span> (lazy[node] != <span class="number">0</span>) &#123;</span><br><span class="line">            tree[node] += (end - start + <span class="number">1</span>) * lazy[node];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (start != end) &#123;</span><br><span class="line">                lazy[<span class="number">2</span> * node + <span class="number">1</span>] += lazy[node];</span><br><span class="line">                lazy[<span class="number">2</span> * node + <span class="number">2</span>] += lazy[node];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            lazy[node] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前节点的区间完全在修改区间外</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; start || left &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前节点的区间完全在修改区间内</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt;= start &amp;&amp; end &lt;= right) &#123;</span><br><span class="line">            tree[node] += (end - start + <span class="number">1</span>) * val;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (start != end) &#123;</span><br><span class="line">                lazy[<span class="number">2</span> * node + <span class="number">1</span>] += val;</span><br><span class="line">                lazy[<span class="number">2</span> * node + <span class="number">2</span>] += val;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改范围部分覆盖当前节点的区间，需要分别修改左右子节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">        updateRangeTree(<span class="number">2</span> * node + <span class="number">1</span>, start, mid, left, right, val);</span><br><span class="line">        updateRangeTree(<span class="number">2</span> * node + <span class="number">2</span>, mid + <span class="number">1</span>, end, left, right, val);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新当前节点的值</span></span><br><span class="line">        tree[node] = tree[<span class="number">2</span> * node + <span class="number">1</span>] + tree[<span class="number">2</span> * node + <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<h4 id="线段树的工作原理"><a href="#线段树的工作原理" class="headerlink" title="线段树的工作原理"></a>线段树的工作原理</h4><p>线段树的结构：</p>
<p>线段树是一棵完全二叉树，其中：</p>
<ul>
<li>根节点代表整个数组区间[0, n-1]</li>
<li>每个非叶节点的左子节点代表区间的左半部分，右子节点代表右半部分</li>
<li>叶子节点代表单个元素（长度为1的区间）</li>
</ul>
<p>懒惰标记（Lazy Propagation）：</p>
<p>懒惰标记是一种优化技术，用于延迟区间修改的传播。当一个节点的所有子节点都需要被修改时，我们不立即修改这些子节点，而是在节点上标记修改信息，只有在需要访问子节点时才将修改下推，提高区间修改的效率。</p>
<h4 id="优缺点-16"><a href="#优缺点-16" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点-16"><a href="#优点-16" class="headerlink" title="优点"></a>优点</h5><ol>
<li>功能强大：支持多种区间操作，包括区间求和、最大值、最小值等</li>
<li>操作灵活：同时支持区间查询和区间修改</li>
<li>时间效率高：所有操作的时间复杂度均为O(log n)</li>
<li>可扩展性好：可以根据具体问题自定义节点存储的信息和操作方式</li>
</ol>
<h5 id="缺点-15"><a href="#缺点-15" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>内存消耗较大：需要额外的内存来存储线段树结构，通常为原数组大小的4倍</li>
<li>代码实现复杂：相比其他数据结构（如树状数组），实现和调试更加复杂</li>
<li>常数因子较大：虽然时间复杂度是O(log n)，但实际运行时间可能比树状数组等结构略长</li>
</ol>
<h4 id="应用场景-17"><a href="#应用场景-17" class="headerlink" title="应用场景"></a>应用场景</h4><p>线段树在许多实际问题中有广泛应用，特别是在需要同时支持区间查询和区间修改的情况下：</p>
<ol>
<li>范围检索系统：在数据库和信息检索系统中，线段树可用于快速查询满足特定条件的数据范围。例如，在时间序列数据库中，快速查找某一时间段内的最大/最小值或平均值。</li>
<li>图像处理：在处理大型图像数据时，线段树可用于快速计算图像某一区域的统计信息或实现区域性的图像编辑操作。</li>
<li>计算几何：在处理二维空间中的点、线或矩形等几何对象时，线段树可以高效地解决区间查询问题，如找出与给定区域相交的所有对象。</li>
<li>在线算法竞赛：线段树是解决动态范围查询问题的标准工具，如区间最大值、区间和等问题。</li>
<li>游戏开发：在大型多人在线游戏中，线段树可用于地图数据的管理和快速查询，如找出某区域内的所有游戏对象。</li>
</ol>
<h4 id="扩展-2"><a href="#扩展-2" class="headerlink" title="扩展"></a>扩展</h4><h5 id="动态线段树"><a href="#动态线段树" class="headerlink" title="动态线段树"></a>动态线段树</h5><p>当区间范围非常大，但实际有值的点比较稀疏时，可以使用动态线段树（通常使用指针实现）来节省空间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicSegmentTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;      <span class="comment">// 节点值</span></span><br><span class="line">        <span class="type">int</span> lazy;     <span class="comment">// 懒惰标记</span></span><br><span class="line">        Node left;    <span class="comment">// 左子节点</span></span><br><span class="line">        Node right;   <span class="comment">// 右子节点</span></span><br><span class="line">        <span class="type">int</span> start;    <span class="comment">// 区间起点</span></span><br><span class="line">        <span class="type">int</span> end;      <span class="comment">// 区间终点</span></span><br><span class="line">        </span><br><span class="line">        Node(<span class="type">int</span> start, <span class="type">int</span> end) &#123;</span><br><span class="line">            <span class="built_in">this</span>.start = start;</span><br><span class="line">            <span class="built_in">this</span>.end = end;</span><br><span class="line">            <span class="built_in">this</span>.val = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.lazy = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicSegmentTree</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>(start, end);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 区间更新</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        update(root, left, right, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Node node, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果区间完全在更新范围外</span></span><br><span class="line">        <span class="keyword">if</span> (node.end &lt; left || node.start &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果区间完全在更新范围内</span></span><br><span class="line">        <span class="keyword">if</span> (node.start &gt;= left &amp;&amp; node.end &lt;= right) &#123;</span><br><span class="line">            node.val += (node.end - node.start + <span class="number">1</span>) * val;</span><br><span class="line">            <span class="keyword">if</span> (node.start != node.end) &#123;</span><br><span class="line">                node.lazy += val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 下推懒惰标记</span></span><br><span class="line">        pushDown(node);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新左右子节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            update(node.left, left, right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            update(node.right, left, right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新当前节点的值</span></span><br><span class="line">        node.val = (node.left != <span class="literal">null</span> ? node.left.val : <span class="number">0</span>) + </span><br><span class="line">                   (node.right != <span class="literal">null</span> ? node.right.val : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 区间查询</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> query(root, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(Node node, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果区间完全在查询范围外</span></span><br><span class="line">        <span class="keyword">if</span> (node.end &lt; left || node.start &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果区间完全在查询范围内</span></span><br><span class="line">        <span class="keyword">if</span> (node.start &gt;= left &amp;&amp; node.end &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> node.val;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 下推懒惰标记</span></span><br><span class="line">        pushDown(node);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            sum += query(node.left, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            sum += query(node.right, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下推懒惰标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushDown</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.lazy == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (node.start + node.end) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建左子节点（如果不存在）</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.left = <span class="keyword">new</span> <span class="title class_">Node</span>(node.start, mid);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建右子节点（如果不存在）</span></span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.right = <span class="keyword">new</span> <span class="title class_">Node</span>(mid + <span class="number">1</span>, node.end);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新子节点的值和懒惰标记</span></span><br><span class="line">        node.left.val += (node.left.end - node.left.start + <span class="number">1</span>) * node.lazy;</span><br><span class="line">        node.right.val += (node.right.end - node.right.start + <span class="number">1</span>) * node.lazy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (node.left.start != node.left.end) &#123;</span><br><span class="line">            node.left.lazy += node.lazy;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right.start != node.right.end) &#123;</span><br><span class="line">            node.right.lazy += node.lazy;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 清除当前节点的懒惰标记</span></span><br><span class="line">        node.lazy = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="可持久化线段树（Persistent-Segment-Tree）"><a href="#可持久化线段树（Persistent-Segment-Tree）" class="headerlink" title="可持久化线段树（Persistent Segment Tree）"></a>可持久化线段树（Persistent Segment Tree）</h5><p>可持久化线段树是线段树的一种变体，它可以保存历史版本，允许查询任意历史状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersistentSegmentTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;      <span class="comment">// 节点值</span></span><br><span class="line">        Node left;    <span class="comment">// 左子节点</span></span><br><span class="line">        Node right;   <span class="comment">// 右子节点</span></span><br><span class="line">        </span><br><span class="line">        Node(<span class="type">int</span> val) &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Node(Node other) &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = other.val;</span><br><span class="line">            <span class="built_in">this</span>.left = other.left;</span><br><span class="line">            <span class="built_in">this</span>.right = other.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Node[] roots;  <span class="comment">// 存储历史版本的根节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;         <span class="comment">// 数组大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> versionCount; <span class="comment">// 版本数量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PersistentSegmentTree</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> maxVersions)</span> &#123;</span><br><span class="line">        n = array.length;</span><br><span class="line">        roots = <span class="keyword">new</span> <span class="title class_">Node</span>[maxVersions];</span><br><span class="line">        versionCount = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 构建初始版本</span></span><br><span class="line">        roots[versionCount++] = build(<span class="number">0</span>, n - <span class="number">1</span>, array);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建线段树</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">build</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(array[start]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">        node.left = build(start, mid, array);</span><br><span class="line">        node.right = build(mid + <span class="number">1</span>, end, array);</span><br><span class="line">        node.val = node.left.val + node.right.val;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建新版本并更新单个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        roots[versionCount] = update(roots[versionCount - <span class="number">1</span>], <span class="number">0</span>, n - <span class="number">1</span>, index, val);</span><br><span class="line">        versionCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">update</span><span class="params">(Node node, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; start || index &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建新节点（路径复制）</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(node);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            newNode.val = val;</span><br><span class="line">            <span class="keyword">return</span> newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (index &lt;= mid) &#123;</span><br><span class="line">            newNode.left = update(node.left, start, mid, index, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newNode.right = update(node.right, mid + <span class="number">1</span>, end, index, val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        newNode.val = newNode.left.val + newNode.right.val;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查询特定版本的区间和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> version, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (version &gt;= versionCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;版本不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> query(roots[version], <span class="number">0</span>, n - <span class="number">1</span>, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(Node node, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; start || left &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (left &lt;= start &amp;&amp; end &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> node.val;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> query(node.left, start, mid, left, right) + </span><br><span class="line">               query(node.right, mid + <span class="number">1</span>, end, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测验-17"><a href="#测验-17" class="headerlink" title="测验"></a>测验</h4><ol>
<li>线段树的每个节点代表什么？与二叉搜索树相比，它的节点组织方式有什么不同？</li>
<li>懒惰标记（Lazy Propagation）的作用是什么？它是如何提高区间修改操作效率的？</li>
<li>一个长度为n的数组，构建其线段树需要多少个节点？为什么？</li>
<li>在线段树中执行区间查询的时间复杂度是多少？请简要说明原因。</li>
<li>线段树和树状数组各有什么优缺点？在什么情况下应该选择线段树而非树状数组？</li>
</ol>
<blockquote>
<p>测验答案</p>
<ol>
<li>线段树的每个节点代表一个区间[start, end]，存储该区间的聚合信息（如区间和、最大值等）。与二叉搜索树不同，线段树的组织方式不是基于节点值的大小比较，而是基于区间的划分：每个非叶节点的左子节点代表区间的左半部分，右子节点代表右半部分。</li>
<li>懒惰标记是一种延迟更新的技术，用于优化区间修改操作。当需要对一个节点的所有子孙节点进行同样的修改时，不会立即递归地修改所有子节点，而是在当前节点上标记修改信息，只在需要访问子节点时才将修改信息下推。这样可以将区间修改的时间复杂度从O(n)优化到O(log n)。</li>
<li>一个长度为n的数组，构建其线段树需要至多4n个节点。这是因为线段树是一个近似的完全二叉树，对于一个有n个叶子的完全二叉树，一共有2n-1个节点。考虑到数组长度n可能不是2的幂，为了保险起见，通常分配4n的空间来确保足够。</li>
<li>线段树中执行区间查询的时间复杂度是O(log n)。这是因为在最坏情况下，一个区间查询需要访问O(log n)个节点：当查询区间与线段树的区间部分重叠时，需要分别查询左右子树；但由于树的高度是log n，因此最多需要访问O(log n)个节点。</li>
<li>线段树和树状数组的比较：<ul>
<li>线段树的优点：功能更强大，可以支持区间修改和多种区间查询（最大值、最小值等），适用范围更广。</li>
<li>线段树的缺点：实现复杂，内存消耗大，常数因子较大。</li>
<li>树状数组的优点：实现简单，内存消耗小，常数因子小，更加高效。</li>
<li>树状数组的缺点：功能有限，主要支持区间和查询和单点修改。</li>
<li>应选择线段树的情况：需要支持区间修改操作，或需要查询区间最大值/最小值等非可加性质的聚合信息时。</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="图结构"><a href="#图结构" class="headerlink" title="图结构"></a>图结构</h2><h3 id="一、边列表"><a href="#一、边列表" class="headerlink" title="一、边列表"></a>一、边列表</h3><p>边列表是表示图的一种简单方式，通过存储所有边的信息（起点、终点和权重）来表示图结构。适用于边数较少的稀疏图，特别适合需要频繁查询和操作边的应用场景。</p>
<p><code>空间复杂度:O(E)</code></p>
<h5 id="算法讲解-19"><a href="#算法讲解-19" class="headerlink" title="算法讲解"></a>算法讲解</h5><h4 id="边列表"><a href="#边列表" class="headerlink" title="边列表"></a>边列表</h4><h5 id="介绍-18"><a href="#介绍-18" class="headerlink" title="介绍"></a>介绍</h5><p>边列表是图论中最基础的图表示方式之一，它通过存储图中的每条边来描述整个图的结构。对于无权图，每条边表示为一个顶点对(u, v)；对于有权图，则表示为三元组(u, v, weight)。</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>边列表（Edge List）是表示图的一种简单数据结构，在理解它之前，我们需要先了解一些基础图论概念：</p>
<p>图（Graph）：由顶点（Vertex）和连接顶点的边（Edge）组成的数据结构。图可以用来表示现实世界中的各种关系，如社交网络、交通路线等。</p>
<p>顶点（Vertex）：图中的节点，通常用数字或字母标识，如 0, 1, 2… 或 A, B, C…</p>
<p>边（Edge）：连接两个顶点的线段，表示它们之间存在某种关系。</p>
<p>度（Degree）：指与该顶点相连的边的总数。</p>
<p>图根据不同特性可以分为几种类型：</p>
<p>无向图 vs 有向图：</p>
<ul>
<li>无向图：边没有方向，如果顶点 A 和 B 之间有边，则可以从 A 到 B，也可以从 B 到 A。</li>
<li>有向图：边有明确的方向，如果有一条从 A 到 B 的边，不代表一定有从 B 到 A 的边。比如社交系统中的”关注”。</li>
</ul>
<p>在有向图中，度分为入度和出度：</p>
<p>入度（In-degree）：指向该顶点的边的数量。</p>
<p>出度（Out-degree）：从该顶点指出的边的数量。</p>
<p>无权图 vs 有权图：</p>
<ul>
<li>无权图：边没有权重值，只表示两个顶点之间是否连接。</li>
<li>有权图：每条边带有一个权重值，表示两个顶点之间连接的某种度量（如距离、成本等）。例如城市间的公路网络，边的权重可以表示距离或行驶时间。</li>
</ul>
<p>边列表的存储方式：</p>
<ul>
<li>对于无权图：边列表中的每个元素是一个二元组 (u, v)，表示从顶点 u 到顶点 v 的一条边</li>
<li>对于有权图：边列表中的每个元素是一个三元组 (u, v, w)，其中 w 表示这条边的权重</li>
</ul>
<p>示例：<br> 假设有一个包含 4 个顶点 (0, 1, 2, 3) 的有权图，边的信息如下：</p>
<ul>
<li>0 连接到 1，权重为 5</li>
<li>0 连接到 2，权重为 3</li>
<li>1 连接到 2，权重为 2</li>
<li>2 连接到 3，权重为 7</li>
</ul>
<p>则其边列表表示为：[(0,1,5), (0,2,3), (1,2,2), (2,3,7)]</p>
<p>边列表虽然概念简单，但在某些算法（如 Kruskal 最小生成树算法）中具有明显优势，因为这些算法需要对所有边进行排序并逐一处理。</p>
<h4 id="核心特性-18"><a href="#核心特性-18" class="headerlink" title="核心特性"></a>核心特性</h4><ul>
<li>简单直观：直接存储边的信息，概念简单</li>
<li>空间效率：对于稀疏图（边数远小于|V|²的图）较为节省空间</li>
<li>添加边方便：只需在列表末尾添加新边</li>
<li>查找特定边效率低：需要遍历整个列表</li>
</ul>
<h4 id="基本操作-17"><a href="#基本操作-17" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li>添加边：将新的边添加到列表中</li>
<li>删除边：遍历列表找到对应边并删除</li>
<li>查找边：遍历列表查找特定边</li>
<li>遍历所有边：直接遍历列表</li>
</ul>
<h4 id="代码实现-16"><a href="#代码实现-16" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 无权图的边列表表示</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> source;      <span class="comment">// 边的起点</span></span><br><span class="line">    <span class="type">int</span> destination; <span class="comment">// 边的终点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> destination)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.source = source;</span><br><span class="line">        <span class="built_in">this</span>.destination = destination;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有权图的边列表表示</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeightedEdge</span> &#123;</span><br><span class="line">    <span class="type">int</span> source;      <span class="comment">// 边的起点</span></span><br><span class="line">    <span class="type">int</span> destination; <span class="comment">// 边的终点</span></span><br><span class="line">    <span class="type">int</span> weight;      <span class="comment">// 边的权重</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeightedEdge</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> destination, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.source = source;</span><br><span class="line">        <span class="built_in">this</span>.destination = destination;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用边列表表示的图</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="type">int</span> V; <span class="comment">// 顶点数</span></span><br><span class="line">    List&lt;Edge&gt; edges; <span class="comment">// 边列表</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> destination)</span> &#123;</span><br><span class="line">        edges.add(<span class="keyword">new</span> <span class="title class_">Edge</span>(source, destination));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印所有边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEdges</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : edges) &#123;</span><br><span class="line">            System.out.println(edge.source + <span class="string">&quot; -&gt; &quot;</span> + edge.destination);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<h4 id="优缺点-17"><a href="#优缺点-17" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>实现简单，容易理解</li>
<li>对于稀疏图，空间占用较小</li>
<li>非常适合某些算法（如Kruskal最小生成树算法）</li>
</ul>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>查找从某个顶点出发的所有边效率较低</li>
<li>判断两个顶点之间是否有边需要遍历整个列表</li>
<li>对于密集图，不如邻接矩阵或邻接表高效</li>
</ul>
<h4 id="应用场景-18"><a href="#应用场景-18" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>执行基于边的图算法，如Kruskal最小生成树算法</li>
<li>需要频繁遍历所有边的场景</li>
<li>存储稀疏图且不需要频繁查询特定边的情况</li>
<li>图的序列化和反序列化</li>
</ul>
<h4 id="测验-18"><a href="#测验-18" class="headerlink" title="测验"></a>测验</h4><ol>
<li>对于一个有5个顶点，7条边的无向图，如果使用边列表表示，边列表的长度是多少？</li>
<li>使用边列表表示一个有权图时，每条边通常需要存储哪些信息？</li>
<li>在边列表中，要判断图中是否存在环（cycle），需要怎样的算法复杂度？</li>
</ol>
<blockquote>
<p>测验答案</p>
<ol>
<li>7条边。边列表直接存储每条边，所以列表长度等于边数。</li>
<li>起点、终点和权重三个信息，通常表示为三元组(u, v, weight)。</li>
<li>至少需要O(V+E)的复杂度，因为需要遍历所有边并使用额外算法（如并查集或DFS）来检测环。</li>
</ol>
</blockquote>
<h3 id="二、有向图"><a href="#二、有向图" class="headerlink" title="二、有向图"></a>二、有向图</h3><p>有向图是一种边具有方向性的图结构，图中的边从一个顶点指向另一个顶点。有向图广泛应用于网络流量分析、社交网络关系建模、任务依赖关系等场景。</p>
<h5 id="算法讲解-20"><a href="#算法讲解-20" class="headerlink" title="算法讲解"></a>算法讲解</h5><h4 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h4><h5 id="介绍-19"><a href="#介绍-19" class="headerlink" title="介绍"></a>介绍</h5><p>有向图(Directed Graph，也称为Digraph)是图论中的一种基本图类型，其中每条边都有明确的方向。在有向图中，边由一个顶点（称为起点或源点）指向另一个顶点（称为终点或目标点）。这种有方向性的连接让有向图特别适合表示具有单向关系的各种现实问题。</p>
<p>有向图中的关键概念：</p>
<ul>
<li>顶点(Vertex)：图中的节点，通常用数字或字母标识。</li>
<li>有向边(Directed Edge)：从一个顶点指向另一个顶点的带方向连接，通常表示为有序对(u,v)，表示从顶点u到顶点v的边。</li>
<li>入度(In-degree)：指向某个顶点的边的数量。例如，如果有3条边指向顶点v，则顶点v的入度为3。</li>
<li>出度(Out-degree)：从某个顶点出发的边的数量。例如，如果从顶点u出发有2条边，则顶点u的出度为2。</li>
<li>路径(Path)：从一个顶点到另一个顶点经过的边的序列。</li>
<li>环(Cycle)：一条起点和终点相同的路径，表示可以从某顶点出发最终回到同一顶点。</li>
</ul>
<h4 id="核心特性-19"><a href="#核心特性-19" class="headerlink" title="核心特性"></a>核心特性</h4><ul>
<li>方向性：每条边都有明确的方向，从一个顶点指向另一个顶点</li>
<li>入度和出度：顶点的连接关系分为指入和指出两种</li>
<li>可能存在环：有向图中可能存在从一个顶点出发最终回到该顶点的路径</li>
<li>可达性：从一个顶点到另一个顶点可能存在路径，也可能不存在</li>
<li>强连通性：在强连通的有向图中，任意两点之间都存在相互可达的路径</li>
<li>拓扑排序：对于无环有向图(DAG)，可以将所有顶点排列成一个线性序列，使得所有边都从序列的前面指向后面</li>
</ul>
<h4 id="基本操作-18"><a href="#基本操作-18" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li>添加顶点：向图中添加新的顶点</li>
<li>添加有向边：在两个顶点之间添加一条有向边</li>
<li>删除顶点：从图中删除顶点及其相关的所有边</li>
<li>删除边：移除图中的某条有向边</li>
<li>判断可达性：判断从一个顶点到另一个顶点是否存在路径</li>
<li>查找入边/出边：获取指向某顶点的所有边或从某顶点出发的所有边</li>
<li>图的遍历：通过深度优先搜索(DFS)或广度优先搜索(BFS)遍历图中的所有顶点</li>
</ul>
<h4 id="代码实现-17"><a href="#代码实现-17" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有向图的边表示</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DirectedEdge</span> &#123;</span><br><span class="line">    <span class="type">int</span> source;      <span class="comment">// 边的起点</span></span><br><span class="line">    <span class="type">int</span> destination; <span class="comment">// 边的终点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DirectedEdge</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> destination)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.source = source;</span><br><span class="line">        <span class="built_in">this</span>.destination = destination;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> source + <span class="string">&quot; -&gt; &quot;</span> + destination;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带权重的有向边</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeightedDirectedEdge</span> &#123;</span><br><span class="line">    <span class="type">int</span> source;      <span class="comment">// 边的起点</span></span><br><span class="line">    <span class="type">int</span> destination; <span class="comment">// 边的终点</span></span><br><span class="line">    <span class="type">int</span> weight;      <span class="comment">// 边的权重</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeightedDirectedEdge</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> destination, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.source = source;</span><br><span class="line">        <span class="built_in">this</span>.destination = destination;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> source + <span class="string">&quot; -&gt; &quot;</span> + destination + <span class="string">&quot; (&quot;</span> + weight + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用边列表实现的有向图</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DirectedGraph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;                      <span class="comment">// 顶点数量</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;DirectedEdge&gt; edges;   <span class="comment">// 边列表</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, List&lt;Integer&gt;&gt; outEdges;  <span class="comment">// 每个顶点的出边列表</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, List&lt;Integer&gt;&gt; inEdges;   <span class="comment">// 每个顶点的入边列表</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DirectedGraph</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        <span class="built_in">this</span>.edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.outEdges = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.inEdges = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化顶点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            outEdges.put(i, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            inEdges.put(i, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加有向边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> destination)</span> &#123;</span><br><span class="line">        <span class="comment">// 确保顶点有效</span></span><br><span class="line">        <span class="keyword">if</span> (source &lt; <span class="number">0</span> || source &gt;= V || destination &lt; <span class="number">0</span> || destination &gt;= V) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;顶点索引无效&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加到边列表</span></span><br><span class="line">        edges.add(<span class="keyword">new</span> <span class="title class_">DirectedEdge</span>(source, destination));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新出边和入边列表</span></span><br><span class="line">        outEdges.get(source).add(destination);</span><br><span class="line">        inEdges.get(destination).add(source);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取图中的顶点数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVertexCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取图中的边数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getEdgeCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> edges.size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取顶点的出度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOutDegree</span><span class="params">(<span class="type">int</span> vertex)</span> &#123;</span><br><span class="line">        validateVertex(vertex);</span><br><span class="line">        <span class="keyword">return</span> outEdges.get(vertex).size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取顶点的入度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getInDegree</span><span class="params">(<span class="type">int</span> vertex)</span> &#123;</span><br><span class="line">        validateVertex(vertex);</span><br><span class="line">        <span class="keyword">return</span> inEdges.get(vertex).size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取从指定顶点出发的所有边</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getOutEdges</span><span class="params">(<span class="type">int</span> vertex)</span> &#123;</span><br><span class="line">        validateVertex(vertex);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(outEdges.get(vertex));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取指向指定顶点的所有边</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getInEdges</span><span class="params">(<span class="type">int</span> vertex)</span> &#123;</span><br><span class="line">        validateVertex(vertex);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(inEdges.get(vertex));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断从顶点u到顶点v是否存在有向边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        validateVertex(u);</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        <span class="keyword">return</span> outEdges.get(u).contains(v);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查顶点是否有效</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">validateVertex</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= V) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;顶点 &quot;</span> + v + <span class="string">&quot; 不在有效范围内&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印图的所有边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEdges</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;图中的所有有向边：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (DirectedEdge edge : edges) &#123;</span><br><span class="line">            System.out.println(edge);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用DFS判断从顶点source到顶点target是否可达</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isReachable</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        validateVertex(source);</span><br><span class="line">        validateVertex(target);</span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[V];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        stack.push(source);</span><br><span class="line">        visited[source] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (current == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> neighbor : outEdges.get(current)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">                    visited[neighbor] = <span class="literal">true</span>;</span><br><span class="line">                    stack.push(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<h4 id="优缺点-18"><a href="#优缺点-18" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>能够表示单向关系，更贴近许多现实问题的本质</li>
<li>可以精确描述方向性约束的系统和流程</li>
<li>支持入度和出度的概念，更好地分析节点的影响力和依赖性</li>
<li>能够处理复杂的有向路径问题，如最短路径、拓扑排序等</li>
</ul>
<h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>比无向图实现更复杂，需要额外维护入边和出边信息</li>
<li>在某些操作（如判断连通性）上需要更复杂的算法</li>
<li>对于双向关系的场景，需要维护两条边，增加了存储和维护成本</li>
<li>有向环的检测和处理比无向图更复杂</li>
</ul>
<h4 id="应用场景-19"><a href="#应用场景-19" class="headerlink" title="应用场景"></a>应用场景</h4><p>有向图在现实中有着广泛的应用，它能够准确地表示具有方向性的关系。</p>
<p>比如在网络流量分析中，数据包的传输方向是单向的，通过有向图可以更精确地表示和分析网络拓扑。在社交网络中，”关注”关系通常是单向的，例如A关注B并不意味着B也关注A，这种关系很自然地用有向图表示。</p>
<p>软件工程领域的依赖关系管理也是有向图的典型应用。模块A依赖模块B，但B可能不依赖A，这种依赖关系可以通过有向图进行建模和分析，帮助开发人员理解代码结构并识别潜在的循环依赖问题。</p>
<p>在任务调度系统中，任务之间的前后顺序关系形成了一个有向无环图(DAG)，通过对这个图进行拓扑排序，可以得到一个合理的任务执行顺序。GPS导航系统中的道路网络也常用有向图表示，因为许多道路是单行道，只能按一个方向行驶。</p>
<p>在状态机设计、工作流引擎、资源分配算法等领域有向图都发挥着不可替代的作用。</p>
<h4 id="扩展-3"><a href="#扩展-3" class="headerlink" title="扩展"></a>扩展</h4><h5 id="有向无环图-DAG"><a href="#有向无环图-DAG" class="headerlink" title="有向无环图(DAG)"></a>有向无环图(DAG)</h5><p>有向无环图(Directed Acyclic Graph, DAG)是一种没有环的有向图。DAG具有许多特殊性质，在计算机科学中有广泛应用：</p>
<ul>
<li>拓扑排序：DAG可以进行拓扑排序，即将所有顶点排列成一个线性序列，使得图中任何一条边的起点在序列中都出现在终点之前</li>
<li>依赖关系：可以用来表示各种依赖关系，如软件包依赖、任务调度等</li>
<li>动态规划：许多动态规划问题可以被表示为DAG上的最长/最短路径问题</li>
</ul>
<p>DAG的Java实现可以扩展基本的有向图实现，添加环检测和拓扑排序功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有向无环图(DAG)的实现扩展</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectedAcyclicGraph</span> <span class="keyword">extends</span> <span class="title class_">DirectedGraph</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DirectedAcyclicGraph</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(V);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重写添加边的方法，确保不会形成环</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> destination)</span> &#123;</span><br><span class="line">        <span class="comment">// 检查添加此边是否会形成环</span></span><br><span class="line">        <span class="keyword">if</span> (isReachable(destination, source)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;添加此边将形成环，DAG不允许有环&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">super</span>.addEdge(source, destination);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拓扑排序 - Kahn算法</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">topologicalSort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">V</span> <span class="operator">=</span> getVertexCount();</span><br><span class="line">        <span class="type">int</span>[] inDegree = <span class="keyword">new</span> <span class="title class_">int</span>[V];</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算每个顶点的入度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            inDegree[v] = getInDegree(v);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个队列，将所有入度为0的顶点加入队列</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理队列中的顶点</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 从队列中取出一个顶点并添加到结果中</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            result.add(u);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 对于从u出发的每条边(u,v)，将v的入度减1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v : getOutEdges(u)) &#123;</span><br><span class="line">                <span class="comment">// 将v的入度减1</span></span><br><span class="line">                inDegree[v]--;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果v的入度变为0，则将其加入队列</span></span><br><span class="line">                <span class="keyword">if</span> (inDegree[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.add(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果结果中的顶点数小于图中的顶点数，说明图中有环</span></span><br><span class="line">        <span class="keyword">if</span> (result.size() != V) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;图中存在环，无法进行拓扑排序&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h5><p>在有向图中，强连通分量(Strongly Connected Component, SCC)是指图中的一个子图，其中任意两个顶点之间都存在相互可达的路径。强连通分量是理解有向图结构的重要概念，也是许多图算法的基础。</p>
<p>Kosaraju算法和Tarjan算法是寻找有向图中强连通分量的经典算法。这些算法可以在线性时间内找出所有强连通分量，为有向图分析提供了强大工具。</p>
<h4 id="测验-19"><a href="#测验-19" class="headerlink" title="测验"></a>测验</h4><ol>
<li>在一个有向图中，如果顶点A的出度为3，入度为2，这意味着什么？</li>
<li>一个有5个顶点的有向图最多可以有多少条边？这种情况下图的特点是什么？</li>
<li>什么是有向图中的”汇点”(sink)和”源点”(source)？它们各自具有什么特征？</li>
<li>拓扑排序只能应用于什么类型的有向图？为什么？</li>
</ol>
<blockquote>
<p>测验答案</p>
<ol>
<li>A可以直接到达3个其他顶点，有2个顶点可以直接到达A。</li>
<li>一个有n个顶点的有向图最多可以有n(n-1)条边，对于5个顶点就是5×4=20条边。这种情况下，图中任意两个不同顶点之间都有一条有向边，称为完全有向图。</li>
<li>源点(source)是指入度为0的顶点，即没有边指向该顶点；汇点(sink)是指出度为0的顶点，即没有从该顶点出发的边。它们分别代表了信息流的起点和终点。</li>
<li>拓扑排序只能应用于有向无环图(DAG)。因为如果图中存在环，那么环上的顶点之间存在循环依赖关系，无法确定它们的先后顺序，因此无法得到一个有效的拓扑序列。</li>
</ol>
</blockquote>
<h3 id="三、无向图"><a href="#三、无向图" class="headerlink" title="三、无向图"></a>三、无向图</h3><p>无向图是一种边没有方向的图结构，图中的边表示两个顶点之间的双向连接。无向图广泛应用于社交网络、地图导航、电路设计等场景。</p>
<h5 id="算法讲解-21"><a href="#算法讲解-21" class="headerlink" title="算法讲解"></a>算法讲解</h5><h4 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h4><h5 id="介绍-20"><a href="#介绍-20" class="headerlink" title="介绍"></a>介绍</h5><p>无向图(Undirected Graph)是图论中最基础的图结构之一，其中的边没有方向性，表示节点之间的双向连接关系。在无向图中，如果顶点A和顶点B之间有一条边，那么可以从A到达B，也可以从B到达A。这种对称的连接关系使无向图成为表示许多现实世界中双向关系的理想模型。</p>
<p>无向图中的关键概念包括：</p>
<ul>
<li>顶点(Vertex)：图中的节点，通常用数字或字母标识。</li>
<li>边(Edge)：连接两个顶点的线段，表示它们之间存在某种关系。在无向图中，边用无序对{u,v}表示，表明顶点u和v之间有连接。</li>
<li>度(Degree)：与某个顶点相连的边的数量。例如，如果顶点v连接了3条边，则顶点v的度为3。</li>
<li>路径(Path)：从一个顶点到另一个顶点经过的边的序列。</li>
<li>连通图(Connected Graph)：任意两个顶点之间都存在路径的图。</li>
<li>连通分量(Connected Component)：图中的极大连通子图。</li>
</ul>
<h4 id="核心特性-20"><a href="#核心特性-20" class="headerlink" title="核心特性"></a>核心特性</h4><ul>
<li>双向连接：任何边都可以双向通行，从一个顶点可以到达相邻的任何顶点</li>
<li>对称性：如果顶点A与顶点B相连，那么顶点B也与顶点A相连</li>
<li>度的概念：顶点的度表示与该顶点相连的边的数量</li>
<li>连通性：无向图的连通性比有向图更为简单，只需考虑是否存在路径，不需要考虑方向</li>
<li>树与环：无环的连通无向图是一棵树；含有环的图至少有一条路径可以从一个顶点出发最终回到该顶点</li>
</ul>
<h4 id="基本操作-19"><a href="#基本操作-19" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li>添加顶点：向图中添加新的顶点</li>
<li>添加边：在两个顶点之间添加一条无向边</li>
<li>删除顶点：从图中删除顶点及其相关的所有边</li>
<li>删除边：移除连接两个顶点的边</li>
<li>判断连通性：判断两个顶点之间是否存在路径</li>
<li>查找相邻顶点：获取与指定顶点相邻的所有顶点</li>
<li>图的遍历：通过深度优先搜索(DFS)或广度优先搜索(BFS)遍历图中的所有顶点</li>
</ul>
<blockquote>
<p>出于篇幅考虑，Java之外的语言实现删掉了遍历方法，需要的小伙伴可以参考Java实现自行补充。</p>
</blockquote>
<h4 id="代码实现-18"><a href="#代码实现-18" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无向图的边表示</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UndirectedEdge</span> &#123;</span><br><span class="line">    <span class="type">int</span> vertex1;  <span class="comment">// 边的一个顶点</span></span><br><span class="line">    <span class="type">int</span> vertex2;  <span class="comment">// 边的另一个顶点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UndirectedEdge</span><span class="params">(<span class="type">int</span> vertex1, <span class="type">int</span> vertex2)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vertex1 = vertex1;</span><br><span class="line">        <span class="built_in">this</span>.vertex2 = vertex2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertex1 + <span class="string">&quot; -- &quot;</span> + vertex2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带权重的无向边</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeightedUndirectedEdge</span> &#123;</span><br><span class="line">    <span class="type">int</span> vertex1;  <span class="comment">// 边的一个顶点</span></span><br><span class="line">    <span class="type">int</span> vertex2;  <span class="comment">// 边的另一个顶点</span></span><br><span class="line">    <span class="type">int</span> weight;   <span class="comment">// 边的权重</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeightedUndirectedEdge</span><span class="params">(<span class="type">int</span> vertex1, <span class="type">int</span> vertex2, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vertex1 = vertex1;</span><br><span class="line">        <span class="built_in">this</span>.vertex2 = vertex2;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertex1 + <span class="string">&quot; -- &quot;</span> + vertex2 + <span class="string">&quot; (&quot;</span> + weight + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用边列表实现的无向图</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UndirectedGraph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;                      <span class="comment">// 顶点数量</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;UndirectedEdge&gt; edges; <span class="comment">// 边列表</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, List&lt;Integer&gt;&gt; adjacencyList; <span class="comment">// 邻接表</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UndirectedGraph</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        <span class="built_in">this</span>.edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.adjacencyList = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化顶点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            adjacencyList.put(i, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加无向边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> vertex1, <span class="type">int</span> vertex2)</span> &#123;</span><br><span class="line">        <span class="comment">// 确保顶点有效</span></span><br><span class="line">        <span class="keyword">if</span> (vertex1 &lt; <span class="number">0</span> || vertex1 &gt;= V || vertex2 &lt; <span class="number">0</span> || vertex2 &gt;= V) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;顶点索引无效&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加到边列表</span></span><br><span class="line">        edges.add(<span class="keyword">new</span> <span class="title class_">UndirectedEdge</span>(vertex1, vertex2));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新邻接表（无向图需要双向添加）</span></span><br><span class="line">        adjacencyList.get(vertex1).add(vertex2);</span><br><span class="line">        adjacencyList.get(vertex2).add(vertex1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取图中的顶点数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVertexCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取图中的边数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getEdgeCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> edges.size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取顶点的度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDegree</span><span class="params">(<span class="type">int</span> vertex)</span> &#123;</span><br><span class="line">        validateVertex(vertex);</span><br><span class="line">        <span class="keyword">return</span> adjacencyList.get(vertex).size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取与指定顶点相邻的所有顶点</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getNeighbors</span><span class="params">(<span class="type">int</span> vertex)</span> &#123;</span><br><span class="line">        validateVertex(vertex);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(adjacencyList.get(vertex));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断两个顶点之间是否存在边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasEdge</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123;</span><br><span class="line">        validateVertex(v1);</span><br><span class="line">        validateVertex(v2);</span><br><span class="line">        <span class="keyword">return</span> adjacencyList.get(v1).contains(v2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查顶点是否有效</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">validateVertex</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= V) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;顶点 &quot;</span> + v + <span class="string">&quot; 不在有效范围内&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印图的所有边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEdges</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;图中的所有无向边：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (UndirectedEdge edge : edges) &#123;</span><br><span class="line">            System.out.println(edge);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用BFS判断两个顶点之间是否存在路径（检查连通性）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        validateVertex(start);</span><br><span class="line">        validateVertex(end);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (start == end) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[V];</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        visited[start] = <span class="literal">true</span>;</span><br><span class="line">        queue.offer(start);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> neighbor : adjacencyList.get(current)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (neighbor == end) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">                    visited[neighbor] = <span class="literal">true</span>;</span><br><span class="line">                    queue.offer(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用DFS遍历图（从指定顶点开始）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> start)</span> &#123;</span><br><span class="line">        validateVertex(start);</span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[V];</span><br><span class="line">        System.out.print(<span class="string">&quot;DFS遍历（从顶点&quot;</span> + start + <span class="string">&quot;开始）：&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        dfsUtil(start, visited);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfsUtil</span><span class="params">(<span class="type">int</span> vertex, <span class="type">boolean</span>[] visited)</span> &#123;</span><br><span class="line">        <span class="comment">// 标记当前顶点为已访问并打印</span></span><br><span class="line">        visited[vertex] = <span class="literal">true</span>;</span><br><span class="line">        System.out.print(vertex + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归处理所有未访问的邻居</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor : adjacencyList.get(vertex)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">                dfsUtil(neighbor, visited);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用BFS遍历图（从指定顶点开始）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> start)</span> &#123;</span><br><span class="line">        validateVertex(start);</span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[V];</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        visited[start] = <span class="literal">true</span>;</span><br><span class="line">        queue.offer(start);</span><br><span class="line">        </span><br><span class="line">        System.out.print(<span class="string">&quot;BFS遍历（从顶点&quot;</span> + start + <span class="string">&quot;开始）：&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            System.out.print(current + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> neighbor : adjacencyList.get(current)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">                    visited[neighbor] = <span class="literal">true</span>;</span><br><span class="line">                    queue.offer(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算图中的连通分量数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countConnectedComponents</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[V];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v]) &#123;</span><br><span class="line">                <span class="comment">// 对未访问的顶点执行DFS</span></span><br><span class="line">                dfsForComponents(v, visited);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfsForComponents</span><span class="params">(<span class="type">int</span> vertex, <span class="type">boolean</span>[] visited)</span> &#123;</span><br><span class="line">        visited[vertex] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor : adjacencyList.get(vertex)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">                dfsForComponents(neighbor, visited);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<h4 id="优缺点-19"><a href="#优缺点-19" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>表示双向关系的直观模型，容易理解和使用</li>
<li>实现相对简单，不需要考虑方向性</li>
<li>许多图算法在无向图上的实现更为简洁</li>
<li>连通性判断更加直观，不需要考虑方向限制</li>
<li>适合表示”对等”关系，如社交网络中的”朋友”关系</li>
</ul>
<h5 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>无法表示单向或不对称的关系</li>
<li>在某些需要方向性的应用场景下表达能力有限</li>
<li>对于需要区分入度和出度的应用场景不适用</li>
<li>不能直接表示有向流网络中的流量问题</li>
</ul>
<h4 id="应用场景-20"><a href="#应用场景-20" class="headerlink" title="应用场景"></a>应用场景</h4><p>无向图特别适合表示双向或对等的关系：</p>
<p>社交网络中的”朋友”关系常用无向图建模，因为朋友关系通常是双向的。如果A是B的朋友，那么B也是A的朋友。</p>
<p>道路网络中，如果没有单行道限制，车辆可以在同一条道路上双向通行，这种情况下使用无向图建模更为自然。同样，电信网络中的通信链路、电力网络中的电力线路等，如果允许双向传输，也适合用无向图表示。</p>
<p>计算机网络拓扑中，如果两台设备之间可以互相通信，则它们之间的连接可以用无向边表示。互联网骨干网络的结构通常被建模为无向图，以便分析路由和连通性问题。</p>
<p>分子结构和化学键也常用无向图表示，其中原子是顶点，化学键是边。这种表示方法帮助化学家分析分子的结构特性和性质。</p>
<h4 id="扩展-4"><a href="#扩展-4" class="headerlink" title="扩展"></a>扩展</h4><h5 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h5><p>最小生成树(Minimum Spanning Tree, MST)是无向图中的一个重要概念，指连接图中所有顶点的一棵权重最小的树。对于带权无向图，最小生成树有着重要的应用价值：</p>
<ul>
<li>网络设计：设计成本最低的通信网络</li>
<li>电路设计：最小化电路中的连线长度</li>
<li>集群分析：在数据挖掘中用于对象分组</li>
</ul>
<p>求解最小生成树的两个经典算法是Kruskal算法和Prim算法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kruskal算法实现最小生成树</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KruskalMST</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;WeightedUndirectedEdge&gt; mst = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 最小生成树的边</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 最小生成树的总权重</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">KruskalMST</span><span class="params">(UndirectedWeightedGraph G)</span> &#123;</span><br><span class="line">        <span class="comment">// 边列表</span></span><br><span class="line">        List&lt;WeightedUndirectedEdge&gt; edges = G.getAllEdges();</span><br><span class="line">        <span class="type">int</span> <span class="variable">V</span> <span class="operator">=</span> G.getVertexCount();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 按权重排序</span></span><br><span class="line">        Collections.sort(edges, Comparator.comparingInt(e -&gt; e.weight));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 并查集，用于检测环</span></span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(V);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 贪心选择边</span></span><br><span class="line">        <span class="keyword">for</span> (WeightedUndirectedEdge edge : edges) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> edge.vertex1;</span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> edge.vertex2;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果添加此边不会形成环</span></span><br><span class="line">            <span class="keyword">if</span> (uf.find(v) != uf.find(w)) &#123;</span><br><span class="line">                uf.union(v, w); <span class="comment">// 合并集合</span></span><br><span class="line">                mst.add(edge);  <span class="comment">// 添加到最小生成树</span></span><br><span class="line">                weight += edge.weight; <span class="comment">// 更新总权重</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果已经有V-1条边，MST构建完成</span></span><br><span class="line">                <span class="keyword">if</span> (mst.size() == V - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取最小生成树的边</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;WeightedUndirectedEdge&gt; <span class="title function_">edges</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mst;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取最小生成树的总权重</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">weight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 并查集实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span>[] rank;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            rank = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查找</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">                parent[x] = find(parent[x]); <span class="comment">// 路径压缩</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 合并</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootX</span> <span class="operator">=</span> find(x);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootY</span> <span class="operator">=</span> find(y);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (rootX == rootY) <span class="keyword">return</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 按秩合并</span></span><br><span class="line">            <span class="keyword">if</span> (rank[rootX] &lt; rank[rootY]) &#123;</span><br><span class="line">                parent[rootX] = rootY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootX] &gt; rank[rootY]) &#123;</span><br><span class="line">                parent[rootY] = rootX;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent[rootY] = rootX;</span><br><span class="line">                rank[rootX]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="无向图的连通分量"><a href="#无向图的连通分量" class="headerlink" title="无向图的连通分量"></a>无向图的连通分量</h5><p>在无向图中，连通分量(Connected Component)是指图中的一个极大连通子图，其中任意两个顶点之间都存在路径。寻找图中的连通分量对于分析网络结构和数据聚类有重要意义。</p>
<h4 id="测验-20"><a href="#测验-20" class="headerlink" title="测验"></a>测验</h4><ol>
<li>在一个拥有10个顶点的无向图中，最多可以有多少条边？这样的图被称为什么？</li>
<li>如果一个无向图有n个顶点和m条边，要使该图连通，m至少需要是多少？这种情况下图的结构是什么？</li>
<li>什么是无向图的桥(Bridge)？移除桥会对图的连通性产生什么影响？</li>
<li>与有向图相比，无向图表示的边列表长度有什么特点？为什么？</li>
</ol>
<blockquote>
<p>测验答案</p>
<ol>
<li>最多可以有10×(10-1)/2 = 45条边。这样的图被称为完全图(Complete Graph)，其中任意两个顶点之间都有一条边连接。</li>
<li>至少需要n-1条边。这种情况下，图的结构是一棵树(Tree)，即恰好连通且没有环的无向图。</li>
<li>桥是指图中的一条边，如果删除这条边，会导致图中的连通分量数量增加。换句话说，桥是连接图中两个连通分量的唯一边，移除桥会导致这两个部分不再连通。</li>
<li>如果用边列表表示，无向图的边列表长度与有向图表示相同连接关系时的边列表长度相比，通常会更短。这是因为在有向图中，两个顶点之间的双向连接需要用两条有向边表示，而在无向图中只需要一条无向边。</li>
</ol>
</blockquote>
<h3 id="四、加权图"><a href="#四、加权图" class="headerlink" title="四、加权图"></a>四、加权图</h3><p>加权图是每条边都有一个与之关联的数值（权重）的图结构。权重可以表示距离、成本、容量等概念，广泛应用于路径规划、网络流量分析等场景。算法讲解</p>
<h4 id="加权图"><a href="#加权图" class="headerlink" title="加权图"></a>加权图</h4><h5 id="介绍-21"><a href="#介绍-21" class="headerlink" title="介绍"></a>介绍</h5><p>加权图(Weighted Graph)是图论中的一种重要图类型，特点是每条边都有一个与之关联的数值，称为权重(Weight)或成本(Cost)。这些权重可以表示各种现实世界中的量化关系，如距离、时间、费用、容量等。加权图广泛应用于网络分析、路径规划、资源分配等领域，是解决许多优化问题的基础数据结构。</p>
<p>加权图中的关键概念包括：</p>
<ul>
<li>顶点(Vertex)：图中的节点，通常用数字或字母标识。</li>
<li>带权边(Weighted Edge)：连接两个顶点的边，附带一个表示某种度量的权重值。例如在表示交通网络的图中，边的权重可能代表路径长度或通行时间。</li>
<li>权重(Weight)：分配给边的数值，根据应用场景可以是正数、负数或零。</li>
<li>路径权重(Path Weight)：路径上所有边的权重总和，也称为路径长度或路径成本。</li>
<li>最短路径(Shortest Path)：两个顶点之间权重总和最小的路径。</li>
<li>最小生成树(Minimum Spanning Tree)：连接图中所有顶点且总权重最小的子图。</li>
</ul>
<h4 id="核心特性-21"><a href="#核心特性-21" class="headerlink" title="核心特性"></a>核心特性</h4><ul>
<li>边权重：每条边都有一个关联的数值，表示某种度量或成本</li>
<li>路径评估：可以根据边的权重计算路径的总成本或效率</li>
<li>最优路径选择：支持寻找最短路径、最小生成树等优化问题</li>
<li>类型多样性：可以是有向的或无向的，根据关系的性质决定</li>
<li>权重特性：权重可以是正数、负数或零，表示不同的约束条件</li>
<li>算法基础：是Dijkstra算法、Bellman-Ford算法、Kruskal算法、Prim算法等经典算法的应用对象</li>
</ul>
<h4 id="基本操作-20"><a href="#基本操作-20" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li>添加带权边：在两个顶点之间添加一条带有特定权重的边</li>
<li>获取边权重：查询连接两个顶点的边的权重</li>
<li>查找相邻顶点及其权重：获取与指定顶点相邻的所有顶点及对应的边权重</li>
<li>更新边权重：修改已存在边的权重值</li>
<li>计算路径总权重：累加路径上所有边的权重</li>
<li>最短路径查找：找到两点间权重和最小的路径</li>
<li>最小生成树构建：构建连接所有顶点的最小权重子图</li>
</ul>
<h4 id="代码实现-19"><a href="#代码实现-19" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带权边表示</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeightedEdge</span> &#123;</span><br><span class="line">    <span class="type">int</span> source;      <span class="comment">// 边的起点</span></span><br><span class="line">    <span class="type">int</span> destination; <span class="comment">// 边的终点</span></span><br><span class="line">    <span class="type">double</span> weight;   <span class="comment">// 边的权重</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeightedEdge</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> destination, <span class="type">double</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.source = source;</span><br><span class="line">        <span class="built_in">this</span>.destination = destination;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> source + <span class="string">&quot; -&gt; &quot;</span> + destination + <span class="string">&quot; (&quot;</span> + weight + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用邻接表实现的加权图</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeightedGraph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;                                  <span class="comment">// 顶点数量</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;WeightedEdge&gt; edges;               <span class="comment">// 边列表</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, List&lt;WeightedEdge&gt;&gt; adj;   <span class="comment">// 邻接表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> directed;                       <span class="comment">// 是否为有向图</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeightedGraph</span><span class="params">(<span class="type">int</span> V, <span class="type">boolean</span> directed)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        <span class="built_in">this</span>.directed = directed;</span><br><span class="line">        <span class="built_in">this</span>.edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.adj = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化顶点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            adj.put(i, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加带权边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> destination, <span class="type">double</span> weight)</span> &#123;</span><br><span class="line">        <span class="comment">// 确保顶点有效</span></span><br><span class="line">        <span class="keyword">if</span> (source &lt; <span class="number">0</span> || source &gt;= V || destination &lt; <span class="number">0</span> || destination &gt;= V) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;顶点索引无效&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">WeightedEdge</span> <span class="variable">edge</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeightedEdge</span>(source, destination, weight);</span><br><span class="line">        edges.add(edge);</span><br><span class="line">        adj.get(source).add(edge);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果是无向图，还需要添加反方向的边</span></span><br><span class="line">        <span class="keyword">if</span> (!directed) &#123;</span><br><span class="line">            <span class="type">WeightedEdge</span> <span class="variable">reverseEdge</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeightedEdge</span>(destination, source, weight);</span><br><span class="line">            adj.get(destination).add(reverseEdge);</span><br><span class="line">            <span class="comment">// 注意：不需要将反向边添加到边列表中，否则会重复计数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取图中的顶点数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVertexCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取图中的边数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getEdgeCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> edges.size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取从指定顶点出发的所有边</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;WeightedEdge&gt; <span class="title function_">getEdges</span><span class="params">(<span class="type">int</span> vertex)</span> &#123;</span><br><span class="line">        validateVertex(vertex);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(adj.get(vertex));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取图中的所有边</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;WeightedEdge&gt; <span class="title function_">getAllEdges</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(edges);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取两个顶点之间边的权重，如果不存在则返回Double.POSITIVE_INFINITY</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> destination)</span> &#123;</span><br><span class="line">        validateVertex(source);</span><br><span class="line">        validateVertex(destination);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (WeightedEdge edge : adj.get(source)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge.destination == destination) &#123;</span><br><span class="line">                <span class="keyword">return</span> edge.weight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Double.POSITIVE_INFINITY;  <span class="comment">// 表示不存在这条边</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断从顶点source到顶点destination是否存在边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasEdge</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> destination)</span> &#123;</span><br><span class="line">        validateVertex(source);</span><br><span class="line">        validateVertex(destination);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (WeightedEdge edge : adj.get(source)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge.destination == destination) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新边的权重，如果边不存在则返回false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateEdgeWeight</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> destination, <span class="type">double</span> newWeight)</span> &#123;</span><br><span class="line">        validateVertex(source);</span><br><span class="line">        validateVertex(destination);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新邻接表中的权重</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (WeightedEdge edge : adj.get(source)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge.destination == destination) &#123;</span><br><span class="line">                edge.weight = newWeight;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果是无向图，还需要更新反方向的边</span></span><br><span class="line">        <span class="keyword">if</span> (!directed) &#123;</span><br><span class="line">            <span class="keyword">for</span> (WeightedEdge edge : adj.get(destination)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (edge.destination == source) &#123;</span><br><span class="line">                    edge.weight = newWeight;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新边列表中的权重</span></span><br><span class="line">        <span class="keyword">for</span> (WeightedEdge edge : edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge.source == source &amp;&amp; edge.destination == destination) &#123;</span><br><span class="line">                edge.weight = newWeight;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查顶点是否有效</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">validateVertex</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= V) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;顶点 &quot;</span> + v + <span class="string">&quot; 不在有效范围内&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印图的所有边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEdges</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;图中的所有&quot;</span> + (directed ? <span class="string">&quot;有向&quot;</span> : <span class="string">&quot;无向&quot;</span>) + <span class="string">&quot;边：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (WeightedEdge edge : edges) &#123;</span><br><span class="line">            System.out.println(edge);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<h4 id="优缺点-20"><a href="#优缺点-20" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>能够模拟和解决现实世界中的加权关系问题</li>
<li>支持寻找最优路径，如最短路径、最小生成树等</li>
<li>可以表示复杂的网络结构和优化约束</li>
<li>适合解决资源分配、网络流等优化问题</li>
<li>为多种经典算法提供了应用场景</li>
</ul>
<h5 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>比无权图实现更复杂，需要额外存储和管理权重信息</li>
<li>算法时间复杂度通常较高，特别是在大规模图上</li>
<li>负权重循环可能导致某些算法（如Dijkstra）失效</li>
<li>实际应用中可能需要处理权重的动态变化</li>
<li>对于某些特殊情况（如含负权重环的图），问题可能无解或难以求解</li>
</ul>
<h4 id="应用场景-21"><a href="#应用场景-21" class="headerlink" title="应用场景"></a>应用场景</h4><p>道路网络可以表示为加权图，其中边的权重可以是距离、预计行驶时间或燃油消耗等因素。通过Dijkstra或A*算法，系统可以为用户找到最短或最快的路线。</p>
<p>在电信网络中，连接不同节点的线路有不同的容量和成本，通过加权图建模可以设计出高效且经济的网络布局。最小生成树算法如Kruskal和Prim可以用来确定最经济的连接方式。</p>
<p>资源调度和分配问题，如作业调度、网络流量管理等，也经常使用加权图建模。通过最大流或最小成本流算法，可以解决复杂的资源分配优化问题。</p>
<h4 id="扩展-5"><a href="#扩展-5" class="headerlink" title="扩展"></a>扩展</h4><p>在上述基础实现的基础上，可以补充 最短路径查找 和 最小生成树构建 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Dijkstra算法计算从源点到所有其他顶点的最短路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span>[] dijkstra(<span class="type">int</span> source) &#123;</span><br><span class="line">    validateVertex(source);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 距离数组，存储源点到每个顶点的最短距离</span></span><br><span class="line">    <span class="type">double</span>[] dist = <span class="keyword">new</span> <span class="title class_">double</span>[V];</span><br><span class="line">    Arrays.fill(dist, Double.POSITIVE_INFINITY);</span><br><span class="line">    dist[source] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 标记数组，标记顶点是否已经处理</span></span><br><span class="line">    <span class="type">boolean</span>[] processed = <span class="keyword">new</span> <span class="title class_">boolean</span>[V];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用优先队列选择当前最短距离的顶点</span></span><br><span class="line">    PriorityQueue&lt;Node&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparingDouble(node -&gt; node.distance));</span><br><span class="line">    pq.add(<span class="keyword">new</span> <span class="title class_">Node</span>(source, <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 取出距离最小的顶点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> current.vertex;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果这个顶点已经处理过，则跳过</span></span><br><span class="line">        <span class="keyword">if</span> (processed[u]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 标记为已处理</span></span><br><span class="line">        processed[u] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新所有相邻顶点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (WeightedEdge edge : adj.get(u)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> edge.destination;</span><br><span class="line">            <span class="type">double</span> <span class="variable">weight</span> <span class="operator">=</span> edge.weight;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果找到更短的路径，更新距离并添加到优先队列</span></span><br><span class="line">            <span class="keyword">if</span> (!processed[v] &amp;&amp; dist[u] + weight &lt; dist[v]) &#123;</span><br><span class="line">                dist[v] = dist[u] + weight;</span><br><span class="line">                pq.add(<span class="keyword">new</span> <span class="title class_">Node</span>(v, dist[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于Dijkstra算法的辅助类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> vertex;</span><br><span class="line">    <span class="type">double</span> distance;</span><br><span class="line">    </span><br><span class="line">    Node(<span class="type">int</span> vertex, <span class="type">double</span> distance) &#123;</span><br><span class="line">        <span class="built_in">this</span>.vertex = vertex;</span><br><span class="line">        <span class="built_in">this</span>.distance = distance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Kruskal算法计算最小生成树（仅适用于无向图）</span></span><br><span class="line"><span class="keyword">public</span> List&lt;WeightedEdge&gt; <span class="title function_">kruskalMST</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (directed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;Kruskal算法只适用于无向图&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最小生成树的边</span></span><br><span class="line">    List&lt;WeightedEdge&gt; mst = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按权重排序所有边</span></span><br><span class="line">    List&lt;WeightedEdge&gt; sortedEdges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(edges);</span><br><span class="line">    sortedEdges.sort(Comparator.comparingDouble(e -&gt; e.weight));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 并查集用于检测环</span></span><br><span class="line">    <span class="type">DisjointSet</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DisjointSet</span>(V);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理每条边</span></span><br><span class="line">    <span class="keyword">for</span> (WeightedEdge edge : sortedEdges) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> edge.source;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> edge.destination;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果这条边不会形成环，则添加到MST</span></span><br><span class="line">        <span class="keyword">if</span> (ds.find(u) != ds.find(v)) &#123;</span><br><span class="line">            mst.add(edge);</span><br><span class="line">            ds.union(u, v);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果MST已经有V-1条边，则完成</span></span><br><span class="line">            <span class="keyword">if</span> (mst.size() == V - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> mst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集实现，用于Kruskal算法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DisjointSet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] rank;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DisjointSet</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化：每个元素是自己的父节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找元素所属的集合（带路径压缩）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">            parent[x] = find(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 合并两个集合（按秩合并）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootX</span> <span class="operator">=</span> find(x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootY</span> <span class="operator">=</span> find(y);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (rootX == rootY) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (rank[rootX] &lt; rank[rootY]) &#123;</span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootX] &gt; rank[rootY]) &#123;</span><br><span class="line">            parent[rootY] = rootX;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rootY] = rootX;</span><br><span class="line">            rank[rootX]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h5><p>最短路径问题是加权图中最经典的问题之一，指在加权图中找到从一个顶点到另一个顶点的总权重最小的路径。主要的算法包括：</p>
<ol>
<li>Dijkstra算法：适用于所有边权重为非负数的图，是求解单源最短路径的高效算法</li>
<li>Bellman-Ford算法：可以处理含有负权边的图，但不能处理负权环</li>
<li>Floyd-Warshall算法：计算图中所有顶点对之间的最短路径</li>
</ol>
<h5 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h5><p>最小生成树(MST)是连接加权无向图中所有顶点且总权重最小的子图。常用的算法有：</p>
<ol>
<li>Kruskal算法：按权重递增顺序处理边，使用并查集避免环的形成</li>
<li>Prim算法：从一个顶点开始，逐步添加连接当前树与未访问顶点的最小权重边</li>
</ol>
<h4 id="测验-21"><a href="#测验-21" class="headerlink" title="测验"></a>测验</h4><ol>
<li>在一个加权图中，最短路径是指什么？它与最小生成树有什么区别？</li>
<li>Dijkstra算法不适用于哪种类型的加权图？为什么？</li>
<li>在一个有10个顶点的加权无向图中，其最小生成树有多少条边？为什么？</li>
<li>如果一个加权图中存在负权环，会对寻找最短路径产生什么影响？</li>
</ol>
<blockquote>
<p>测验答案</p>
<ol>
<li>最短路径是指从起点到终点的路径中，边权重之和最小的路径。最短路径是两点之间的问题，而最小生成树是连接整个图所有顶点且总权重最小的子图。最短路径关注的是两点间的最优连接，最小生成树关注的是整体网络的最优连接。</li>
<li>Dijkstra算法不适用于含有负权边的加权图。因为Dijkstra算法基于贪心策略，假设一旦处理了某个顶点，就已经找到了到该顶点的最短路径。但负权边可能导致后续发现更短的路径，违背了这一假设。</li>
<li>在有n个顶点的图中，其最小生成树恰好有n-1条边。因此，10个顶点的图的最小生成树有9条边。这是因为最小生成树是一棵树，而树的特性是有n个顶点就有n-1条边。</li>
<li>如果存在负权环，则最短路径问题在理论上没有明确的解，因为可以通过反复经过负权环来无限减小路径的总权重。这种情况下，标准的最短路径算法如Dijkstra会失效，而Bellman-Ford算法可以检测负权环的存在。</li>
</ol>
</blockquote>
<h3 id="五、-有向无环图"><a href="#五、-有向无环图" class="headerlink" title="五、 有向无环图"></a>五、 有向无环图</h3><p>有向无环图(DAG)是一种边有方向且不包含环的图结构，常用于表示任务的依赖关系、工作流程、以及系统中的资源调度等问题。</p>
<h5 id="算法讲解-22"><a href="#算法讲解-22" class="headerlink" title="算法讲解"></a>算法讲解</h5><h4 id="有向无环图"><a href="#有向无环图" class="headerlink" title="有向无环图"></a>有向无环图</h4><h5 id="介绍-22"><a href="#介绍-22" class="headerlink" title="介绍"></a>介绍</h5><p>有向无环图(Directed Acyclic Graph，简称DAG)是一种没有环的有向图。在DAG中，如果从顶点A出发沿着有向边行走，永远不可能回到顶点A，也就是说图中不存在环路。DAG在计算机科学中有着广泛的应用，尤其是在表示依赖关系、任务调度和执行顺序等场景中。</p>
<p>有向无环图中的关键概念包括：</p>
<ul>
<li>顶点(Vertex)：图中的节点，通常用数字或字母标识。</li>
<li>有向边(Directed Edge)：从一个顶点指向另一个顶点的带方向连接，通常表示为有序对(u,v)。</li>
<li>路径(Path)：从一个顶点到另一个顶点经过的边的序列。</li>
<li>拓扑排序(Topological Sort)：将DAG中的所有顶点排列成一个线性序列，使得图中任何一条边(u,v)对应的顶点u在序列中都出现在v之前。</li>
<li>源点(Source)：入度为0的顶点，即没有边指向该顶点。</li>
<li>汇点(Sink)：出度为0的顶点，即没有从该顶点出发的边。</li>
</ul>
<h4 id="核心特性-22"><a href="#核心特性-22" class="headerlink" title="核心特性"></a>核心特性</h4><ul>
<li>无环性：DAG中不存在环路，从任意顶点出发无法回到该顶点</li>
<li>拓扑排序：总是可以将DAG的顶点排列成一个线性序列，使得所有边都从序列的前面指向后面</li>
<li>依赖表示：非常适合表示依赖关系，如软件包依赖、任务调度的先后顺序</li>
<li>可预测性：由于没有循环依赖，DAG的行为更加可预测</li>
<li>单向流动：信息在DAG中只能沿一个方向流动，没有反馈循环</li>
<li>层次结构：可以组织成层次结构，每一层的节点只依赖于更低层的节点</li>
</ul>
<h4 id="基本操作-21"><a href="#基本操作-21" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li>添加顶点：向图中添加新的顶点</li>
<li>添加有向边：在两个顶点之间添加一条有向边（需要确保不会形成环）</li>
<li>检测环：验证添加新边后是否会形成环</li>
<li>拓扑排序：生成符合依赖关系的顶点排序</li>
<li>查找源点和汇点：找出图中的源点（入度为0）和汇点（出度为0）</li>
<li>计算路径：找出从一个顶点到另一个顶点的路径</li>
<li>查找前驱和后继：获取指定顶点的所有前驱或后继顶点</li>
</ul>
<h4 id="代码实现-20"><a href="#代码实现-20" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有向无环图(DAG)的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectedAcyclicGraph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;                          <span class="comment">// 顶点数量</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, List&lt;Integer&gt;&gt; adj;  <span class="comment">// 邻接表</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, List&lt;Integer&gt;&gt; incoming;  <span class="comment">// 反向邻接表（用于快速查找入边）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个具有指定顶点数的有向无环图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> V 顶点数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DirectedAcyclicGraph</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        adj = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        incoming = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化顶点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            adj.put(i, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            incoming.put(i, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加有向边，在添加前会检查是否会形成环</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source 边的起点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destination 边的终点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否成功添加边</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException 如果顶点索引无效或添加边会形成环</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> destination)</span> &#123;</span><br><span class="line">        <span class="comment">// 确保顶点有效</span></span><br><span class="line">        validateVertex(source);</span><br><span class="line">        validateVertex(destination);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查是否会形成环</span></span><br><span class="line">        <span class="keyword">if</span> (hasPath(destination, source)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;添加此边将形成环，DAG不允许有环&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加边</span></span><br><span class="line">        adj.get(source).add(destination);</span><br><span class="line">        incoming.get(destination).add(source);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断从source到destination是否存在路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source 起点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destination 终点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否存在路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPath</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> destination)</span> &#123;</span><br><span class="line">        validateVertex(source);</span><br><span class="line">        validateVertex(destination);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 特殊情况：起点等于终点</span></span><br><span class="line">        <span class="keyword">if</span> (source == destination) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用BFS检查是否存在路径</span></span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[V];</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        visited[source] = <span class="literal">true</span>;</span><br><span class="line">        queue.offer(source);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> neighbor : adj.get(current)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (neighbor == destination) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">                    visited[neighbor] = <span class="literal">true</span>;</span><br><span class="line">                    queue.offer(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用Kahn算法进行拓扑排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 拓扑排序结果（如果存在环，则返回null）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">topologicalSort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 计算每个顶点的入度</span></span><br><span class="line">        <span class="type">int</span>[] inDegree = <span class="keyword">new</span> <span class="title class_">int</span>[V];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> neighbor : adj.get(v)) &#123;</span><br><span class="line">                inDegree[neighbor]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将所有入度为0的顶点加入队列</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 拓扑排序结果</span></span><br><span class="line">        List&lt;Integer&gt; topologicalOrder = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理队列</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            topologicalOrder.add(current);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 删除所有从current出发的边</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> neighbor : adj.get(current)) &#123;</span><br><span class="line">                <span class="comment">// 减少neighbor的入度</span></span><br><span class="line">                inDegree[neighbor]--;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果入度变为0，则加入队列</span></span><br><span class="line">                <span class="keyword">if</span> (inDegree[neighbor] == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.offer(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果不是所有顶点都加入了拓扑排序，则存在环</span></span><br><span class="line">        <span class="keyword">if</span> (topologicalOrder.size() != V) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// 图中存在环</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> topologicalOrder;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DFS方法的拓扑排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 拓扑排序结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">topologicalSortDFS</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[V];</span><br><span class="line">        LinkedList&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; recursionStack = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对每个未访问的顶点进行DFS</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!topologicalSortDFSUtil(i, visited, recursionStack, result)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// 检测到环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">topologicalSortDFSUtil</span><span class="params">(<span class="type">int</span> v, <span class="type">boolean</span>[] visited, Set&lt;Integer&gt; recursionStack, LinkedList&lt;Integer&gt; result)</span> &#123;</span><br><span class="line">        <span class="comment">// 标记当前节点为已访问</span></span><br><span class="line">        visited[v] = <span class="literal">true</span>;</span><br><span class="line">        recursionStack.add(v);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归处理所有邻接顶点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor : adj.get(v)) &#123;</span><br><span class="line">            <span class="comment">// 如果邻居在递归栈中，则存在环</span></span><br><span class="line">            <span class="keyword">if</span> (recursionStack.contains(neighbor)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果邻居尚未访问，则递归访问</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!topologicalSortDFSUtil(neighbor, visited, recursionStack, result)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将当前顶点添加到结果的前面（这就是拓扑排序的关键）</span></span><br><span class="line">        recursionStack.remove(v);</span><br><span class="line">        result.addFirst(v);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取图中的所有源点（入度为0的顶点）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 源点列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getSources</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; sources = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (incoming.get(v).isEmpty()) &#123;</span><br><span class="line">                sources.add(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sources;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取图中的所有汇点（出度为0的顶点）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 汇点列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getSinks</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; sinks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (adj.get(v).isEmpty()) &#123;</span><br><span class="line">                sinks.add(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sinks;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取顶点的出度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertex 顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 出度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOutDegree</span><span class="params">(<span class="type">int</span> vertex)</span> &#123;</span><br><span class="line">        validateVertex(vertex);</span><br><span class="line">        <span class="keyword">return</span> adj.get(vertex).size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取顶点的入度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertex 顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 入度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getInDegree</span><span class="params">(<span class="type">int</span> vertex)</span> &#123;</span><br><span class="line">        validateVertex(vertex);</span><br><span class="line">        <span class="keyword">return</span> incoming.get(vertex).size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取顶点的所有后继（能够到达的顶点）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertex 顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 后继列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getSuccessors</span><span class="params">(<span class="type">int</span> vertex)</span> &#123;</span><br><span class="line">        validateVertex(vertex);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用BFS找出所有可达顶点</span></span><br><span class="line">        Set&lt;Integer&gt; successors = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[V];</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        queue.offer(vertex);</span><br><span class="line">        visited[vertex] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> neighbor : adj.get(current)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">                    visited[neighbor] = <span class="literal">true</span>;</span><br><span class="line">                    queue.offer(neighbor);</span><br><span class="line">                    successors.add(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(successors);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取顶点的所有前驱（能够到达该顶点的顶点）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertex 顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 前驱列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getPredecessors</span><span class="params">(<span class="type">int</span> vertex)</span> &#123;</span><br><span class="line">        validateVertex(vertex);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用BFS找出所有能到达此顶点的顶点</span></span><br><span class="line">        Set&lt;Integer&gt; predecessors = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[V];</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 反向搜索，从incoming开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : incoming.get(vertex)) &#123;</span><br><span class="line">            queue.offer(v);</span><br><span class="line">            visited[v] = <span class="literal">true</span>;</span><br><span class="line">            predecessors.add(v);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> prev : incoming.get(current)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[prev]) &#123;</span><br><span class="line">                    visited[prev] = <span class="literal">true</span>;</span><br><span class="line">                    queue.offer(prev);</span><br><span class="line">                    predecessors.add(prev);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(predecessors);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查顶点是否有效</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertex 顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException 如果顶点无效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">validateVertex</span><span class="params">(<span class="type">int</span> vertex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (vertex &lt; <span class="number">0</span> || vertex &gt;= V) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;顶点 &quot;</span> + vertex + <span class="string">&quot; 不在有效范围内&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取图中的顶点数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 顶点数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVertexCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印图的结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printGraph</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有向无环图结构：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            System.out.print(v + <span class="string">&quot; -&gt; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (adj.get(v).isEmpty()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;(无出边)&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(adj.get(v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<h4 id="优缺点-21"><a href="#优缺点-21" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点：-4"><a href="#优点：-4" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>能够表示复杂的依赖关系和优先级顺序</li>
<li>通过拓扑排序可以获得满足依赖关系的执行序列</li>
<li>没有环意味着没有循环依赖，更易于分析和理解</li>
<li>适合表示作业调度、程序执行流、数据处理管线等场景</li>
<li>保证了可达性和终止性，不会出现无限循环</li>
</ul>
<h5 id="缺点：-4"><a href="#缺点：-4" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>不能表示需要循环或反馈的关系</li>
<li>添加新边时需要验证是否会形成环，增加了操作复杂度</li>
<li>对于动态变化的依赖关系，可能需要频繁地重建图结构</li>
<li>在某些应用场景中，环路检测的开销可能较大</li>
<li>实现较为复杂，尤其是需要高效的环检测算法</li>
</ul>
<h4 id="应用场景-22"><a href="#应用场景-22" class="headerlink" title="应用场景"></a>应用场景</h4><p>在构建系统中，软件包之间的依赖关系形成了一个典型的DAG。例如，在Maven、Gradle等构建工具中，项目依赖的各个模块和库之间的关系可以表示为DAG，从而确定正确的编译和打包顺序。</p>
<p>在工作流引擎或批处理系统中，任务之间的前后依赖关系形成DAG，系统根据拓扑排序结果安排任务执行顺序，保证依赖任务先于被依赖任务执行。</p>
<p>在编译器设计中，程序的控制流图通常是DAG形式。编译器根据这个图进行代码优化，如指令重排序、公共子表达式消除等，以提高程序性能。</p>
<p>数据处理管线，特别是ETL(Extract-Transform-Load)过程，也常表示为DAG。数据从源头经过一系列转换节点，最终到达目标存储，整个流程可以建模为有向无环图。</p>
<p>论文引用网络、事件调度、项目规划等领域也经常使用DAG进行建模和分析。</p>
<h4 id="测验-22"><a href="#测验-22" class="headerlink" title="测验"></a>测验</h4><ol>
<li>如果一个有向无环图有n个顶点，最多可以有多少条边？为什么？</li>
<li>拓扑排序的结果是唯一的吗？如果不是，试举一个有多种拓扑排序结果的DAG例子。</li>
<li>如何判断一个有向图是否为有向无环图？请简述算法思路。</li>
<li>在DAG中，所有顶点是否总能通过一条路径连接？为什么？</li>
</ol>
<blockquote>
<p>测验答案</p>
<ol>
<li>最多可以有n(n-1)/2条边。因为在有向无环图中，如果存在从顶点i到顶点j的边，就不能存在从j到i的边（否则会形成环）。对于n个顶点，最多可以有n(n-1)/2对顶点之间有边。</li>
<li>拓扑排序的结果通常不是唯一的。例如，考虑一个有4个顶点的DAG，边为(0,2)、(0,3)、(1,3)。这个图有两种可能的拓扑排序：[0,1,2,3]和[1,0,2,3]。</li>
<li>判断有向图是否为DAG可以使用DFS算法：在DFS遍历过程中维护一个”访问栈”，记录当前递归路径上的所有顶点。如果在DFS过程中发现一个已经在访问栈中的顶点，说明存在环；如果DFS结束后没有发现环，则图是DAG。另一种方法是尝试进行拓扑排序，如果能够得到包含所有顶点的排序结果，则图是DAG。</li>
<li>在DAG中，并非所有顶点对之间都能通过路径连接。DAG可能包含多个不相连的部分。例如，一个有两个顶点0和1但没有边的图就是DAG，但0和1之间没有路径。</li>
</ol>
</blockquote>
<h3 id="六、邻接矩阵"><a href="#六、邻接矩阵" class="headerlink" title="六、邻接矩阵"></a>六、邻接矩阵</h3><p>邻接矩阵使用二维数组表示图，matrix[i][j]的值表示顶点i和顶点j之间是否存在边（以及边的权重）。</p>
<p><code>空间复杂度:O(V^2)</code></p>
<h5 id="算法讲解-23"><a href="#算法讲解-23" class="headerlink" title="算法讲解"></a>算法讲解</h5><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><h5 id="介绍-23"><a href="#介绍-23" class="headerlink" title="介绍"></a>介绍</h5><p>邻接矩阵（Adjacency Matrix）是图论中常用的图表示方式之一，它使用二维数组来表示图中顶点之间的连接关系。对于有 n 个顶点的图，我们使用一个 n×n 的矩阵，如果顶点 i 和顶点 j 之间有边，则矩阵中对应位置的元素值为 1（无权图）或者权重值（有权图），否则为 0 或无穷大。</p>
<h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p>在理解邻接矩阵之前，我们需要了解一些基础图论概念：</p>
<p>图（Graph）：由顶点（Vertex）和连接顶点的边（Edge）组成的数据结构。</p>
<p>顶点（Vertex）：图中的节点，通常用数字标识，如 0, 1, 2… 或字母 A, B, C…</p>
<p>边（Edge）：连接两个顶点的线段，表示它们之间存在某种关系。</p>
<h6 id="在邻接矩阵中："><a href="#在邻接矩阵中：" class="headerlink" title="在邻接矩阵中："></a>在邻接矩阵中：</h6><ul>
<li>矩阵的行和列分别代表图中的顶点</li>
<li>矩阵元素 M[i][j] 表示从顶点 i 到顶点 j 的边的信息</li>
</ul>
<p>根据图的类型，邻接矩阵有不同的表示方式：</p>
<h6 id="无向图中："><a href="#无向图中：" class="headerlink" title="无向图中："></a>无向图中：</h6><ul>
<li>如果顶点 i 和 j 之间有边，则 M[i][j] = M[j][i] = 1（无权图）或权重值（有权图）</li>
<li>如果没有边，则 M[i][j] = M[j][i] = 0 或无穷大</li>
<li>矩阵是对称的，即 M[i][j] = M[j][i]</li>
</ul>
<h6 id="有向图中："><a href="#有向图中：" class="headerlink" title="有向图中："></a>有向图中：</h6><ul>
<li>如果从顶点 i 到 j 有一条边，则 M[i][j] = 1 或权重值</li>
<li>如果没有边，则 M[i][j] = 0 或无穷大</li>
<li>矩阵通常不是对称的</li>
</ul>
<p>示例：<br> 假设有一个包含 4 个顶点 (0, 1, 2, 3) 的无权无向图，边的信息如下：</p>
<ul>
<li>0 连接到 1</li>
<li>0 连接到 2</li>
<li>1 连接到 2</li>
<li>2 连接到 3</li>
</ul>
<p>则其邻接矩阵表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0  1  2  3</span><br><span class="line">0 [ 0  1  1  0 ]</span><br><span class="line">1 [ 1  0  1  0 ]</span><br><span class="line">2 [ 1  1  0  1 ]</span><br><span class="line">3 [ 0  0  1  0 ]</span><br></pre></td></tr></table></figure>
<p>如果是有权图，矩阵中存储的就是对应边的权重，没有边的位置通常用无穷大（实际编程中可能用一个特殊值如 -1 或 Integer.MAX_VALUE）表示。</p>
<h4 id="核心特性-23"><a href="#核心特性-23" class="headerlink" title="核心特性"></a>核心特性</h4><ul>
<li>直观表示：通过矩阵可以直观地看出任意两个顶点之间是否有连接</li>
<li>快速查询：O(1) 时间复杂度即可确定两个顶点之间是否有边</li>
<li>适合密集图：当图中边的数量接近顶点数的平方时，邻接矩阵较为高效</li>
<li>矩阵运算：可以利用矩阵运算解决图论问题，如求最短路径</li>
</ul>
<h4 id="基本操作-22"><a href="#基本操作-22" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li>添加边：设置矩阵中对应位置的值</li>
<li>删除边：重置矩阵中对应位置的值</li>
<li>查询边：直接访问矩阵中对应位置</li>
<li>获取顶点的所有邻接点：遍历该顶点对应的行或列</li>
</ul>
<h4 id="代码实现-21"><a href="#代码实现-21" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 邻接矩阵表示的图</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;           <span class="comment">// 顶点数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] adjMatrix; <span class="comment">// 邻接矩阵</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = v;</span><br><span class="line">        adjMatrix = <span class="keyword">new</span> <span class="title class_">int</span>[v][v];</span><br><span class="line">        <span class="comment">// 初始化矩阵，所有边的值都为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; v; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; v; j++) &#123;</span><br><span class="line">                adjMatrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加边（无向图）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> destination)</span> &#123;</span><br><span class="line">        <span class="comment">// 确保顶点有效</span></span><br><span class="line">        <span class="keyword">if</span> (source &gt;= <span class="number">0</span> &amp;&amp; source &lt; V &amp;&amp; destination &gt;= <span class="number">0</span> &amp;&amp; destination &lt; V) &#123;</span><br><span class="line">            adjMatrix[source][destination] = <span class="number">1</span>;</span><br><span class="line">            adjMatrix[destination][source] = <span class="number">1</span>; <span class="comment">// 对于无向图，两个方向都要设置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加带权重的边（有权图）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> destination, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (source &gt;= <span class="number">0</span> &amp;&amp; source &lt; V &amp;&amp; destination &gt;= <span class="number">0</span> &amp;&amp; destination &lt; V) &#123;</span><br><span class="line">            adjMatrix[source][destination] = weight;</span><br><span class="line">            adjMatrix[destination][source] = weight; <span class="comment">// 对于无向图，两个方向都要设置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeEdge</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> destination)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (source &gt;= <span class="number">0</span> &amp;&amp; source &lt; V &amp;&amp; destination &gt;= <span class="number">0</span> &amp;&amp; destination &lt; V) &#123;</span><br><span class="line">            adjMatrix[source][destination] = <span class="number">0</span>;</span><br><span class="line">            adjMatrix[destination][source] = <span class="number">0</span>; <span class="comment">// 对于无向图，两个方向都要重置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断两个顶点之间是否有边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasEdge</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> destination)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (source &gt;= <span class="number">0</span> &amp;&amp; source &lt; V &amp;&amp; destination &gt;= <span class="number">0</span> &amp;&amp; destination &lt; V) &#123;</span><br><span class="line">            <span class="keyword">return</span> adjMatrix[source][destination] != <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取边的权重</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getEdgeWeight</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> destination)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (source &gt;= <span class="number">0</span> &amp;&amp; source &lt; V &amp;&amp; destination &gt;= <span class="number">0</span> &amp;&amp; destination &lt; V) &#123;</span><br><span class="line">            <span class="keyword">return</span> adjMatrix[source][destination];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 表示没有边或顶点无效</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印邻接矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMatrix</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; V; j++) &#123;</span><br><span class="line">                System.out.print(adjMatrix[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取顶点的所有邻接点</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getAdjacentVertices</span><span class="params">(<span class="type">int</span> vertex)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; adjacentVertices = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (vertex &gt;= <span class="number">0</span> &amp;&amp; vertex &lt; V) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; V; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (adjMatrix[vertex][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    adjacentVertices.add(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> adjacentVertices;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<h4 id="优缺点-22"><a href="#优缺点-22" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点：-5"><a href="#优点：-5" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>实现简单，易于理解</li>
<li>查询两个顶点之间是否有边的时间复杂度为 O(1)</li>
<li>添加和删除边的操作非常高效，时间复杂度为 O(1)</li>
<li>适合表示密集图（边数接近顶点数平方的图）</li>
<li>可以直接应用矩阵运算来解决一些图论问题</li>
</ul>
<h5 id="缺点：-5"><a href="#缺点：-5" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>空间复杂度为 O(V²)，对于大型稀疏图会浪费大量空间</li>
<li>添加或删除顶点的操作复杂，需要重新分配并复制整个矩阵</li>
<li>遍历所有边的时间复杂度为 O(V²)，对于稀疏图效率较低</li>
<li>不能表示平行边（两个顶点之间的多条边）</li>
</ul>
<h4 id="应用场景-23"><a href="#应用场景-23" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>表示较小规模的图，尤其是边较密集的图</li>
<li>需要频繁查询两个顶点之间是否存在边的场景</li>
<li>实现图的算法时，特别是那些需要快速判断顶点间连接性的算法</li>
<li>图的分析算法，如Floyd-Warshall算法寻找所有点对之间的最短路径</li>
<li>社交网络分析中的连接关系表示</li>
<li>网络路由算法中的连接性分析</li>
</ul>
<h4 id="扩展-6"><a href="#扩展-6" class="headerlink" title="扩展"></a>扩展</h4><h5 id="邻接矩阵的优化"><a href="#邻接矩阵的优化" class="headerlink" title="邻接矩阵的优化"></a>邻接矩阵的优化</h5><p>对于无向图，由于邻接矩阵是对称的，我们可以只存储上三角或下三角部分，从而将空间需求降低约一半。这种优化在实际应用中可以通过一维数组加索引转换公式实现。</p>
<h5 id="变种：关联矩阵"><a href="#变种：关联矩阵" class="headerlink" title="变种：关联矩阵"></a>变种：关联矩阵</h5><p>除了邻接矩阵外，还有一种称为关联矩阵（Incidence Matrix）的表示方法。在 n 个顶点、m 条边的图中，关联矩阵是一个 n×m 的矩阵：</p>
<ul>
<li>对于无向图，如果边 j 连接顶点 i，则矩阵元素 M[i][j] = 1，否则为 0</li>
<li>对于有向图，如果边 j 从顶点 i 出发，则 M[i][j] = 1；如果边 j 指向顶点 i，则 M[i][j] = -1；否则为 0</li>
</ul>
<h4 id="测验-23"><a href="#测验-23" class="headerlink" title="测验"></a>测验</h4><ol>
<li>在一个包含 100 个顶点的无向图中，如果使用邻接矩阵表示，矩阵的大小是多少？存储这个矩阵最少需要多少比特？</li>
<li>如果一个邻接矩阵是对称的（即 M[i][j] = M[j][i] 对所有 i, j 成立），这说明这个图是什么类型？</li>
<li>在邻接矩阵中，一个顶点的度（与之相连的边数）如何计算？</li>
</ol>
<blockquote>
<p>测验答案</p>
<ol>
<li>矩阵大小为 100×100 = 10000 个元素。如果使用布尔值（1 比特）表示边的存在，则至少需要 10000 比特。</li>
<li>对称的邻接矩阵表示的是无向图，因为无向图中的边没有方向，从 i 到 j 有边意味着从 j 到 i 也有边。</li>
<li>对于无向图，顶点的度等于该顶点对应行（或列）中非零元素的数量；对于有向图，顶点的出度等于对应行中非零元素的数量，入度等于对应列中非零元素的数量。</li>
</ol>
</blockquote>
<h3 id="七、邻接表"><a href="#七、邻接表" class="headerlink" title="七、邻接表"></a>七、邻接表</h3><p>邻接表使用哈希表或数组存储每个顶点及其相邻顶点的列表。</p>
<p><code>空间复杂度:O(V + E)</code></p>
<h5 id="算法讲解-24"><a href="#算法讲解-24" class="headerlink" title="算法讲解"></a>算法讲解</h5><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><h4 id="介绍-24"><a href="#介绍-24" class="headerlink" title="介绍"></a>介绍</h4><p>邻接表是图论中最常用的图表示方式之一，它为每个顶点维护一个列表，存储与该顶点相邻的所有顶点。这种表示方法特别适合表示稀疏图（边数远小于顶点数平方的图），能有效节省空间，保持较高的操作效率。</p>
<h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h4><p>邻接表（Adjacency List）是一种通过链表或数组表示图的数据结构。在理解它之前，我们需要掌握一些基础图论概念：</p>
<p>图（Graph）：由顶点（Vertex）和连接顶点的边（Edge）组成的数据结构。图可以用来表示现实世界中的各种关系，如社交网络、交通系统等。</p>
<p>顶点（Vertex）：图中的节点，通常用数字或字母标识，如 0, 1, 2… 或 A, B, C…</p>
<p>边（Edge）：连接两个顶点的线段，表示它们之间存在某种关系。</p>
<p>在邻接表中：</p>
<ul>
<li>每个顶点对应一个列表（可以是链表、数组或其他集合类型）</li>
<li>列表中存储与该顶点直接相连的所有顶点</li>
<li>对于有权图，还需要存储边的权重信息</li>
</ul>
<p>邻接表的表示方式根据图的类型有所不同：</p>
<p>无向图中：</p>
<ul>
<li>如果顶点 i 和 j 之间有边，则 j 会出现在 i 的邻接表中，i 也会出现在 j 的邻接表中</li>
<li>每条边在两个不同的列表中各出现一次</li>
</ul>
<p>有向图中：</p>
<ul>
<li>如果从顶点 i 到 j 有一条边，则 j 只会出现在 i 的邻接表中</li>
<li>每条边只在一个列表中出现一次</li>
</ul>
<p>示例：<br> 假设有一个包含 4 个顶点 (0, 1, 2, 3) 的无向图，边的信息如下：</p>
<ul>
<li>0 连接到 1</li>
<li>0 连接到 2</li>
<li>1 连接到 2</li>
<li>2 连接到 3</li>
</ul>
<p>则其邻接表表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 -&gt; [1, 2]</span><br><span class="line">1 -&gt; [0, 2]</span><br><span class="line">2 -&gt; [0, 1, 3]</span><br><span class="line">3 -&gt; [2]</span><br></pre></td></tr></table></figure>
<p>对于有权图，每个邻接表项通常包含顶点索引和边的权重。</p>
<h4 id="核心特性-24"><a href="#核心特性-24" class="headerlink" title="核心特性"></a>核心特性</h4><ul>
<li>空间效率高：只需存储实际存在的边，特别适合稀疏图</li>
<li>快速访问某个顶点的所有邻接点</li>
<li>灵活：容易添加和删除边，同时支持添加额外的边信息（如权重）</li>
<li>适用于各种图算法，如广度优先搜索（BFS）和深度优先搜索（DFS）</li>
</ul>
<h4 id="基本操作-23"><a href="#基本操作-23" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li>添加边：将目标顶点添加到源顶点的邻接列表中</li>
<li>删除边：从源顶点的邻接列表中删除目标顶点</li>
<li>查询边：检查目标顶点是否在源顶点的邻接列表中</li>
<li>获取顶点的所有邻接点：直接访问该顶点的邻接列表</li>
</ul>
<h4 id="代码实现-22"><a href="#代码实现-22" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表表示的图</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;                 <span class="comment">// 顶点数</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; adjList; <span class="comment">// 邻接表（无权图）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = v;</span><br><span class="line">        adjList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; v; i++) &#123;</span><br><span class="line">            adjList.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加边（无向图）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> destination)</span> &#123;</span><br><span class="line">        <span class="comment">// 确保顶点有效</span></span><br><span class="line">        <span class="keyword">if</span> (source &gt;= <span class="number">0</span> &amp;&amp; source &lt; V &amp;&amp; destination &gt;= <span class="number">0</span> &amp;&amp; destination &lt; V) &#123;</span><br><span class="line">            adjList.get(source).add(destination);</span><br><span class="line">            adjList.get(destination).add(source); <span class="comment">// 对于无向图，两个方向都要添加</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeEdge</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> destination)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (source &gt;= <span class="number">0</span> &amp;&amp; source &lt; V &amp;&amp; destination &gt;= <span class="number">0</span> &amp;&amp; destination &lt; V) &#123;</span><br><span class="line">            adjList.get(source).remove(Integer.valueOf(destination));</span><br><span class="line">            adjList.get(destination).remove(Integer.valueOf(source)); <span class="comment">// 对于无向图，两个方向都要删除</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断两个顶点之间是否有边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasEdge</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> destination)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (source &gt;= <span class="number">0</span> &amp;&amp; source &lt; V &amp;&amp; destination &gt;= <span class="number">0</span> &amp;&amp; destination &lt; V) &#123;</span><br><span class="line">            <span class="keyword">return</span> adjList.get(source).contains(destination);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取顶点的所有邻接点</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getAdjacentVertices</span><span class="params">(<span class="type">int</span> vertex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (vertex &gt;= <span class="number">0</span> &amp;&amp; vertex &lt; V) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(adjList.get(vertex));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印邻接表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printGraph</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; -&gt; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j : adjList.get(i)) &#123;</span><br><span class="line">                System.out.print(j + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有权图的邻接表实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeightedGraph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Edge&gt;&gt; adjList;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内部类表示有权边</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> destination;</span><br><span class="line">        <span class="type">int</span> weight;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(<span class="type">int</span> destination, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.destination = destination;</span><br><span class="line">            <span class="built_in">this</span>.weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeightedGraph</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = v;</span><br><span class="line">        adjList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; v; i++) &#123;</span><br><span class="line">            adjList.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加边（有权图）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> destination, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (source &gt;= <span class="number">0</span> &amp;&amp; source &lt; V &amp;&amp; destination &gt;= <span class="number">0</span> &amp;&amp; destination &lt; V) &#123;</span><br><span class="line">            adjList.get(source).add(<span class="keyword">new</span> <span class="title class_">Edge</span>(destination, weight));</span><br><span class="line">            adjList.get(destination).add(<span class="keyword">new</span> <span class="title class_">Edge</span>(source, weight)); <span class="comment">// 对于无向图</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取边的权重</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getEdgeWeight</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> destination)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (source &gt;= <span class="number">0</span> &amp;&amp; source &lt; V &amp;&amp; destination &gt;= <span class="number">0</span> &amp;&amp; destination &lt; V) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Edge edge : adjList.get(source)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (edge.destination == destination) &#123;</span><br><span class="line">                    <span class="keyword">return</span> edge.weight;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 表示没有边或顶点无效</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印有权图</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printGraph</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; -&gt; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Edge edge : adjList.get(i)) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;(&quot;</span> + edge.destination + <span class="string">&quot;,&quot;</span> + edge.weight + <span class="string">&quot;) &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<h4 id="优缺点-23"><a href="#优缺点-23" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点：-6"><a href="#优点：-6" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>空间效率高：对于稀疏图，只需存储实际存在的边</li>
<li>添加顶点操作简单：只需添加一个新的空列表</li>
<li>遍历顶点的所有邻接点高效：直接访问对应列表</li>
<li>适合与大多数图算法结合使用，如 BFS、DFS、Dijkstra 等</li>
<li>内存使用灵活：随着边的增加，动态分配内存</li>
</ul>
<h5 id="缺点：-6"><a href="#缺点：-6" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>查询特定边的存在性需要遍历列表，时间复杂度为 O(度)</li>
<li>删除边操作较慢，需要遍历列表查找目标顶点</li>
<li>对于完全图或近似完全图，内存消耗与邻接矩阵相当甚至更多</li>
<li>对于无向图，每条边需要存储两次，可能导致不一致性</li>
</ul>
<h4 id="应用场景-24"><a href="#应用场景-24" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>表示大多数实际应用中的稀疏图</li>
<li>社交网络的关系表示（如朋友关系、关注关系）</li>
<li>网络路由中的节点连接关系</li>
<li>图遍历算法的实现（如 BFS、DFS）</li>
<li>最短路径算法（如 Dijkstra、Bellman-Ford）</li>
<li>最小生成树算法（如 Prim 算法）</li>
</ul>
<h4 id="扩展-7"><a href="#扩展-7" class="headerlink" title="扩展"></a>扩展</h4><h4 id="邻接表的优化与变体"><a href="#邻接表的优化与变体" class="headerlink" title="邻接表的优化与变体"></a>邻接表的优化与变体</h4><h6 id="反向邻接表"><a href="#反向邻接表" class="headerlink" title="反向邻接表"></a>反向邻接表</h6><p>对于有向图，除了常规邻接表外，可以同时维护一个反向邻接表，存储指向每个顶点的所有顶点。这种双重结构在一些算法中非常有用，如：</p>
<ul>
<li>强连通分量算法（如 Kosaraju 算法）</li>
<li>计算顶点的入度</li>
<li>反向遍历图</li>
</ul>
<h6 id="压缩邻接表"><a href="#压缩邻接表" class="headerlink" title="压缩邻接表"></a>压缩邻接表</h6><p>对于静态图（边不会频繁变化），可以使用压缩邻接表（CSR, Compressed Sparse Row）格式来进一步降低内存消耗。CSR 使用两个数组：</p>
<ul>
<li>一个存储所有邻接点，按顶点顺序排列</li>
<li>另一个存储每个顶点邻接列表的起始索引</li>
</ul>
<p>这种表示方法在大规模图计算中常用，如 PageRank 算法。</p>
<h4 id="高级应用"><a href="#高级应用" class="headerlink" title="高级应用"></a>高级应用</h4><h5 id="复杂路径查询"><a href="#复杂路径查询" class="headerlink" title="复杂路径查询"></a>复杂路径查询</h5><p>邻接表特别适合实现图遍历算法，如广度优先搜索（BFS）和深度优先搜索（DFS）。这些算法是许多更复杂路径查询的基础：</p>
<ul>
<li>最短路径查找（Dijkstra 和 Bellman-Ford 算法）</li>
<li>所有节点对之间的最短路径（Floyd-Warshall 算法）</li>
<li>欧拉路径和汉密尔顿路径查找</li>
</ul>
<h5 id="增强邻接表"><a href="#增强邻接表" class="headerlink" title="增强邻接表"></a>增强邻接表</h5><p>在实际应用中，邻接表可以增强存储更多信息：</p>
<ul>
<li>为边添加时间戳（表示关系建立的时间）</li>
<li>存储边的类型（如社交网络中的”朋友”、”关注”等不同关系）</li>
<li>为边添加状态信息（如交通网络中道路的拥堵状况）</li>
</ul>
<h5 id="与其他表示方法的比较选择"><a href="#与其他表示方法的比较选择" class="headerlink" title="与其他表示方法的比较选择"></a>与其他表示方法的比较选择</h5><p>选择图表示方法时的一般准则：</p>
<ul>
<li>稀疏图（|E| &lt;&lt; |V|²）：首选邻接表，空间复杂度为 O(V+E)</li>
<li>密集图（|E| 接近 |V|²）：邻接矩阵可能更有效，空间复杂度为 O(V²)</li>
<li>需要快速查询特定边：邻接矩阵提供 O(1) 查询时间</li>
<li>需要频繁添加/删除顶点：邻接表更灵活</li>
<li>需要在所有边上迭代：边列表更直接</li>
</ul>
<h5 id="内存效率考虑"><a href="#内存效率考虑" class="headerlink" title="内存效率考虑"></a>内存效率考虑</h5><p>在大规模图应用中，节省内存特别重要。邻接表可以通过以下方式进一步优化：</p>
<ul>
<li>使用整数索引代替对象引用</li>
<li>采用适当的数据结构存储邻接点（比如有序数组可支持二分查找）</li>
<li>使用哈希表或平衡树代替普通列表，加速搜索特定边的过程</li>
</ul>
<h4 id="测验-24"><a href="#测验-24" class="headerlink" title="测验"></a>测验</h4><ol>
<li>在一个包含 100 个顶点和 300 条边的无向图中，如果使用邻接表表示，共需要存储多少个顶点引用？</li>
<li>对于一个有向图，如果要判断某个顶点的入度（指向该顶点的边数），使用邻接表需要怎样的时间复杂度？</li>
<li>在邻接表表示的图中，遍历所有边的时间复杂度是多少？（V 表示顶点数，E 表示边数）</li>
</ol>
<blockquote>
<p>测验答案</p>
<ol>
<li>600个顶点引用。在无向图的邻接表中，每条边在两个顶点的列表中各出现一次，所以总共有 300 * 2 = 600 个顶点引用。</li>
<li>O(V+E)。使用标准邻接表无法直接获取入度，需要遍历所有顶点的邻接表，检查是否包含目标顶点。</li>
<li>O(V+E)。需要遍历所有顶点的邻接表，总工作量与顶点数加边数成正比。</li>
</ol>
</blockquote>
<h2 id="哈希与映射"><a href="#哈希与映射" class="headerlink" title="哈希与映射"></a>哈希与映射</h2><h3 id="一、哈希表（链地址法）"><a href="#一、哈希表（链地址法）" class="headerlink" title="一、哈希表（链地址法）"></a>一、哈希表（链地址法）</h3><p>通过哈希函数将键映射到数组的索引，使用链表处理哈希冲突。提供近乎O(1)的查找、插入和删除操作。</p>
<p><code>空间复杂度:O(n)</code></p>
<h5 id="算法讲解-25"><a href="#算法讲解-25" class="headerlink" title="算法讲解"></a>算法讲解</h5><h4 id="哈希表（链地址法）"><a href="#哈希表（链地址法）" class="headerlink" title="哈希表（链地址法）"></a>哈希表（链地址法）</h4><h5 id="介绍-25"><a href="#介绍-25" class="headerlink" title="介绍"></a>介绍</h5><p>哈希表（Hash Table）是一种高效的数据结构，能够实现快速的插入、查找和删除操作。链地址法（Chaining）是解决哈希冲突的一种常用方法，它通过为每个哈希桶维护一个链表，将具有相同哈希值的元素存储在同一链表中，从而有效处理冲突问题。</p>
<h4 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h4><p>哈希表（Hash Table）是一种基于哈希函数直接访问元素的数据结构，理解它需要先掌握几个关键概念：</p>
<p>哈希函数（Hash Function）：将输入数据（通常是无限范围）映射到有限范围（哈希表大小）的函数。一个好的哈希函数应该能够均匀分布元素，最小化冲突。</p>
<p>哈希值（Hash Value）：哈希函数的输出结果，用作哈希表中的索引。</p>
<p>哈希桶（Bucket）：哈希表中存储元素的位置，每个桶对应一个哈希值。</p>
<p>哈希冲突（Hash Collision）：当两个不同的输入通过哈希函数产生相同的哈希值时发生冲突。由于哈希表空间有限而可能的输入数据无限，冲突不可避免。</p>
<p>链地址法（Chaining）：解决哈希冲突的一种方法，其基本思想是：</p>
<ul>
<li>每个哈希桶维护一个链表</li>
<li>当发生冲突时，将新元素添加到对应哈希桶的链表中</li>
<li>查找元素时，先计算哈希值找到对应桶，然后在链表中搜索目标元素</li>
</ul>
<p>哈希表的负载因子（Load Factor）：表中元素数量与哈希表大小的比值。当负载因子增大时，链表长度可能增加，导致性能下降。</p>
<p>示例：<br> 假设有一个大小为 7 的哈希表，使用简单的哈希函数 h(k) = k % 7，现在需要插入键值对：(10, “苹果”)、(21, “香蕉”)、(32, “橙子”)、(17, “葡萄”)。</p>
<p>计算哈希值：</p>
<ul>
<li>h(10) = 10 % 7 = 3，将 (10, “苹果”) 存入索引 3 的链表</li>
<li>h(21) = 21 % 7 = 0，将 (21, “香蕉”) 存入索引 0 的链表</li>
<li>h(32) = 32 % 7 = 4，将 (32, “橙子”) 存入索引 4 的链表</li>
<li>h(17) = 17 % 7 = 3，将 (17, “葡萄”) 存入索引 3 的链表，与 (10, “苹果”) 在同一链表中</li>
</ul>
<p>最终哈希表结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">▼Plain复制代码0: → (21, &quot;香蕉&quot;) → null</span><br><span class="line">1: → null</span><br><span class="line">2: → null</span><br><span class="line">3: → (10, &quot;苹果&quot;) → (17, &quot;葡萄&quot;) → null</span><br><span class="line">4: → (32, &quot;橙子&quot;) → null</span><br><span class="line">5: → null</span><br><span class="line">6: → null</span><br></pre></td></tr></table></figure>
<p>可以看到索引 3 处有两个元素，这是因为 10 和 17 发生了哈希冲突，它们通过链表连接在一起。</p>
<h4 id="核心特性-25"><a href="#核心特性-25" class="headerlink" title="核心特性"></a>核心特性</h4><ul>
<li>高效操作：平均情况下，插入、查找、删除操作的时间复杂度为 O(1)</li>
<li>冲突处理：使用链表解决哈希冲突，适应性强</li>
<li>动态扩容：当负载因子过高时，可以扩容哈希表以维持性能</li>
<li>无序性：元素在哈希表中的位置由哈希函数决定，不保持插入顺序</li>
</ul>
<h4 id="基本操作-24"><a href="#基本操作-24" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li>插入（put）：计算键的哈希值，将键值对插入对应桶的链表中</li>
<li>查找（get）：计算键的哈希值，在对应桶的链表中查找键值对</li>
<li>删除（remove）：计算键的哈希值，从对应桶的链表中移除键值对</li>
<li>判断键是否存在（containsKey）：计算键的哈希值，检查对应桶的链表中是否存在该键</li>
</ul>
<h4 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h4><p>在大多数语言中都有哈希表的实现，比如 Java 中的 HashMap、Python 中的 dict 和 collections.defaultdict、JavaScript 中的 Object 和 Map、Go 中的 map 以及 C++ 中的 std::unordered_map，这些内置实现已经高度优化，能够有效处理哈希冲突并提供稳定的性能，所以这里不再提供自定义实现。</p>
<h4 id="优缺点-24"><a href="#优缺点-24" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点：-7"><a href="#优点：-7" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>实现简单：链地址法概念明确，实现相对简单</li>
<li>高效查找：平均情况下，查找操作的时间复杂度接近 O(1)</li>
<li>适应性强：可以处理任意数量的冲突</li>
<li>删除操作简单：不需要复杂的逻辑即可完成删除</li>
<li>扩容策略灵活：可以根据负载因子动态调整哈希表大小</li>
</ul>
<h5 id="缺点：-7"><a href="#缺点：-7" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>额外内存开销：每个节点需要额外的指针存储，增加了内存消耗</li>
<li>不适合缓存局部性：链表中的元素可能散布在内存各处，不利于CPU缓存</li>
<li>链表过长时性能下降：当哈希冲突严重时，操作可能退化为 O(n)</li>
<li>哈希函数敏感：性能严重依赖于哈希函数的质量</li>
</ul>
<h4 id="应用场景-25"><a href="#应用场景-25" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>实现关联数组或字典，如大多数语言的 HashMap/Dictionary 类</li>
<li>数据库索引，特别是哈希索引</li>
<li>缓存系统，如 LRU 缓存的底层结构</li>
<li>符号表，用于编译器和解释器</li>
<li>集合（Set）数据结构的实现</li>
<li>用于快速去重和查找的场景</li>
</ul>
<h4 id="扩展-8"><a href="#扩展-8" class="headerlink" title="扩展"></a>扩展</h4><h5 id="链地址法的优化与变体"><a href="#链地址法的优化与变体" class="headerlink" title="链地址法的优化与变体"></a>链地址法的优化与变体</h5><h6 id="改进链表结构"><a href="#改进链表结构" class="headerlink" title="改进链表结构"></a>改进链表结构</h6><p>传统链地址法使用普通链表存储冲突元素，但可以通过替换链表结构提升性能：</p>
<ul>
<li>有序链表：保持链表元素有序，可以提前终止查找</li>
<li>自调整链表：将频繁访问的元素移到链表前端，减少平均查找时间</li>
<li>替换为平衡树：对于长链表，可以使用小型平衡树（如红黑树）替代，将最坏情况从O(n)改善为O(log n)</li>
</ul>
<h6 id="桶大小优化"><a href="#桶大小优化" class="headerlink" title="桶大小优化"></a>桶大小优化</h6><ul>
<li>多元素桶：每个桶预先分配固定空间（如4个元素），当元素少时避免动态分配</li>
<li>两级哈希：在冲突严重的桶中使用第二级哈希表</li>
</ul>
<h4 id="测验-25"><a href="#测验-25" class="headerlink" title="测验"></a>测验</h4><ol>
<li>在一个使用链地址法的哈希表中，如果负载因子（load factor）为 2，表示什么？这对哈希表性能有何影响？</li>
<li>如果哈希表的大小为 10，使用哈希函数 h(x) = x % 10，插入元素 {12, 22, 32, 42, 52}，请描述哈希表的结构。</li>
<li>在哈希表中使用链地址法解决冲突时，查找不存在的元素的最坏时间复杂度是多少？为什么？</li>
</ol>
<blockquote>
<p>测验答案</p>
<ol>
<li>负载因子为 2 表示哈希表中的元素数量是哈希表大小的两倍，平均每个桶包含 2 个元素。这意味着哈希冲突较多，查找操作的平均时间复杂度将增加，可能接近 O(n)，性能会下降。</li>
<li>哈希表结构如下：<ul>
<li>桶 2: → (12, value) → (22, value) → (32, value) → (42, value) → (52, value) → null</li>
<li>其他桶 (0,1,3-9): → null<br>所有元素都被映射到索引 2 上，形成了一个长链表。</li>
</ul>
</li>
<li>最坏时间复杂度是 O(n)，n 是哈希表中的元素总数。在最坏情况下，所有元素都被哈希到同一个桶中，形成一个长链表，需要遍历整个链表才能确定元素不存在。</li>
</ol>
</blockquote>
<h3 id="二、哈希表（开放寻址法）"><a href="#二、哈希表（开放寻址法）" class="headerlink" title="二、哈希表（开放寻址法）"></a>二、哈希表（开放寻址法）</h3><p>通过哈希函数将键映射到数组的索引，使用开放寻址法（线性探测）处理哈希冲突，提供近乎O(1)的查找、插入和删除操作。</p>
<p><code>空间复杂度:O(n)</code></p>
<h5 id="算法讲解-26"><a href="#算法讲解-26" class="headerlink" title="算法讲解"></a>算法讲解</h5><h4 id="哈希表（开放寻址法）"><a href="#哈希表（开放寻址法）" class="headerlink" title="哈希表（开放寻址法）"></a>哈希表（开放寻址法）</h4><h5 id="介绍-26"><a href="#介绍-26" class="headerlink" title="介绍"></a>介绍</h5><p>哈希表（Hash Table）是一种高效的数据结构，能够实现近乎 O(1) 时间复杂度的查找、插入和删除操作。开放寻址法（Open Addressing）是解决哈希冲突的一种重要方法，它不使用额外的数据结构（如链表），在哈希表本身的空间内寻找可用位置来存储冲突的元素，从而更加节省内存空间。</p>
<h4 id="基本概念-4"><a href="#基本概念-4" class="headerlink" title="基本概念"></a>基本概念</h4><p>哈希表（Hash Table）是一种基于哈希函数直接访问元素的数据结构，理解开放寻址法需要先掌握以下基础概念：</p>
<p>哈希函数（Hash Function）：将输入数据映射到哈希表索引范围内的函数。理想的哈希函数应该计算快速且均匀分布元素。</p>
<p>哈希冲突（Hash Collision）：当两个不同的键通过哈希函数得到相同的索引值时发生的情况。</p>
<p>开放寻址法（Open Addressing）：解决哈希冲突的方法，其核心思想是：</p>
<ul>
<li>当发生冲突时，通过特定的探测序列寻找表中的下一个可用位置</li>
<li>所有元素都直接存储在哈希表中，不使用额外的数据结构</li>
<li>每个桶只存储一个元素，表中的空间可分为三种状态：空闲、占用、删除</li>
</ul>
<p>开放寻址法的主要探测技术包括：</p>
<ol>
<li>线性探测（Linear Probing）：<ul>
<li>最简单的探测方法，冲突发生时，按顺序检查下一个位置</li>
<li>探测序列：h(k), (h(k) + 1) % m, (h(k) + 2) % m, …, (h(k) + m-1) % m</li>
<li>优点：缓存友好；缺点：容易产生聚集</li>
</ul>
</li>
<li>二次探测（Quadratic Probing）：<ul>
<li>通过平方级数增长的步长来寻找空位置</li>
<li>探测序列：h(k), (h(k) + 1²) % m, (h(k) + 2²) % m, (h(k) + 3²) % m, …</li>
<li>优点：减少聚集；缺点：不保证能探测所有位置</li>
</ul>
</li>
<li>双重哈希（Double Hashing）：<ul>
<li>使用第二个哈希函数确定探测步长</li>
<li>探测序列：h₁(k), (h₁(k) + h₂(k)) % m, (h₁(k) + 2h₂(k)) % m, …</li>
<li>优点：减少聚集，增加探测路径多样性；缺点：需要计算两次哈希值</li>
</ul>
</li>
</ol>
<p>装载因子（Load Factor）：表中已占用位置与表容量的比值，用 α 表示。当 α 增大时，冲突概率增加，性能下降。通常当 α 超过某个阈值（如 0.7）时进行扩容。</p>
<p>示例：<br> 假设有一个大小为 7 的哈希表，使用简单的哈希函数 h(k) = k % 7 和线性探测。现在需要插入键：10, 21, 32, 17。</p>
<p>计算过程：</p>
<ul>
<li>h(10) = 10 % 7 = 3，将 10 存入索引 3</li>
<li>h(21) = 21 % 7 = 0，将 21 存入索引 0</li>
<li>h(32) = 32 % 7 = 4，将 32 存入索引 4</li>
<li>h(17) = 17 % 7 = 3，但索引 3 已被 10 占用，按线性探测，尝试索引 4，已被 32 占用，继续尝试索引 5，可用，将 17 存入索引 5</li>
</ul>
<p>最终哈希表结构为：[21, <em>, </em>, 10, 32, 17, ]，其中 _ 表示空位置。</p>
<h4 id="核心特性-26"><a href="#核心特性-26" class="headerlink" title="核心特性"></a>核心特性</h4><ul>
<li>空间效率：所有元素直接存储在表中，不需要额外指针，节省空间</li>
<li>缓存友好：特别是线性探测法，元素存储紧凑，有利于缓存局部性</li>
<li>灵活性：可以根据应用需求选择不同的探测策略</li>
<li>负载敏感：性能受装载因子影响显著，需要及时扩容维持性能</li>
</ul>
<h4 id="基本操作-25"><a href="#基本操作-25" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li>插入（put）：计算哈希值，如遇冲突则根据探测策略寻找下一个可用位置</li>
<li>查找（get）：计算哈希值，在探测序列上查找，直到找到目标键或遇到空位置</li>
<li>删除（remove）：计算哈希值，找到元素后不能直接标记为空闲，而是标记为已删除</li>
<li>扩容（resize）：当装载因子超过阈值时，创建更大的表并重新哈希所有元素</li>
</ul>
<h4 id="基础实现-1"><a href="#基础实现-1" class="headerlink" title="基础实现"></a>基础实现</h4><p>在大多数语言中都有哈希表的实现，比如 Java 中的 HashMap、Python 中的 dict 和 collections.defaultdict、JavaScript 中的 Object 和 Map、Go 中的 map 以及 C++ 中的 std::unordered_map，这些内置实现已经高度优化，能够有效处理哈希冲突并提供稳定的性能，所以这里不再提供自定义实现。</p>
<h4 id="优缺点-25"><a href="#优缺点-25" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点：-8"><a href="#优点：-8" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>内存效率高：不需要额外的链表结构和指针，节省空间</li>
<li>缓存友好：数据存储紧凑，有利于 CPU 缓存</li>
<li>实现简单：尤其是线性探测，实现逻辑相对简单</li>
<li>扩展性好：可以结合不同的探测策略适应不同的应用场景</li>
</ul>
<h5 id="缺点：-8"><a href="#缺点：-8" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>聚集问题：尤其是线性探测容易产生基本聚集（primary clustering）现象</li>
<li>装载因子限制：通常需要保持较低的装载因子（如 &lt;0.7）才能维持性能</li>
<li>删除操作复杂：需要特殊处理删除操作，避免破坏探测链</li>
<li>全表重建：扩容时需要重新哈希所有元素，成本较高</li>
</ul>
<h4 id="应用场景-26"><a href="#应用场景-26" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>对内存使用敏感的环境：嵌入式系统或内存受限的应用</li>
<li>适合元素大小相对固定的场景</li>
<li>对缓存性能敏感的高性能计算</li>
<li>需要高效查找和简单实现的小型应用</li>
<li>适合装载因子可预测或可控制的场景</li>
<li>实现高性能的集合（Set）数据结构</li>
</ul>
<h4 id="扩展-9"><a href="#扩展-9" class="headerlink" title="扩展"></a>扩展</h4><h5 id="常见的变种与改进"><a href="#常见的变种与改进" class="headerlink" title="常见的变种与改进"></a>常见的变种与改进</h5><h6 id="线性探测的改进"><a href="#线性探测的改进" class="headerlink" title="线性探测的改进"></a>线性探测的改进</h6><p>线性探测虽然简单，但存在严重的聚集问题。实践中常用以下技术改进：</p>
<ul>
<li>带间隔的线性探测：不是每次加1，而是加一个质数（如7），减少聚集</li>
<li>伪随机序列：使用简单的伪随机数生成器创建探测序列，打破规则模式</li>
</ul>
<h6 id="混合策略"><a href="#混合策略" class="headerlink" title="混合策略"></a>混合策略</h6><p>在实际应用中，经常采用混合策略结合多种方法的优点：</p>
<ul>
<li>桶式开放寻址法：每个位置存储固定数量（如4个）的元素，减少冲突同时保持缓存友好</li>
<li>链接-开放混合：当冲突达到一定程度时，从开放寻址转为链式存储</li>
</ul>
<h4 id="实际应用中的考量"><a href="#实际应用中的考量" class="headerlink" title="实际应用中的考量"></a>实际应用中的考量</h4><h5 id="装载因子的选择"><a href="#装载因子的选择" class="headerlink" title="装载因子的选择"></a>装载因子的选择</h5><p>不同探测策略下的最佳装载因子不同：</p>
<ul>
<li>线性探测：通常保持在0.5-0.7之间</li>
<li>二次探测：可以稍高，约0.7-0.8</li>
<li>双重哈希：可以更高，达到0.8-0.9</li>
</ul>
<h4 id="测验-26"><a href="#测验-26" class="headerlink" title="测验"></a>测验</h4><ol>
<li>在使用线性探测的开放寻址哈希表中，什么是”基本聚集”（primary clustering）？它如何影响哈希表性能？</li>
<li>开放寻址法中的删除操作为什么不能直接将位置标记为空（null）？这会导致什么问题？</li>
<li>在同样大小的哈希表中，假设装载因子为 0.8，开放寻址法和链地址法哪种方法的查找性能更好？为什么？</li>
</ol>
<blockquote>
<p>测验答案</p>
<ol>
<li>基本聚集是指在线性探测中连续被占用的位置形成的”群集”现象。当一个位置发生冲突时，会占用下一个位置，导致对后续哈希到这些位置的键产生更多冲突，形成越来越长的连续占用区域。这会显著降低查找和插入操作的性能，因为探测长度增加。</li>
<li>不能直接标记为空，因为这会中断探测链。在开放寻址法中，探测序列遇到空位置时停止，表示元素不存在。如果删除操作简单地将位置标记为空，会导致原本能找到的后续插入的元素无法被找到。因此需要特殊的”已删除”标记。</li>
<li>通常情况下，在高装载因子（如0.8）时，链地址法的性能更好。因为开放寻址法在高装载因子时探测序列变长，查找性能下降明显；链地址法即使在高装载因子下，只要哈希函数分布均匀，每个链表的平均长度仍然可控。开放寻址法通常需要保持较低的装载因子（如&lt;0.7）才能维持良好性能。</li>
</ol>
</blockquote>
<h3 id="三、布隆过滤器"><a href="#三、布隆过滤器" class="headerlink" title="三、布隆过滤器"></a>三、布隆过滤器</h3><p>布隆过滤器是一种空间效率高的概率性数据结构，用于判断一个元素是否在集合中。它可能误判元素存在，但不会误判元素不存在。</p>
<p><code>空间复杂度:O(m)</code></p>
<h5 id="算法讲解-27"><a href="#算法讲解-27" class="headerlink" title="算法讲解"></a>算法讲解</h5><h4 id="布隆过滤器教程"><a href="#布隆过滤器教程" class="headerlink" title="布隆过滤器教程"></a>布隆过滤器教程</h4><h5 id="介绍-27"><a href="#介绍-27" class="headerlink" title="介绍"></a>介绍</h5><p>布隆过滤器(Bloom Filter)是一种空间效率很高的概率型数据结构，它用于判断一个元素是否在一个集合中。布隆过滤器的特点是：对于一个元素，如果布隆过滤器说它不存在，那么它一定不存在；如果布隆过滤器说它存在，那么它可能存在（有一定的误判率）。</p>
<p>布隆过滤器的核心组成部分包括：</p>
<ul>
<li>位数组（Bit Array）：一个由二进制位（0或1）组成的数组，初始时所有位都设为0</li>
<li>哈希函数（Hash Functions）：多个不同的哈希函数，用于将元素映射到位数组的不同位置</li>
<li>误判率（False Positive Rate）：表示不在集合中的元素被误判为在集合中的概率</li>
</ul>
<h4 id="核心特性-27"><a href="#核心特性-27" class="headerlink" title="核心特性"></a>核心特性</h4><ol>
<li>高效的空间利用率：相比于传统的存储方式，布隆过滤器使用的空间非常小</li>
<li>常数时间复杂度：判断元素是否存在的操作时间复杂度为O(k)，k为哈希函数的个数，通常很小</li>
<li>可能存在误判：布隆过滤器可能会将不在集合中的元素误判为在集合中（假阳性），但不会将在集合中的元素误判为不在（没有假阴性）</li>
<li>不可移除元素：标准的布隆过滤器不支持删除元素的操作</li>
</ol>
<h4 id="基本操作-26"><a href="#基本操作-26" class="headerlink" title="基本操作"></a>基本操作</h4><p>布隆过滤器支持两种基本操作：</p>
<ol>
<li>添加元素（Add）：<ul>
<li>使用k个哈希函数计算元素的k个哈希值</li>
<li>将位数组中对应的k个位置设为1</li>
</ul>
</li>
<li>查询元素（Query）：<ul>
<li>使用k个哈希函数计算元素的k个哈希值</li>
<li>检查位数组中对应的k个位置是否都为1</li>
<li>如果都为1，返回”可能存在”；如果有一个不为1，返回”一定不存在”</li>
</ul>
</li>
</ol>
<h4 id="代码实现-23"><a href="#代码实现-23" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">import</span> java.util.BitSet;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BloomFilter</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> BitSet bitSet;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numberOfHashFunctions;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希函数数组</span></span><br><span class="line">    <span class="keyword">private</span> Function&lt;T, Integer&gt;[] hashFunctions;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BloomFilter</span><span class="params">(<span class="type">int</span> size, <span class="type">int</span> numberOfHashFunctions)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        <span class="built_in">this</span>.numberOfHashFunctions = numberOfHashFunctions;</span><br><span class="line">        <span class="built_in">this</span>.bitSet = <span class="keyword">new</span> <span class="title class_">BitSet</span>(size);</span><br><span class="line">        <span class="built_in">this</span>.hashFunctions = <span class="keyword">new</span> <span class="title class_">Function</span>[numberOfHashFunctions];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建多个哈希函数（这里用简单方式模拟多个哈希函数）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numberOfHashFunctions; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">seed</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            hashFunctions[i] = item -&gt; Math.abs((item.hashCode() * seed) % size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T item)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Function&lt;T, Integer&gt; hashFunction : hashFunctions) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hashFunction.apply(item);</span><br><span class="line">            bitSet.set(hash);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查询元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">mightContain</span><span class="params">(T item)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Function&lt;T, Integer&gt; hashFunction : hashFunctions) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hashFunction.apply(item);</span><br><span class="line">            <span class="keyword">if</span> (!bitSet.get(hash)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果有一个位是0，则元素一定不存在</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 所有位都是1，元素可能存在</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前设置为1的位的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBitCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bitSet.cardinality();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空过滤器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        bitSet.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 示例使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个大小为1000，使用3个哈希函数的布隆过滤器</span></span><br><span class="line">        BloomFilter&lt;String&gt; filter = <span class="keyword">new</span> <span class="title class_">BloomFilter</span>&lt;&gt;(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        filter.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        filter.add(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        filter.add(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 测试元素是否存在</span></span><br><span class="line">        System.out.println(<span class="string">&quot;apple 可能存在: &quot;</span> + filter.mightContain(<span class="string">&quot;apple&quot;</span>));    <span class="comment">// 应该返回 true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;banana 可能存在: &quot;</span> + filter.mightContain(<span class="string">&quot;banana&quot;</span>));  <span class="comment">// 应该返回 true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;grape 可能存在: &quot;</span> + filter.mightContain(<span class="string">&quot;grape&quot;</span>));    <span class="comment">// 很可能返回 false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<p>注意，在实际开发中我们一般不会自己实现布隆过滤器，而是使用一些工具包中提供的现成实现，这里上述的实现只是方便大家学习，所以可能并不够完善(比如哈希函数的设计)。</p>
<h4 id="优缺点-26"><a href="#优缺点-26" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点-17"><a href="#优点-17" class="headerlink" title="优点"></a>优点</h5><ol>
<li>空间效率高：相比于存储元素本身，布隆过滤器只需要很小的空间</li>
<li>查询速度快：O(k)的时间复杂度，k为哈希函数个数</li>
<li>隐私保护：不存储元素本身，只存储元素的哈希映射结果</li>
<li>适合处理大规模数据：当数据量巨大时，布隆过滤器的优势更加明显</li>
</ol>
<h5 id="缺点-16"><a href="#缺点-16" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>存在误判：可能会将不在集合中的元素误判为在集合中</li>
<li>不支持删除：标准布隆过滤器不支持删除元素（有计数布隆过滤器等变种可以支持）</li>
<li>需要预估数据量：需要在创建时预估元素数量和期望的误判率</li>
</ol>
<h4 id="应用场景-27"><a href="#应用场景-27" class="headerlink" title="应用场景"></a>应用场景</h4><p>布隆过滤器在很多领域都有广泛的应用：</p>
<ol>
<li>网络爬虫：用于检测URL是否已经被爬取过，避免重复爬取</li>
<li>数据库优化：在数据库查询前，使用布隆过滤器快速判断记录是否可能存在，减少不必要的磁盘访问</li>
<li>缓存穿透防护：判断一个key是否在缓存或数据库中存在，防止恶意请求大量不存在的key导致系统压力</li>
<li>网络安全：判断一个IP地址是否在黑名单中</li>
<li>推荐系统：快速判断用户是否已经看过某内容，避免重复推荐</li>
</ol>
<p>以缓存穿透防护为例，当有请求访问一个不存在的数据时，请求会先经过布隆过滤器的检查。如果布隆过滤器判断这个数据”一定不存在”，就可以直接返回”不存在”的结果，避免对缓存和数据库的无效查询，提高系统的性能和安全性。</p>
<h4 id="扩展：布隆过滤器的变种"><a href="#扩展：布隆过滤器的变种" class="headerlink" title="扩展：布隆过滤器的变种"></a>扩展：布隆过滤器的变种</h4><ol>
<li>计数布隆过滤器（Counting Bloom Filter）：为每个位置使用一个计数器而不是一个位，支持元素的删除操作</li>
<li>稳定布隆过滤器（Stable Bloom Filter）：随机重置部分计数器以保持误判率的稳定</li>
<li>可扩展布隆过滤器（Scalable Bloom Filter）：可以动态增长以适应更多的元素</li>
<li>布谷鸟过滤器（Cuckoo Filter）：布隆过滤器的一种替代方案，支持删除操作，并且可能具有更低的误判率</li>
</ol>
<h4 id="测验-27"><a href="#测验-27" class="headerlink" title="测验"></a>测验</h4><ol>
<li>如果布隆过滤器表明一个元素”可能存在”，这个元素一定在集合中吗？为什么？</li>
<li>如果布隆过滤器表明一个元素”一定不存在”，这个元素有可能在集合中吗？为什么？</li>
<li>当向布隆过滤器中添加更多的元素时，假阳性（误判）的概率会如何变化？为什么？</li>
<li>如果增加布隆过滤器中哈希函数的数量，会对过滤器的性能产生什么影响？</li>
<li>一个公司需要检查新用户注册的密码是否在常见密码列表中。该列表包含一百万个常见密码。你认为布隆过滤器适合这个场景吗？为什么？</li>
</ol>
<blockquote>
<p>测验答案</p>
<ol>
<li>不一定。布隆过滤器可能会有假阳性（误判），即它可能会将不在集合中的元素误判为在集合中。这是由于哈希冲突导致的。</li>
<li>不可能。如果布隆过滤器说元素”一定不存在”，那么这个元素确实不在集合中。布隆过滤器不会出现假阴性。</li>
<li>添加更多元素会增加假阳性的概率。因为随着添加的元素增多，位数组中被设置为1的位也会增多，导致哈希冲突的可能性增加。</li>
<li>增加哈希函数的数量会：降低假阳性率（因为需要更多的位都为1才会判定元素存在）；但会增加计算开销和内存访问次数；同时也会导致位数组中1的数量增加得更快。需要在准确性和性能之间找到平衡。</li>
<li>非常适合。理由：密码列表较大（一百万个）；只需要判断密码是否可能在列表中，允许少量误判；相比存储完整密码列表，布隆过滤器可以大大节省空间；密码检查需要快速响应；不需要删除操作。</li>
</ol>
</blockquote>
<h2 id="高级结构"><a href="#高级结构" class="headerlink" title="高级结构"></a>高级结构</h2><h3 id="一、并查集-Union-Find"><a href="#一、并查集-Union-Find" class="headerlink" title="一、并查集 (Union-Find)"></a>一、并查集 (Union-Find)</h3><p>并查集是一种树形数据结构，用于处理不相交集合的合并及查询问题，支持「查找」和「合并」两种操作，常用于解决连通性问题、最小生成树和动态连通性等问题。</p>
<h5 id="算法讲解-28"><a href="#算法讲解-28" class="headerlink" title="算法讲解"></a>算法讲解</h5><h4 id="并查集（Union-Find）"><a href="#并查集（Union-Find）" class="headerlink" title="并查集（Union-Find）"></a>并查集（Union-Find）</h4><h5 id="介绍-28"><a href="#介绍-28" class="headerlink" title="介绍"></a>介绍</h5><p>并查集是一种树形的数据结构，用于处理不相交集合（Disjoint Set）的合并及查询问题。它主要支持两种操作：</p>
<ol>
<li>查找（Find）：确定某个元素属于哪个集合</li>
<li>合并（Union）：将两个集合合并为一个集合</li>
</ol>
<p>名称”并查集”直接体现了它的核心功能：合并集合与查询元素所属集合。在英文中，它通常被称为”Union-Find”数据结构或”Disjoint-Set”数据结构。</p>
<p>并查集的基本思想是使用树形结构来表示每个集合，树的根节点作为集合的代表元素。</p>
<h4 id="核心特性-28"><a href="#核心特性-28" class="headerlink" title="核心特性"></a>核心特性</h4><ol>
<li>快速查找：能够快速判断两个元素是否属于同一集合</li>
<li>快速合并：能够快速将两个集合合并为一个</li>
<li>路径压缩：优化查找操作，使树的高度尽量小</li>
<li>按秩合并：优化合并操作，减少树的高度增长</li>
</ol>
<h4 id="基本操作-27"><a href="#基本操作-27" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="初始化（MakeSet）"><a href="#初始化（MakeSet）" class="headerlink" title="初始化（MakeSet）"></a>初始化（MakeSet）</h5><p>创建n个单元素集合，每个元素初始时都是独立的集合。</p>
<h5 id="查找（Find）"><a href="#查找（Find）" class="headerlink" title="查找（Find）"></a>查找（Find）</h5><p>查找元素所属的集合，通常是查找元素所在树的根节点。</p>
<h5 id="合并（Union）"><a href="#合并（Union）" class="headerlink" title="合并（Union）"></a>合并（Union）</h5><p>将两个集合合并为一个集合，通常是将一个集合的根节点连接到另一个集合的根节点上。</p>
<h4 id="代码实现-24"><a href="#代码实现-24" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent; <span class="comment">// 记录每个节点的父节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] rank;   <span class="comment">// 记录每个根节点对应树的高度</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始时，每个元素自成一个集合，父节点指向自己</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找操作（带路径压缩）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">            <span class="comment">// 路径压缩：将x的父节点直接设为根节点</span></span><br><span class="line">            parent[x] = find(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 合并操作（按秩合并）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootX</span> <span class="operator">=</span> find(x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootY</span> <span class="operator">=</span> find(y);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果已经在同一集合中，不需要合并</span></span><br><span class="line">        <span class="keyword">if</span> (rootX == rootY) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 按秩合并：将秩较小的树连接到秩较大的树下</span></span><br><span class="line">        <span class="keyword">if</span> (rank[rootX] &lt; rank[rootY]) &#123;</span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootX] &gt; rank[rootY]) &#123;</span><br><span class="line">            parent[rootY] = rootX;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 秩相同时，随便选一个作为根，并将新根的秩+1</span></span><br><span class="line">            parent[rootY] = rootX;</span><br><span class="line">            rank[rootX]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断两个元素是否在同一集合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<h4 id="优缺点-27"><a href="#优缺点-27" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点-18"><a href="#优点-18" class="headerlink" title="优点"></a>优点</h5><ol>
<li>查找和合并操作的平均时间复杂度接近O(1)</li>
<li>实现简单，易于理解</li>
<li>空间复杂度低，只需要两个数组</li>
<li>适用于处理大量动态连通性问题</li>
</ol>
<h5 id="缺点-17"><a href="#缺点-17" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>不支持分裂操作（将一个集合分成两个）</li>
<li>不方便查询集合中的所有元素</li>
<li>在某些特殊情况下，性能可能退化</li>
</ol>
<h4 id="应用场景-28"><a href="#应用场景-28" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="Kruskal最小生成树算法"><a href="#Kruskal最小生成树算法" class="headerlink" title="Kruskal最小生成树算法"></a>Kruskal最小生成树算法</h5><p>在Kruskal算法中，并查集是核心数据结构。该算法按权重从小到大遍历边，使用并查集判断加入某条边是否会形成环，从而高效构建最小生成树。</p>
<h5 id="网络连通性问题"><a href="#网络连通性问题" class="headerlink" title="网络连通性问题"></a>网络连通性问题</h5><p>并查集可高效解决动态连通性问题，比如判断网络中两个节点是否连通、社交网络中用户间的关系连接等。当关系变化时，只需执行简单的union操作，判断连通性时使用find操作即可。</p>
<h5 id="等价类划分"><a href="#等价类划分" class="headerlink" title="等价类划分"></a>等价类划分</h5><p>在编译器设计、电路分析等领域，并查集可用于等价类识别与合并。当系统发现两个元素等价时执行union操作，需要判断等价关系时使用find操作，这种动态维护等价关系的能力正是并查集的优势所在。</p>
<h5 id="判断无向图中的环"><a href="#判断无向图中的环" class="headerlink" title="判断无向图中的环"></a>判断无向图中的环</h5><p>当向无向图中添加边时，如果边的两个端点已在同一个集合中，则添加这条边会形成环。在很多图算法和网络设计问题中都可以使用这一特性。</p>
<h4 id="测验-28"><a href="#测验-28" class="headerlink" title="测验"></a>测验</h4><ol>
<li>并查集主要支持哪两种基本操作？</li>
<li>路径压缩指的是什么？它有什么好处？</li>
<li>在一个包含10个元素的并查集中，如果我们执行union(1,2), union(3,4), union(1,5), union(6,7), union(8,9), union(7,8)，最终会形成多少个不同的集合？</li>
<li>并查集的合并操作时间复杂度是多少？用了优化后的查询操作时间复杂度是多少？</li>
</ol>
<blockquote>
<p>测验答案</p>
<ol>
<li>查找（Find）和合并（Union）操作</li>
<li>路径压缩是在执行查找操作时，将查找路径上的所有节点都直接连接到根节点的优化技术。这样可以减少树的高度，加速后续的查找操作。</li>
<li>3个集合。分析：集合1包含元素{1,2,5}，集合2包含元素{3,4}，集合3包含元素{6,7,8,9,10}</li>
<li>合并操作的时间复杂度是O(α(n))，其中α(n)是阿克曼函数的反函数，实际使用中可以近似看作常数。使用路径压缩后的查询操作时间复杂度也是O(α(n))，近似常数。</li>
</ol>
</blockquote>
<h3 id="二、跳表-Skip-List"><a href="#二、跳表-Skip-List" class="headerlink" title="二、跳表 (Skip List)"></a>二、跳表 (Skip List)</h3><p>跳表是一种随机化的数据结构，基于链表实现，通过维护多层链表实现对有序链表的快速访问，平均查找、插入和删除时间复杂度均为O(log n)。跳表是对有序链表的一种优化，在链表的基础上，增加了多级索引，以空间换时间，使得操作效率接近二叉查找树。</p>
<h5 id="算法讲解-29"><a href="#算法讲解-29" class="headerlink" title="算法讲解"></a>算法讲解</h5><h4 id="跳表（Skip-List）"><a href="#跳表（Skip-List）" class="headerlink" title="跳表（Skip List）"></a>跳表（Skip List）</h4><h5 id="介绍-29"><a href="#介绍-29" class="headerlink" title="介绍"></a>介绍</h5><p>跳表是一种基于有序链表的数据结构，通过添加额外的”跳跃”链接，实现了对链表的快速查找。传统的有序链表查找需要从头开始一个一个节点遍历，时间复杂度为O(n)，而跳表通过构建多层索引，可以达到平均O(log n)的搜索效率，接近于二叉搜索树。</p>
<p>跳表的核心构想可以类比为图书馆的索引系统或多层电梯：</p>
<ul>
<li>底层链表：完整存储所有数据的有序链表</li>
<li>索引层：由底层链表中部分节点”提拔”形成的快速通道</li>
</ul>
<p>在跳表中，每个节点包含以下几个组成部分：</p>
<ul>
<li>值（value）：节点存储的数据</li>
<li>前进指针数组（forward array）：指向不同层级的后继节点</li>
<li>层高（level）：该节点的最大层级</li>
</ul>
<h4 id="核心特性-29"><a href="#核心特性-29" class="headerlink" title="核心特性"></a>核心特性</h4><ol>
<li>多层结构：由最底层的原始有序链表，以及若干层索引组成</li>
<li>概率平衡：通过随机函数决定节点的层数，无需复杂的平衡操作</li>
<li>快速查找：能够跳过大量节点，实现对数级别的查找效率</li>
<li>有序性：所有节点按关键字排序</li>
<li>空间换时间：使用额外的索引指针提高查询速度</li>
</ol>
<h4 id="基本操作-28"><a href="#基本操作-28" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="1-查找（Search）"><a href="#1-查找（Search）" class="headerlink" title="1. 查找（Search）"></a>1. 查找（Search）</h5><p>查找过程从最高层开始，沿着当前层前进，直到遇到大于或等于目标值的节点：</p>
<ol>
<li>如果找到目标值，返回该节点</li>
<li>如果当前节点的下一个值大于目标值，则降至下一层继续查找</li>
<li>如果到达最底层仍未找到，则目标值不存在</li>
</ol>
<h5 id="2-插入（Insert）"><a href="#2-插入（Insert）" class="headerlink" title="2. 插入（Insert）"></a>2. 插入（Insert）</h5><p>插入新节点的步骤：</p>
<ol>
<li>查找新值的插入位置，同时记录每一层的”插入点”</li>
<li>随机生成新节点的层高</li>
<li>从底层到该节点的最高层，逐层调整指针，将新节点插入到每层链表中</li>
</ol>
<h5 id="3-删除（Delete）"><a href="#3-删除（Delete）" class="headerlink" title="3. 删除（Delete）"></a>3. 删除（Delete）</h5><p>删除节点的步骤：</p>
<ol>
<li>查找待删除节点的位置，同时记录每一层的前驱节点</li>
<li>如果找到该节点，从该节点的最高层到底层，逐层调整前驱节点的指针，绕过待删除节点</li>
</ol>
<h4 id="代码实现-25"><a href="#代码实现-25" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SkipList</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_LEVEL</span> <span class="operator">=</span> <span class="number">16</span>; <span class="comment">// 最大层数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">P</span> <span class="operator">=</span> <span class="number">0.5</span>;     <span class="comment">// 提升层级的概率</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> level;                       <span class="comment">// 当前跳表的最大层数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;T&gt; header;            <span class="comment">// 头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random random;             <span class="comment">// 用于随机层数的生成</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点定义</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">        T value;                  <span class="comment">// 节点值</span></span><br><span class="line">        Node&lt;T&gt;[] forward;        <span class="comment">// 前进指针数组</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Node(T value, <span class="type">int</span> level) &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.forward = <span class="keyword">new</span> <span class="title class_">Node</span>[level + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SkipList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.level = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.header = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, MAX_LEVEL);</span><br><span class="line">        <span class="built_in">this</span>.random = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机生成层数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">randomLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lvl</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (lvl &lt; MAX_LEVEL &amp;&amp; random.nextDouble() &lt; P) &#123;</span><br><span class="line">            lvl++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lvl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找操作</span></span><br><span class="line">    <span class="keyword">public</span> Node&lt;T&gt; <span class="title function_">search</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        Node&lt;T&gt; current = header;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从最高层开始查找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> level; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 在当前层向前移动，直到找到大于等于目标值的节点</span></span><br><span class="line">            <span class="keyword">while</span> (current.forward[i] != <span class="literal">null</span> &amp;&amp; </span><br><span class="line">                   current.forward[i].value.compareTo(value) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                current = current.forward[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 现在我们在第0层，并且current是目标值的前一个节点</span></span><br><span class="line">        current = current.forward[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查是否找到目标值</span></span><br><span class="line">        <span class="keyword">if</span> (current != <span class="literal">null</span> &amp;&amp; current.value.compareTo(value) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Node&lt;T&gt;[] update = <span class="keyword">new</span> <span class="title class_">Node</span>[MAX_LEVEL + <span class="number">1</span>];</span><br><span class="line">        Node&lt;T&gt; current = header;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找插入位置并记录每层的前驱节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> level; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (current.forward[i] != <span class="literal">null</span> &amp;&amp; </span><br><span class="line">                   current.forward[i].value.compareTo(value) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                current = current.forward[i];</span><br><span class="line">            &#125;</span><br><span class="line">            update[i] = current;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取新节点的随机层数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newLevel</span> <span class="operator">=</span> randomLevel();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果新层数比当前跳表的最大层数大，更新跳表层数</span></span><br><span class="line">        <span class="keyword">if</span> (newLevel &gt; level) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> level + <span class="number">1</span>; i &lt;= newLevel; i++) &#123;</span><br><span class="line">                update[i] = header;</span><br><span class="line">            &#125;</span><br><span class="line">            level = newLevel;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建新节点</span></span><br><span class="line">        Node&lt;T&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(value, newLevel);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 插入节点到各层链表中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= newLevel; i++) &#123;</span><br><span class="line">            newNode.forward[i] = update[i].forward[i];</span><br><span class="line">            update[i].forward[i] = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Node&lt;T&gt;[] update = <span class="keyword">new</span> <span class="title class_">Node</span>[MAX_LEVEL + <span class="number">1</span>];</span><br><span class="line">        Node&lt;T&gt; current = header;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找删除位置并记录每层的前驱节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> level; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (current.forward[i] != <span class="literal">null</span> &amp;&amp; </span><br><span class="line">                   current.forward[i].value.compareTo(value) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                current = current.forward[i];</span><br><span class="line">            &#125;</span><br><span class="line">            update[i] = current;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        current = current.forward[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果找到节点，进行删除</span></span><br><span class="line">        <span class="keyword">if</span> (current != <span class="literal">null</span> &amp;&amp; current.value.compareTo(value) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= level; i++) &#123;</span><br><span class="line">                <span class="comment">// 如果当前层的前驱节点指向要删除的节点，则修改指针</span></span><br><span class="line">                <span class="keyword">if</span> (update[i].forward[i] == current) &#123;</span><br><span class="line">                    update[i].forward[i] = current.forward[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 更新跳表的最大层数</span></span><br><span class="line">            <span class="keyword">while</span> (level &gt; <span class="number">0</span> &amp;&amp; header.forward[level] == <span class="literal">null</span>) &#123;</span><br><span class="line">                level--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印跳表内容（用于调试）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printSkipList</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Skip List Structure:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> level; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;Level &quot;</span> + i + <span class="string">&quot;: &quot;</span>);</span><br><span class="line">            Node&lt;T&gt; node = header.forward[i];</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.print(node.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                node = node.forward[i];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳表节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SkipListNode</span> &#123;</span><br><span class="line">  constructor(value, level) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.forward = <span class="keyword">new</span> <span class="title class_">Array</span>(level + <span class="number">1</span>).fill(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="type">const</span> <span class="variable">skipList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SkipList</span>();</span><br><span class="line">skipList.insert(<span class="number">3</span>);</span><br><span class="line">skipList.insert(<span class="number">6</span>);</span><br><span class="line">skipList.insert(<span class="number">7</span>);</span><br><span class="line">console.log(skipList.search(<span class="number">6</span>)); <span class="comment">// true</span></span><br><span class="line">skipList.insert(<span class="number">9</span>);</span><br><span class="line">skipList.delete(<span class="number">6</span>);</span><br><span class="line">console.log(skipList.search(<span class="number">6</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://myj-2024.github.io">宇仔</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://myj-2024.github.io/2024/11/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">https://myj-2024.github.io/2024/11/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://myj-2024.github.io" target="_blank">宇仔的小破站</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></div><div class="post_share"><div class="social-share" data-image="https://img.picgo.net/2024/12/07/169_1_5b886d18-cb55-4030-8238-9c911a3b887dac464e01b8713ae4.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" media="print" onload="this.media='all'"><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/11/24/%E8%BF%9B%E9%98%B6%E7%AE%97%E6%B3%95/" title="进阶算法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picgo.net/2024/12/07/169_3_convert.io_1b1a0b531dd8e5437.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">进阶算法</div></div></a></div><div class="next-post pull-right"><a href="/2024/11/24/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/" title="算法复杂度"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picgo.net/2024/12/07/16.9_Still9a6c5cbb75130a12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">算法复杂度</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/11/24/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/" title="算法复杂度"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picgo.net/2024/12/07/16.9_Still9a6c5cbb75130a12.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-24</div><div class="title">算法复杂度</div></div></a></div><div><a href="/2024/11/24/%E8%BF%9B%E9%98%B6%E7%AE%97%E6%B3%95/" title="进阶算法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picgo.net/2024/12/07/169_3_convert.io_1b1a0b531dd8e5437.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-24</div><div class="title">进阶算法</div></div></a></div><div><a href="/2024/11/24/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" title="基础算法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picgo.net/2024/12/07/16_9_705655e0-03d6-4ba7-8b8c-ca3f2a81b3ac5ac2e8ae4394b197.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-24</div><div class="title">基础算法</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">宇仔</div><div class="author-info__description">一个喜欢折腾的小菜鸟</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Myj-2024"><i></i><span>🚀 前往小家...</span><i class="faa-passing animated" style="padding-left:20px;display:inline-block;vertical-align:middle;"><svg class="icon" style="height:28px;width:28px;fill:currentColor;position:relative;top:5px"><use xlink:href="#icon-xiaoqiche"></use></svg></i></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Myj-2024" target="_blank" title="Github"><i class="iconfont icon-github1"></i></a><a class="social-icon" href="mailto:3287456080@qq.com" target="_blank" title="Email"><i class="iconfont icon-youxiang"></i></a></div><div id="welcome-info"></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">宇仔的小破站</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">线性结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">一、数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">算法讲解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-Array"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">数组(Array)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0"><span class="toc-number">1.1.1.5.1.</span> <span class="toc-text">1. 访问元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%9B%B4%E6%96%B0%E5%85%83%E7%B4%A0"><span class="toc-number">1.1.1.5.2.</span> <span class="toc-text">2. 更新元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.1.5.3.</span> <span class="toc-text">3. 遍历数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%90%9C%E7%B4%A2%E5%85%83%E7%B4%A0"><span class="toc-number">1.1.1.5.4.</span> <span class="toc-text">4. 搜索元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E6%8F%92%E5%85%A5-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">1.1.1.5.5.</span> <span class="toc-text">5. 插入&#x2F;删除元素</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.1.6.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.1.1.7.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">1.1.1.7.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">1.1.1.7.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.1.1.8.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.1.9.</span> <span class="toc-text">扩展：动态数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9A%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.1.10.</span> <span class="toc-text">扩展：多维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.1.10.1.</span> <span class="toc-text">二维数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">1.1.1.10.2.</span> <span class="toc-text">内存布局</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.1.10.3.</span> <span class="toc-text">多维数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.1.1.10.4.</span> <span class="toc-text">多维数组的应用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C"><span class="toc-number">1.1.1.11.</span> <span class="toc-text">测验</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C%E7%AD%94%E6%A1%88"><span class="toc-number">1.1.1.11.1.</span> <span class="toc-text">测验答案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.1.2.</span> <span class="toc-text">二、字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3-1"><span class="toc-number">1.1.2.0.1.</span> <span class="toc-text">算法讲解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-String"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">字符串(String)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-1"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">1.1.2.6.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95"><span class="toc-number">1.1.2.7.</span> <span class="toc-text">扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#StringBuilder-vs-StringBuffer-vs-String"><span class="toc-number">1.1.2.7.1.</span> <span class="toc-text">StringBuilder vs StringBuffer vs String</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81"><span class="toc-number">1.1.2.7.2.</span> <span class="toc-text">字符串编码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A0%81%E6%AF%94%E8%BE%83"><span class="toc-number">1.1.2.7.3.</span> <span class="toc-text">常见编码比较</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C-1"><span class="toc-number">1.1.2.8.</span> <span class="toc-text">测验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">三、单向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3-2"><span class="toc-number">1.1.3.0.1.</span> <span class="toc-text">算法讲解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">单向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">1.1.3.1.1.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-2"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-1"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0-1"><span class="toc-number">1.1.3.3.1.</span> <span class="toc-text">1. 访问元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%9C%A8%E5%A4%B4%E9%83%A8%E6%8F%92%E5%85%A5"><span class="toc-number">1.1.3.3.2.</span> <span class="toc-text">2. 在头部插入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%9C%A8%E5%B0%BE%E9%83%A8%E6%8F%92%E5%85%A5"><span class="toc-number">1.1.3.3.3.</span> <span class="toc-text">3. 在尾部插入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%9C%A8%E4%B8%AD%E9%97%B4%E6%8F%92%E5%85%A5"><span class="toc-number">1.1.3.3.4.</span> <span class="toc-text">4. 在中间插入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-number">1.1.3.3.5.</span> <span class="toc-text">5. 删除节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0"><span class="toc-number">1.1.3.3.6.</span> <span class="toc-text">6. 查找元素</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="toc-number">1.1.3.5.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-2"><span class="toc-number">1.1.3.5.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="toc-number">1.1.3.5.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number">1.1.3.6.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9A%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%92%8C%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">1.1.3.7.</span> <span class="toc-text">扩展：双向链表和循环链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">1.1.3.7.1.</span> <span class="toc-text">双向链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">1.1.3.7.2.</span> <span class="toc-text">循环链表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C-2"><span class="toc-number">1.1.3.8.</span> <span class="toc-text">测验</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C%E7%AD%94%E6%A1%88-1"><span class="toc-number">1.1.3.8.1.</span> <span class="toc-text">测验答案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.1.4.</span> <span class="toc-text">四、双端队列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3-3"><span class="toc-number">1.1.4.0.1.</span> <span class="toc-text">算法讲解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97-Deque"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">双端队列(Deque)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-3"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-3"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-2"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%9C%A8%E5%89%8D%E7%AB%AF%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0-addFirst-offerFirst"><span class="toc-number">1.1.4.4.1.</span> <span class="toc-text">1. 在前端添加元素(addFirst&#x2F;offerFirst)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%9C%A8%E5%90%8E%E7%AB%AF%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0-addLast-offerLast"><span class="toc-number">1.1.4.4.2.</span> <span class="toc-text">2. 在后端添加元素(addLast&#x2F;offerLast)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BB%8E%E5%89%8D%E7%AB%AF%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0-removeFirst-pollFirst"><span class="toc-number">1.1.4.4.3.</span> <span class="toc-text">3. 从前端删除元素(removeFirst&#x2F;pollFirst)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E4%BB%8E%E5%90%8E%E7%AB%AF%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0-removeLast-pollLast"><span class="toc-number">1.1.4.4.4.</span> <span class="toc-text">4. 从后端删除元素(removeLast&#x2F;pollLast)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E6%9F%A5%E7%9C%8B%E5%89%8D%E7%AB%AF%E5%85%83%E7%B4%A0-getFirst-peekFirst"><span class="toc-number">1.1.4.4.5.</span> <span class="toc-text">5. 查看前端元素(getFirst&#x2F;peekFirst)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E6%9F%A5%E7%9C%8B%E5%90%8E%E7%AB%AF%E5%85%83%E7%B4%A0-getLast-peekLast"><span class="toc-number">1.1.4.4.6.</span> <span class="toc-text">6. 查看后端元素(getLast&#x2F;peekLast)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E6%A3%80%E6%9F%A5%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA-isEmpty"><span class="toc-number">1.1.4.4.7.</span> <span class="toc-text">7. 检查队列是否为空(isEmpty)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">1.1.4.5.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-2"><span class="toc-number">1.1.4.6.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-3"><span class="toc-number">1.1.4.6.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-2"><span class="toc-number">1.1.4.6.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="toc-number">1.1.4.7.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9A%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.4.8.</span> <span class="toc-text">扩展：双端队列的实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.4.8.1.</span> <span class="toc-text">1. 基于数组的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%9F%BA%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.4.8.2.</span> <span class="toc-text">2. 基于链表的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%B7%B7%E5%90%88%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.4.8.3.</span> <span class="toc-text">3. 混合实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C-3"><span class="toc-number">1.1.4.9.</span> <span class="toc-text">测验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">1.1.5.</span> <span class="toc-text">五、双向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3-4"><span class="toc-number">1.1.5.0.1.</span> <span class="toc-text">算法讲解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-Doubly-Linked-List"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">双向链表(Doubly Linked List)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-4"><span class="toc-number">1.1.5.1.1.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-4"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-3"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0-2"><span class="toc-number">1.1.5.3.1.</span> <span class="toc-text">1. 访问元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.5.3.2.</span> <span class="toc-text">2. 插入操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.5.3.3.</span> <span class="toc-text">3. 删除操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0"><span class="toc-number">1.1.5.3.4.</span> <span class="toc-text">4. 查找元素</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">1.1.5.4.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-3"><span class="toc-number">1.1.5.5.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-4"><span class="toc-number">1.1.5.5.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-3"><span class="toc-number">1.1.5.5.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-4"><span class="toc-number">1.1.5.6.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9A%E5%BE%AA%E7%8E%AF%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">1.1.5.7.</span> <span class="toc-text">扩展：循环双向链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C-4"><span class="toc-number">1.1.5.8.</span> <span class="toc-text">测验</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C%E7%AD%94%E6%A1%88-2"><span class="toc-number">1.1.5.8.1.</span> <span class="toc-text">测验答案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%A0%88"><span class="toc-number">1.1.6.</span> <span class="toc-text">六、栈</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3-5"><span class="toc-number">1.1.6.0.1.</span> <span class="toc-text">算法讲解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88-Stack"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">栈(Stack)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-5"><span class="toc-number">1.1.6.1.1.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-5"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-4"><span class="toc-number">1.1.6.3.</span> <span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%85%A5%E6%A0%88-push"><span class="toc-number">1.1.6.3.1.</span> <span class="toc-text">1. 入栈(push)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%87%BA%E6%A0%88-pop"><span class="toc-number">1.1.6.3.2.</span> <span class="toc-text">2. 出栈(pop)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%9F%A5%E7%9C%8B%E6%A0%88%E9%A1%B6-peek"><span class="toc-number">1.1.6.3.3.</span> <span class="toc-text">3. 查看栈顶(peek)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%88%A4%E6%96%AD%E6%A0%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA-isEmpty"><span class="toc-number">1.1.6.3.4.</span> <span class="toc-text">4. 判断栈是否为空(isEmpty)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E8%8E%B7%E5%8F%96%E6%A0%88%E5%A4%A7%E5%B0%8F-size"><span class="toc-number">1.1.6.3.5.</span> <span class="toc-text">5. 获取栈大小(size)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-5"><span class="toc-number">1.1.6.4.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-4"><span class="toc-number">1.1.6.5.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-5"><span class="toc-number">1.1.6.5.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-4"><span class="toc-number">1.1.6.5.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-5"><span class="toc-number">1.1.6.6.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9A%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">1.1.6.7.</span> <span class="toc-text">扩展：单调栈</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.1.6.7.1.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C-5"><span class="toc-number">1.1.6.8.</span> <span class="toc-text">测验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E9%98%9F%E5%88%97"><span class="toc-number">1.1.7.</span> <span class="toc-text">七、队列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3-6"><span class="toc-number">1.1.7.0.1.</span> <span class="toc-text">算法讲解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97-Queue"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">队列(Queue)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-6"><span class="toc-number">1.1.7.1.1.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-6"><span class="toc-number">1.1.7.2.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-5"><span class="toc-number">1.1.7.3.</span> <span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%85%A5%E9%98%9F-enqueue"><span class="toc-number">1.1.7.3.1.</span> <span class="toc-text">1. 入队(enqueue)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%87%BA%E9%98%9F-dequeue"><span class="toc-number">1.1.7.3.2.</span> <span class="toc-text">2. 出队(dequeue)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%9F%A5%E7%9C%8B%E9%98%9F%E5%A4%B4-peek-front"><span class="toc-number">1.1.7.3.3.</span> <span class="toc-text">3. 查看队头(peek&#x2F;front)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%88%A4%E6%96%AD%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA-isEmpty"><span class="toc-number">1.1.7.3.4.</span> <span class="toc-text">4. 判断队列是否为空(isEmpty)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E8%8E%B7%E5%8F%96%E9%98%9F%E5%88%97%E5%A4%A7%E5%B0%8F-size"><span class="toc-number">1.1.7.3.5.</span> <span class="toc-text">5. 获取队列大小(size)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-6"><span class="toc-number">1.1.7.4.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-5"><span class="toc-number">1.1.7.5.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-6"><span class="toc-number">1.1.7.5.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-5"><span class="toc-number">1.1.7.5.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-6"><span class="toc-number">1.1.7.6.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C-6"><span class="toc-number">1.1.7.7.</span> <span class="toc-text">测验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9%E6%98%AF%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA-FIFO-%EF%BC%8C%E5%8D%B3%E6%9C%80%E5%85%88%E5%85%A5%E9%98%9F%E7%9A%84%E5%85%83%E7%B4%A0%E6%9C%80%E5%85%88%E5%87%BA%E9%98%9F%E3%80%82"><span class="toc-number">1.1.7.8.</span> <span class="toc-text">队列的主要特点是先进先出(FIFO)，即最先入队的元素最先出队。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.1.8.</span> <span class="toc-text">八、循环队列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3-7"><span class="toc-number">1.1.8.0.1.</span> <span class="toc-text">算法讲解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97-Circular-Queue"><span class="toc-number">1.1.8.1.</span> <span class="toc-text">循环队列(Circular Queue)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-7"><span class="toc-number">1.1.8.1.1.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-7"><span class="toc-number">1.1.8.2.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-6"><span class="toc-number">1.1.8.3.</span> <span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%85%A5%E9%98%9F-enqueue-1"><span class="toc-number">1.1.8.3.1.</span> <span class="toc-text">1. 入队(enqueue)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%87%BA%E9%98%9F-dequeue-1"><span class="toc-number">1.1.8.3.2.</span> <span class="toc-text">2. 出队(dequeue)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%9F%A5%E7%9C%8B%E9%98%9F%E5%A4%B4-peek-front-1"><span class="toc-number">1.1.8.3.3.</span> <span class="toc-text">3. 查看队头(peek&#x2F;front)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%88%A4%E6%96%AD%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA-isEmpty-1"><span class="toc-number">1.1.8.3.4.</span> <span class="toc-text">4. 判断队列是否为空(isEmpty)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%88%A4%E6%96%AD%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E5%B7%B2%E6%BB%A1-isFull"><span class="toc-number">1.1.8.3.5.</span> <span class="toc-text">5. 判断队列是否已满(isFull)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-7"><span class="toc-number">1.1.8.4.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-6"><span class="toc-number">1.1.8.5.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-7"><span class="toc-number">1.1.8.5.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-6"><span class="toc-number">1.1.8.5.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-7"><span class="toc-number">1.1.8.6.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C-7"><span class="toc-number">1.1.8.7.</span> <span class="toc-text">测验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-number">1.1.9.</span> <span class="toc-text">九、优先队列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3-8"><span class="toc-number">1.1.9.0.1.</span> <span class="toc-text">算法讲解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-Priority-Queue"><span class="toc-number">1.1.9.1.</span> <span class="toc-text">优先队列(Priority Queue)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-8"><span class="toc-number">1.1.9.1.1.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-8"><span class="toc-number">1.1.9.2.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-7"><span class="toc-number">1.1.9.3.</span> <span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A5%E9%98%9F-enqueue-insert"><span class="toc-number">1.1.9.3.1.</span> <span class="toc-text">入队(enqueue&#x2F;insert)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BA%E9%98%9F-dequeue-extractMax-extractMin"><span class="toc-number">1.1.9.3.2.</span> <span class="toc-text">出队(dequeue&#x2F;extractMax&#x2F;extractMin)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E9%A1%B6%E9%83%A8%E5%85%83%E7%B4%A0-peek-top"><span class="toc-number">1.1.9.3.3.</span> <span class="toc-text">查看顶部元素(peek&#x2F;top)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA-isEmpty"><span class="toc-number">1.1.9.3.4.</span> <span class="toc-text">判断队列是否为空(isEmpty)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%98%9F%E5%88%97%E5%A4%A7%E5%B0%8F-size"><span class="toc-number">1.1.9.3.5.</span> <span class="toc-text">获取队列大小(size)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-8"><span class="toc-number">1.1.9.4.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-7"><span class="toc-number">1.1.9.5.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-8"><span class="toc-number">1.1.9.5.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-7"><span class="toc-number">1.1.9.5.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-8"><span class="toc-number">1.1.9.6.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C-8"><span class="toc-number">1.1.9.7.</span> <span class="toc-text">测验</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">树形结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.1.</span> <span class="toc-text">一、二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3-9"><span class="toc-number">1.2.1.0.1.</span> <span class="toc-text">算法讲解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91-Binary-Tree"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">二叉树(Binary Tree)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-9"><span class="toc-number">1.2.1.1.1.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-9"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-8"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.1.3.1.</span> <span class="toc-text">1. 创建二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.1.3.2.</span> <span class="toc-text">2. 遍历二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9"><span class="toc-number">1.2.1.3.3.</span> <span class="toc-text">3. 查找节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9"><span class="toc-number">1.2.1.3.4.</span> <span class="toc-text">4. 插入节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9-1"><span class="toc-number">1.2.1.3.5.</span> <span class="toc-text">5. 删除节点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-9"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Java-%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.1.4.1.</span> <span class="toc-text">Java 实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-8"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-9"><span class="toc-number">1.2.1.6.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.2.1.7.</span> <span class="toc-text">扩展：二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.1.7.1.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C-9"><span class="toc-number">1.2.1.8.</span> <span class="toc-text">测验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81AVL%E6%A0%91"><span class="toc-number">1.2.2.</span> <span class="toc-text">二、AVL树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3-10"><span class="toc-number">1.2.2.0.1.</span> <span class="toc-text">算法讲解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AVL%E6%A0%91-AVL-Tree"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">AVL树(AVL Tree)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-10"><span class="toc-number">1.2.2.1.1.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-10"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-9"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0"><span class="toc-number">1.2.2.3.1.</span> <span class="toc-text">1. 查找元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0"><span class="toc-number">1.2.2.3.2.</span> <span class="toc-text">2. 插入元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">1.2.2.3.3.</span> <span class="toc-text">3. 删除元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%97%8B%E8%BD%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.2.3.4.</span> <span class="toc-text">4. 旋转操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-10"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-9"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-9"><span class="toc-number">1.2.2.5.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-8"><span class="toc-number">1.2.2.5.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-10"><span class="toc-number">1.2.2.6.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C-10"><span class="toc-number">1.2.2.7.</span> <span class="toc-text">测验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">1.2.3.</span> <span class="toc-text">三、红黑树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3-11"><span class="toc-number">1.2.3.0.1.</span> <span class="toc-text">算法讲解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91-Red-Black-Tree"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">红黑树(Red-Black Tree)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-11"><span class="toc-number">1.2.3.1.1.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-11"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-10"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0-1"><span class="toc-number">1.2.3.3.1.</span> <span class="toc-text">1. 查找元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0-1"><span class="toc-number">1.2.3.3.2.</span> <span class="toc-text">2. 插入元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0-1"><span class="toc-number">1.2.3.3.3.</span> <span class="toc-text">3. 删除元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E4%BF%AE%E5%A4%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.3.3.4.</span> <span class="toc-text">4. 修复操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-11"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-10"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-10"><span class="toc-number">1.2.3.5.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-9"><span class="toc-number">1.2.3.5.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-11"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9A%E4%B8%8EAVL%E6%A0%91%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.2.3.7.</span> <span class="toc-text">扩展：与AVL树的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C-11"><span class="toc-number">1.2.3.8.</span> <span class="toc-text">测验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.2.4.</span> <span class="toc-text">四、二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3-12"><span class="toc-number">1.2.4.0.1.</span> <span class="toc-text">算法讲解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-12"><span class="toc-number">1.2.4.1.1.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-12"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-11"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.4.3.1.</span> <span class="toc-text">查找操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.4.3.2.</span> <span class="toc-text">插入操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.4.3.3.</span> <span class="toc-text">删除操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-12"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-11"><span class="toc-number">1.2.4.5.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-11"><span class="toc-number">1.2.4.5.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-10"><span class="toc-number">1.2.4.5.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9A%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.2.4.6.</span> <span class="toc-text">扩展：自平衡二叉搜索树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C-12"><span class="toc-number">1.2.4.7.</span> <span class="toc-text">测验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%BA%8C%E5%8F%89%E5%A0%86"><span class="toc-number">1.2.5.</span> <span class="toc-text">五、二叉堆</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3-13"><span class="toc-number">1.2.5.0.1.</span> <span class="toc-text">算法讲解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E5%A0%86"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">二叉堆</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-13"><span class="toc-number">1.2.5.1.1.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-13"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-12"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0%EF%BC%88Insert%EF%BC%89"><span class="toc-number">1.2.5.3.1.</span> <span class="toc-text">插入元素（Insert）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%A1%B6%E9%83%A8%E5%85%83%E7%B4%A0%EF%BC%88Extract-Max-Min%EF%BC%89"><span class="toc-number">1.2.5.3.2.</span> <span class="toc-text">删除顶部元素（Extract-Max&#x2F;Min）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8A%E6%B5%AE%EF%BC%88Heapify-Up%EF%BC%89"><span class="toc-number">1.2.5.3.3.</span> <span class="toc-text">上浮（Heapify-Up）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8B%E6%B2%89%EF%BC%88Heapify-Down%EF%BC%89"><span class="toc-number">1.2.5.3.4.</span> <span class="toc-text">下沉（Heapify-Down）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-13"><span class="toc-number">1.2.5.4.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-12"><span class="toc-number">1.2.5.5.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-12"><span class="toc-number">1.2.5.5.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-11"><span class="toc-number">1.2.5.5.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-12"><span class="toc-number">1.2.5.6.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95-1"><span class="toc-number">1.2.5.7.</span> <span class="toc-text">扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Java%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84%E5%A0%86%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.5.7.1.</span> <span class="toc-text">Java标准库中的堆实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E5%8F%98%E7%A7%8D"><span class="toc-number">1.2.5.7.2.</span> <span class="toc-text">堆的变种</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C-13"><span class="toc-number">1.2.5.8.</span> <span class="toc-text">测验</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C%E7%AD%94%E6%A1%88-3"><span class="toc-number">1.2.5.8.1.</span> <span class="toc-text">测验答案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81B%E6%A0%91"><span class="toc-number">1.2.6.</span> <span class="toc-text">六、B树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3-14"><span class="toc-number">1.2.6.0.1.</span> <span class="toc-text">算法讲解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B%E6%A0%91%E6%95%99%E7%A8%8B"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">B树教程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-14"><span class="toc-number">1.2.6.1.1.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-14"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-13"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.6.3.1.</span> <span class="toc-text">搜索操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C-1"><span class="toc-number">1.2.6.3.2.</span> <span class="toc-text">插入操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-1"><span class="toc-number">1.2.6.3.3.</span> <span class="toc-text">删除操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-13"><span class="toc-number">1.2.6.4.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-13"><span class="toc-number">1.2.6.4.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-12"><span class="toc-number">1.2.6.4.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-13"><span class="toc-number">1.2.6.5.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9AB%E6%A0%91%E7%9A%84%E5%8F%98%E7%A7%8D"><span class="toc-number">1.2.6.6.</span> <span class="toc-text">扩展：B树的变种</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E6%A0%91"><span class="toc-number">1.2.6.6.1.</span> <span class="toc-text">B+树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E6%A0%91-1"><span class="toc-number">1.2.6.6.2.</span> <span class="toc-text">B*树</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C-14"><span class="toc-number">1.2.6.7.</span> <span class="toc-text">测验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81B-%E6%A0%91"><span class="toc-number">1.2.7.</span> <span class="toc-text">七、B+树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3-15"><span class="toc-number">1.2.7.0.1.</span> <span class="toc-text">算法讲解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%A0%91-2"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">B+树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-15"><span class="toc-number">1.2.7.1.1.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-15"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-14"><span class="toc-number">1.2.7.3.</span> <span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C-1"><span class="toc-number">1.2.7.3.1.</span> <span class="toc-text">查找操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C-2"><span class="toc-number">1.2.7.3.2.</span> <span class="toc-text">插入操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-2"><span class="toc-number">1.2.7.3.3.</span> <span class="toc-text">删除操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-14"><span class="toc-number">1.2.7.4.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-14"><span class="toc-number">1.2.7.4.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-13"><span class="toc-number">1.2.7.4.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-14"><span class="toc-number">1.2.7.5.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C-15"><span class="toc-number">1.2.7.6.</span> <span class="toc-text">测验</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C%E7%AD%94%E6%A1%88-4"><span class="toc-number">1.2.7.6.1.</span> <span class="toc-text">测验答案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81Trie%E6%A0%91%EF%BC%88%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%89"><span class="toc-number">1.2.8.</span> <span class="toc-text">八、Trie树（字典树）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3-16"><span class="toc-number">1.2.8.0.1.</span> <span class="toc-text">算法讲解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Trie%E6%A0%91"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">Trie树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-16"><span class="toc-number">1.2.8.1.1.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-16"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-15"><span class="toc-number">1.2.8.3.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-14"><span class="toc-number">1.2.8.4.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-15"><span class="toc-number">1.2.8.5.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-15"><span class="toc-number">1.2.8.5.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-14"><span class="toc-number">1.2.8.5.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-15"><span class="toc-number">1.2.8.6.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C-16"><span class="toc-number">1.2.8.7.</span> <span class="toc-text">测验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.9.</span> <span class="toc-text">九、树状数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3-17"><span class="toc-number">1.2.9.0.1.</span> <span class="toc-text">算法讲解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%88Binary-Indexed-Tree%EF%BC%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.9.1.</span> <span class="toc-text">树状数组（Binary Indexed Tree）数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.9.2.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.9.3.</span> <span class="toc-text">存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.9.4.</span> <span class="toc-text">核心操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C%EF%BC%88update%EF%BC%89"><span class="toc-number">1.2.9.4.1.</span> <span class="toc-text">1. 更新操作（update）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%9F%A5%E8%AF%A2%E5%89%8D%E7%BC%80%E5%92%8C%EF%BC%88query%EF%BC%89"><span class="toc-number">1.2.9.4.2.</span> <span class="toc-text">2. 查询前缀和（query）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.2.9.5.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-16"><span class="toc-number">1.2.9.6.</span> <span class="toc-text">应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">1.2.9.6.1.</span> <span class="toc-text">树状数组的优势</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9A%E5%8C%BA%E9%97%B4%E6%9B%B4%E6%96%B0"><span class="toc-number">1.2.9.7.</span> <span class="toc-text">扩展：区间更新</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.9.7.1.</span> <span class="toc-text">使用示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">1.2.10.</span> <span class="toc-text">十、线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3-18"><span class="toc-number">1.2.10.0.1.</span> <span class="toc-text">算法讲解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%88Segment-Tree%EF%BC%89"><span class="toc-number">1.2.10.1.</span> <span class="toc-text">线段树（Segment Tree）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-17"><span class="toc-number">1.2.10.1.1.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-17"><span class="toc-number">1.2.10.2.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-16"><span class="toc-number">1.2.10.3.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-15"><span class="toc-number">1.2.10.4.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.10.5.</span> <span class="toc-text">线段树的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-16"><span class="toc-number">1.2.10.6.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-16"><span class="toc-number">1.2.10.6.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-15"><span class="toc-number">1.2.10.6.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-17"><span class="toc-number">1.2.10.7.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95-2"><span class="toc-number">1.2.10.8.</span> <span class="toc-text">扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">1.2.10.8.1.</span> <span class="toc-text">动态线段树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%88Persistent-Segment-Tree%EF%BC%89"><span class="toc-number">1.2.10.8.2.</span> <span class="toc-text">可持久化线段树（Persistent Segment Tree）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C-17"><span class="toc-number">1.2.10.9.</span> <span class="toc-text">测验</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">图结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%BE%B9%E5%88%97%E8%A1%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">一、边列表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3-19"><span class="toc-number">1.3.1.0.1.</span> <span class="toc-text">算法讲解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9%E5%88%97%E8%A1%A8"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">边列表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-18"><span class="toc-number">1.3.1.1.1.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-18"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-17"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-16"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-17"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">1.3.1.6.1.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">1.3.1.6.2.</span> <span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-18"><span class="toc-number">1.3.1.7.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C-18"><span class="toc-number">1.3.1.8.</span> <span class="toc-text">测验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%9C%89%E5%90%91%E5%9B%BE"><span class="toc-number">1.3.2.</span> <span class="toc-text">二、有向图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3-20"><span class="toc-number">1.3.2.0.1.</span> <span class="toc-text">算法讲解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">有向图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-19"><span class="toc-number">1.3.2.1.1.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-19"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-18"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-17"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-18"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-1"><span class="toc-number">1.3.2.5.1.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-1"><span class="toc-number">1.3.2.5.2.</span> <span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-19"><span class="toc-number">1.3.2.6.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95-3"><span class="toc-number">1.3.2.7.</span> <span class="toc-text">扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE-DAG"><span class="toc-number">1.3.2.7.1.</span> <span class="toc-text">有向无环图(DAG)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="toc-number">1.3.2.7.2.</span> <span class="toc-text">强连通分量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C-19"><span class="toc-number">1.3.2.8.</span> <span class="toc-text">测验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%97%A0%E5%90%91%E5%9B%BE"><span class="toc-number">1.3.3.</span> <span class="toc-text">三、无向图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3-21"><span class="toc-number">1.3.3.0.1.</span> <span class="toc-text">算法讲解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">无向图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-20"><span class="toc-number">1.3.3.1.1.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-20"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-19"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-18"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-19"><span class="toc-number">1.3.3.5.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-2"><span class="toc-number">1.3.3.5.1.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-2"><span class="toc-number">1.3.3.5.2.</span> <span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-20"><span class="toc-number">1.3.3.6.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95-4"><span class="toc-number">1.3.3.7.</span> <span class="toc-text">扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.3.3.7.1.</span> <span class="toc-text">最小生成树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="toc-number">1.3.3.7.2.</span> <span class="toc-text">无向图的连通分量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C-20"><span class="toc-number">1.3.3.8.</span> <span class="toc-text">测验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%8A%A0%E6%9D%83%E5%9B%BE"><span class="toc-number">1.3.4.</span> <span class="toc-text">四、加权图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E6%9D%83%E5%9B%BE"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">加权图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-21"><span class="toc-number">1.3.4.1.1.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-21"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-20"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-19"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-20"><span class="toc-number">1.3.4.5.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-3"><span class="toc-number">1.3.4.5.1.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-3"><span class="toc-number">1.3.4.5.2.</span> <span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-21"><span class="toc-number">1.3.4.6.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95-5"><span class="toc-number">1.3.4.7.</span> <span class="toc-text">扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.4.7.1.</span> <span class="toc-text">最短路径算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.4.7.2.</span> <span class="toc-text">最小生成树算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C-21"><span class="toc-number">1.3.4.8.</span> <span class="toc-text">测验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81-%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE"><span class="toc-number">1.3.5.</span> <span class="toc-text">五、 有向无环图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3-22"><span class="toc-number">1.3.5.0.1.</span> <span class="toc-text">算法讲解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">有向无环图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-22"><span class="toc-number">1.3.5.1.1.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-22"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-21"><span class="toc-number">1.3.5.3.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-20"><span class="toc-number">1.3.5.4.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-21"><span class="toc-number">1.3.5.5.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-4"><span class="toc-number">1.3.5.5.1.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-4"><span class="toc-number">1.3.5.5.2.</span> <span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-22"><span class="toc-number">1.3.5.6.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C-22"><span class="toc-number">1.3.5.7.</span> <span class="toc-text">测验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">1.3.6.</span> <span class="toc-text">六、邻接矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3-23"><span class="toc-number">1.3.6.0.1.</span> <span class="toc-text">算法讲解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">邻接矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-23"><span class="toc-number">1.3.6.1.1.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="toc-number">1.3.6.2.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%A8%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%AD%EF%BC%9A"><span class="toc-number">1.3.6.2.0.1.</span> <span class="toc-text">在邻接矩阵中：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%AD%EF%BC%9A"><span class="toc-number">1.3.6.2.0.2.</span> <span class="toc-text">无向图中：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E4%B8%AD%EF%BC%9A"><span class="toc-number">1.3.6.2.0.3.</span> <span class="toc-text">有向图中：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-23"><span class="toc-number">1.3.6.3.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-22"><span class="toc-number">1.3.6.4.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-21"><span class="toc-number">1.3.6.5.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-22"><span class="toc-number">1.3.6.6.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-5"><span class="toc-number">1.3.6.6.1.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-5"><span class="toc-number">1.3.6.6.2.</span> <span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-23"><span class="toc-number">1.3.6.7.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95-6"><span class="toc-number">1.3.6.8.</span> <span class="toc-text">扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.6.8.1.</span> <span class="toc-text">邻接矩阵的优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E7%A7%8D%EF%BC%9A%E5%85%B3%E8%81%94%E7%9F%A9%E9%98%B5"><span class="toc-number">1.3.6.8.2.</span> <span class="toc-text">变种：关联矩阵</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C-23"><span class="toc-number">1.3.6.9.</span> <span class="toc-text">测验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">1.3.7.</span> <span class="toc-text">七、邻接表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3-24"><span class="toc-number">1.3.7.0.1.</span> <span class="toc-text">算法讲解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">1.3.7.1.</span> <span class="toc-text">邻接表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-24"><span class="toc-number">1.3.7.2.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="toc-number">1.3.7.3.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-24"><span class="toc-number">1.3.7.4.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-23"><span class="toc-number">1.3.7.5.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-22"><span class="toc-number">1.3.7.6.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-23"><span class="toc-number">1.3.7.7.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-6"><span class="toc-number">1.3.7.7.1.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-6"><span class="toc-number">1.3.7.7.2.</span> <span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-24"><span class="toc-number">1.3.7.8.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95-7"><span class="toc-number">1.3.7.9.</span> <span class="toc-text">扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E4%BC%98%E5%8C%96%E4%B8%8E%E5%8F%98%E4%BD%93"><span class="toc-number">1.3.7.10.</span> <span class="toc-text">邻接表的优化与变体</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">1.3.7.10.0.1.</span> <span class="toc-text">反向邻接表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">1.3.7.10.0.2.</span> <span class="toc-text">压缩邻接表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.7.11.</span> <span class="toc-text">高级应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.3.7.11.1.</span> <span class="toc-text">复杂路径查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BA%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">1.3.7.11.2.</span> <span class="toc-text">增强邻接表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83%E9%80%89%E6%8B%A9"><span class="toc-number">1.3.7.11.3.</span> <span class="toc-text">与其他表示方法的比较选择</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%95%88%E7%8E%87%E8%80%83%E8%99%91"><span class="toc-number">1.3.7.11.4.</span> <span class="toc-text">内存效率考虑</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C-24"><span class="toc-number">1.3.7.12.</span> <span class="toc-text">测验</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E4%B8%8E%E6%98%A0%E5%B0%84"><span class="toc-number">1.4.</span> <span class="toc-text">哈希与映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%88%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95%EF%BC%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">一、哈希表（链地址法）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3-25"><span class="toc-number">1.4.1.0.1.</span> <span class="toc-text">算法讲解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%88%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95%EF%BC%89"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">哈希表（链地址法）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-25"><span class="toc-number">1.4.1.1.1.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-3"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-25"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-24"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.1.5.</span> <span class="toc-text">基础实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-24"><span class="toc-number">1.4.1.6.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-7"><span class="toc-number">1.4.1.6.1.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-7"><span class="toc-number">1.4.1.6.2.</span> <span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-25"><span class="toc-number">1.4.1.7.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95-8"><span class="toc-number">1.4.1.8.</span> <span class="toc-text">扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96%E4%B8%8E%E5%8F%98%E4%BD%93"><span class="toc-number">1.4.1.8.1.</span> <span class="toc-text">链地址法的优化与变体</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.1.8.1.1.</span> <span class="toc-text">改进链表结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A1%B6%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96"><span class="toc-number">1.4.1.8.1.2.</span> <span class="toc-text">桶大小优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C-25"><span class="toc-number">1.4.1.9.</span> <span class="toc-text">测验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%88%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80%E6%B3%95%EF%BC%89"><span class="toc-number">1.4.2.</span> <span class="toc-text">二、哈希表（开放寻址法）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3-26"><span class="toc-number">1.4.2.0.1.</span> <span class="toc-text">算法讲解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%88%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80%E6%B3%95%EF%BC%89"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">哈希表（开放寻址法）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-26"><span class="toc-number">1.4.2.1.1.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-4"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-26"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-25"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">基础实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-25"><span class="toc-number">1.4.2.6.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-8"><span class="toc-number">1.4.2.6.1.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-8"><span class="toc-number">1.4.2.6.2.</span> <span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-26"><span class="toc-number">1.4.2.7.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95-9"><span class="toc-number">1.4.2.8.</span> <span class="toc-text">扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8F%98%E7%A7%8D%E4%B8%8E%E6%94%B9%E8%BF%9B"><span class="toc-number">1.4.2.8.1.</span> <span class="toc-text">常见的变种与改进</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">1.4.2.8.1.1.</span> <span class="toc-text">线性探测的改进</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E7%AD%96%E7%95%A5"><span class="toc-number">1.4.2.8.1.2.</span> <span class="toc-text">混合策略</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E8%80%83%E9%87%8F"><span class="toc-number">1.4.2.9.</span> <span class="toc-text">实际应用中的考量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A3%85%E8%BD%BD%E5%9B%A0%E5%AD%90%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">1.4.2.9.1.</span> <span class="toc-text">装载因子的选择</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C-26"><span class="toc-number">1.4.2.10.</span> <span class="toc-text">测验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">1.4.3.</span> <span class="toc-text">三、布隆过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3-27"><span class="toc-number">1.4.3.0.1.</span> <span class="toc-text">算法讲解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E6%95%99%E7%A8%8B"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">布隆过滤器教程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-27"><span class="toc-number">1.4.3.1.1.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-27"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-26"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-23"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-26"><span class="toc-number">1.4.3.5.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-17"><span class="toc-number">1.4.3.5.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-16"><span class="toc-number">1.4.3.5.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-27"><span class="toc-number">1.4.3.6.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9A%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%8F%98%E7%A7%8D"><span class="toc-number">1.4.3.7.</span> <span class="toc-text">扩展：布隆过滤器的变种</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C-27"><span class="toc-number">1.4.3.8.</span> <span class="toc-text">测验</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.</span> <span class="toc-text">高级结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%B9%B6%E6%9F%A5%E9%9B%86-Union-Find"><span class="toc-number">1.5.1.</span> <span class="toc-text">一、并查集 (Union-Find)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3-28"><span class="toc-number">1.5.1.0.1.</span> <span class="toc-text">算法讲解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%88Union-Find%EF%BC%89"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">并查集（Union-Find）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-28"><span class="toc-number">1.5.1.1.1.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-28"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-27"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88MakeSet%EF%BC%89"><span class="toc-number">1.5.1.3.1.</span> <span class="toc-text">初始化（MakeSet）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%EF%BC%88Find%EF%BC%89"><span class="toc-number">1.5.1.3.2.</span> <span class="toc-text">查找（Find）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%EF%BC%88Union%EF%BC%89"><span class="toc-number">1.5.1.3.3.</span> <span class="toc-text">合并（Union）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-24"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-27"><span class="toc-number">1.5.1.5.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-18"><span class="toc-number">1.5.1.5.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-17"><span class="toc-number">1.5.1.5.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-28"><span class="toc-number">1.5.1.6.</span> <span class="toc-text">应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Kruskal%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.1.6.1.</span> <span class="toc-text">Kruskal最小生成树算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%BF%9E%E9%80%9A%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.1.6.2.</span> <span class="toc-text">网络连通性问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%92%E5%88%86"><span class="toc-number">1.5.1.6.3.</span> <span class="toc-text">等价类划分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%AD%E7%9A%84%E7%8E%AF"><span class="toc-number">1.5.1.6.4.</span> <span class="toc-text">判断无向图中的环</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C-28"><span class="toc-number">1.5.1.7.</span> <span class="toc-text">测验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%B7%B3%E8%A1%A8-Skip-List"><span class="toc-number">1.5.2.</span> <span class="toc-text">二、跳表 (Skip List)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3-29"><span class="toc-number">1.5.2.0.1.</span> <span class="toc-text">算法讲解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8%EF%BC%88Skip-List%EF%BC%89"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">跳表（Skip List）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-29"><span class="toc-number">1.5.2.1.1.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-29"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-28"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%9F%A5%E6%89%BE%EF%BC%88Search%EF%BC%89"><span class="toc-number">1.5.2.3.1.</span> <span class="toc-text">1. 查找（Search）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%8F%92%E5%85%A5%EF%BC%88Insert%EF%BC%89"><span class="toc-number">1.5.2.3.2.</span> <span class="toc-text">2. 插入（Insert）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%88%A0%E9%99%A4%EF%BC%88Delete%EF%BC%89"><span class="toc-number">1.5.2.3.3.</span> <span class="toc-text">3. 删除（Delete）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-25"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Java"><span class="toc-number">1.5.2.4.1.</span> <span class="toc-text">Java</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/11/24/Docker%E5%A4%87%E5%BF%98%E6%B8%85%E5%8D%95/" title="Docker备忘清单"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picgo.net/2024/12/07/16.9_Iamalex340f652ed853d658.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker备忘清单"/></a><div class="content"><a class="title" href="/2024/11/24/Docker%E5%A4%87%E5%BF%98%E6%B8%85%E5%8D%95/" title="Docker备忘清单">Docker备忘清单</a><time datetime="2024-11-24T11:47:12.000Z" title="发表于 2024-11-24 19:47:12">2024-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/24/Cmd%20%E5%A4%87%E5%BF%98%E6%B8%85%E5%8D%95/" title="cmd备忘清单"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picgo.net/2024/12/07/169_2_e662e95c-9e3a-43f1-9606-a58ae6cc0dcb876144533b806e72.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="cmd备忘清单"/></a><div class="content"><a class="title" href="/2024/11/24/Cmd%20%E5%A4%87%E5%BF%98%E6%B8%85%E5%8D%95/" title="cmd备忘清单">cmd备忘清单</a><time datetime="2024-11-24T11:47:12.000Z" title="发表于 2024-11-24 19:47:12">2024-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/24/Github%20%E5%A4%87%E5%BF%98%E6%B8%85%E5%8D%95/" title="Github 备忘清单"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picgo.net/2024/12/07/169_1ff49853-a0f4-47ed-93f2-4f475a0d42cbbdea83d694c47fc0.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Github 备忘清单"/></a><div class="content"><a class="title" href="/2024/11/24/Github%20%E5%A4%87%E5%BF%98%E6%B8%85%E5%8D%95/" title="Github 备忘清单">Github 备忘清单</a><time datetime="2024-11-24T11:47:12.000Z" title="发表于 2024-11-24 19:47:12">2024-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/24/ES2015+%20%E5%A4%87%E5%BF%98%E6%B8%85%E5%8D%95/" title="ES2015+ 备忘清单"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picgo.net/2024/12/07/169_3_7b5cba12-ac44-49d0-801a-4e2eff72a04cdf7afc3f3e8136a5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ES2015+ 备忘清单"/></a><div class="content"><a class="title" href="/2024/11/24/ES2015+%20%E5%A4%87%E5%BF%98%E6%B8%85%E5%8D%95/" title="ES2015+ 备忘清单">ES2015+ 备忘清单</a><time datetime="2024-11-24T11:47:12.000Z" title="发表于 2024-11-24 19:47:12">2024-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/24/C%E8%AF%AD%E8%A8%80%E7%BB%8F%E5%85%B8100%E4%BE%8B/" title="C语言经典100例"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picgo.net/2024/12/07/16_9_705655e0-03d6-4ba7-8b8c-ca3f2a81b3ac5ac2e8ae4394b197.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C语言经典100例"/></a><div class="content"><a class="title" href="/2024/11/24/C%E8%AF%AD%E8%A8%80%E7%BB%8F%E5%85%B8100%E4%BE%8B/" title="C语言经典100例">C语言经典100例</a><time datetime="2024-11-24T11:47:12.000Z" title="发表于 2024-11-24 19:47:12">2024-11-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://stellarium.org/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/posts/eec9786.html">魔改指南</a><a href="/box/nav/">网址导航</a></li><li><a href="/social/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/box/Gallery/">我的画廊</a><a href="/personal/bb/">我的唠叨</a></li><li><a href="/site/time/">建设进程</a><a href="/site/census/">网站统计</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a target="_blank" rel="noopener" href="https://stackoverflow.com/" title="stackoverflow"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon.png?v=c78bd457575a" alt=""/></a></div></div></div></div><div class="copyright"><span><b>&copy;2024 - 2026</b></span><span><b>&nbsp;&nbsp;By 宇仔</b></span></div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.</div><div id="workboard"></div><p id="ghbdages"></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i><span id="percent">0<span>%</span></span></button><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.33/fancybox/fancybox.umd.min.js"></script><script src="/js/instantpage.js" type="module"></script><script src="/js/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.8.0/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-liard-zeta.vercel.app',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-liard-zeta.vercel.app',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))

    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(init)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script defer src="/js/custom.js"></script><script defer src="/js/cursor.js"></script><script async src="//at.alicdn.com/t/font_2264842_b004iy0kk2b.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer data-pjax src="/js/readPercent.js"></script><script defer data-pjax src="/js/emoji.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script src="/js/share.js"></script><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async data-pjax src="/js/txmap.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer src="/js/runtime.js"></script><script async src="/js/console.js"></script><script async src="/js/title.js"></script><script id="canvas_nest" defer="defer" color="255,255,255" opacity="0.5" zIndex="-1" count="99" mobile="false" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/canvas-nest.min.js"></script><script id="click-heart" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/click-heart.min.js" async="async" mobile="true"></script><script>(() => {
  window.$crisp = [];
  window.CRISP_WEBSITE_ID = "a5ca0a84-595c-43f4-9bef-b5451d3b9034";
  (function () {
    d = document;
    s = d.createElement("script");
    s.src = "https://client.crisp.chat/l.js";
    s.async = 1;
    d.getElementsByTagName("head")[0].appendChild(s);
  })();
  $crisp.push(["safe", true])

  const isChatBtn = true
  const isChatHideShow = false

  if (isChatBtn) {
    const open = () => {
      $crisp.push(["do", "chat:show"])
      $crisp.push(["do", "chat:open"])
    }

    const close = () => {
      $crisp.push(["do", "chat:hide"])
    }

    close()
    $crisp.push(["on", "chat:closed", function() {
      close()
    }])

    window.chatBtnFn = () => {
      $crisp.is("chat:visible") ? close() : open()
    }
  } else if (isChatHideShow) {
    window.chatBtn = {
      hide: () => {
        $crisp.push(["do", "chat:hide"])
      },
      show: () => {
        $crisp.push(["do", "chat:show"])
      }
    }
  }
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://myj-2024.github.io/categories/C语言/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱 C语言学习 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://myj-2024.github.io/categories/Linux/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💻 Linux学习 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://myj-2024.github.io/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1s');
    arr[i].setAttribute('data-wow-delay', '700ms');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/11/24/MySQL常用语法/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picgo.net/2024/12/07/169_2_cbe9dbcf-fcb3-4aa8-ad14-7554c0cb4798c6160e3b810e4673.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-11-24</span><a class="blog-slider__title" href="2024/11/24/MySQL常用语法/" alt="">MySQL常用语法</a><div class="blog-slider__text">MySQL常用语法</div><a class="blog-slider__button" href="2024/11/24/MySQL常用语法/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/11/24/YUM 备忘清单/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picgo.net/2024/12/07/169_2_b4e389f3-454e-46ff-92ba-928bfa6ce59e29908f5b1527dcb7.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-11-24</span><a class="blog-slider__title" href="2024/11/24/YUM 备忘清单/" alt="">Yum备忘清单</a><div class="blog-slider__text">Yum备忘清单</div><a class="blog-slider__button" href="2024/11/24/YUM 备忘清单/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/11/24/Vue 3 备忘清单/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picgo.net/2024/12/07/16.9_Still9a6c5cbb75130a12.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-11-24</span><a class="blog-slider__title" href="2024/11/24/Vue 3 备忘清单/" alt="">Vue 3 备忘清单</a><div class="blog-slider__text">Vue 3 备忘清单</div><a class="blog-slider__button" href="2024/11/24/Vue 3 备忘清单/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/11/24/算法复杂度/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picgo.net/2024/12/07/16.9_Still9a6c5cbb75130a12.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-11-24</span><a class="blog-slider__title" href="2024/11/24/算法复杂度/" alt="">算法复杂度</a><div class="blog-slider__text">算法复杂度</div><a class="blog-slider__button" href="2024/11/24/算法复杂度/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/11/24/数据结构/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picgo.net/2024/12/07/169_1_5b886d18-cb55-4030-8238-9c911a3b887dac464e01b8713ae4.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-11-24</span><a class="blog-slider__title" href="2024/11/24/数据结构/" alt="">数据结构</a><div class="blog-slider__text">数据结构</div><a class="blog-slider__button" href="2024/11/24/数据结构/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/11/24/进阶算法/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picgo.net/2024/12/07/169_3_convert.io_1b1a0b531dd8e5437.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-11-24</span><a class="blog-slider__title" href="2024/11/24/进阶算法/" alt="">进阶算法</a><div class="blog-slider__text">进阶算法</div><a class="blog-slider__button" href="2024/11/24/进阶算法/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/11/24/基础算法/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picgo.net/2024/12/07/16_9_705655e0-03d6-4ba7-8b8c-ca3f2a81b3ac5ac2e8ae4394b197.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-11-24</span><a class="blog-slider__title" href="2024/11/24/基础算法/" alt="">基础算法</a><div class="blog-slider__text">基础算法</div><a class="blog-slider__button" href="2024/11/24/基础算法/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/11/24/linux常用命令大全/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picgo.net/2024/12/07/169_3_fcf607d8-0c9e-4f90-8e47-d5f393ccf3a4f03fa2166f23539f.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-11-24</span><a class="blog-slider__title" href="2024/11/24/linux常用命令大全/" alt="">Linux常用命令</a><div class="blog-slider__text">Linux常用命令</div><a class="blog-slider__button" href="2024/11/24/linux常用命令大全/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/11/24/NGINX 备忘清单/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picgo.net/2024/12/07/169_2_1695ac0d-2435-4d00-bbcf-f9b987af8c9c1ac1a3d4046a47db.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-11-24</span><a class="blog-slider__title" href="2024/11/24/NGINX 备忘清单/" alt="">Nginx备忘清单</a><div class="blog-slider__text">Nginx备忘清单</div><a class="blog-slider__button" href="2024/11/24/NGINX 备忘清单/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/11/24/Java经典算法50题/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picgo.net/2024/12/07/16_9_a5c9b6f0-8157-41a9-a20b-7e89517f5f8ba41f799f9e3259a2.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-11-24</span><a class="blog-slider__title" href="2024/11/24/Java经典算法50题/" alt="">Java经典算法50题</a><div class="blog-slider__text">Java经典算法50题</div><a class="blog-slider__button" href="2024/11/24/Java经典算法50题/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/11/24/Github 备忘清单/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picgo.net/2024/12/07/169_1ff49853-a0f4-47ed-93f2-4f475a0d42cbbdea83d694c47fc0.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-11-24</span><a class="blog-slider__title" href="2024/11/24/Github 备忘清单/" alt="">Github 备忘清单</a><div class="blog-slider__text">Github 备忘清单</div><a class="blog-slider__button" href="2024/11/24/Github 备忘清单/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/11/24/ES2015+ 备忘清单/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picgo.net/2024/12/07/169_3_7b5cba12-ac44-49d0-801a-4e2eff72a04cdf7afc3f3e8136a5.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-11-24</span><a class="blog-slider__title" href="2024/11/24/ES2015+ 备忘清单/" alt="">ES2015+ 备忘清单</a><div class="blog-slider__text">ES2015+ 备忘清单</div><a class="blog-slider__button" href="2024/11/24/ES2015+ 备忘清单/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/11/24/Docker备忘清单/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picgo.net/2024/12/07/16.9_Iamalex340f652ed853d658.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-11-24</span><a class="blog-slider__title" href="2024/11/24/Docker备忘清单/" alt="">Docker备忘清单</a><div class="blog-slider__text">Docker备忘清单</div><a class="blog-slider__button" href="2024/11/24/Docker备忘清单/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/11/24/Cmd 备忘清单/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picgo.net/2024/12/07/169_2_e662e95c-9e3a-43f1-9606-a58ae6cc0dcb876144533b806e72.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-11-24</span><a class="blog-slider__title" href="2024/11/24/Cmd 备忘清单/" alt="">cmd备忘清单</a><div class="blog-slider__text">cmd备忘清单</div><a class="blog-slider__button" href="2024/11/24/Cmd 备忘清单/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/11/24/Redis基础命令集详解/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picgo.net/2024/12/07/169_1_0480c1f7-1649-4102-9fb8-8f4819c2841882697633eb543817.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-11-24</span><a class="blog-slider__title" href="2024/11/24/Redis基础命令集详解/" alt="">Redis基础命令详解</a><div class="blog-slider__text">Redis基础命令详解</div><a class="blog-slider__button" href="2024/11/24/Redis基础命令集详解/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/11/24/Redis详解/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picgo.net/2024/12/07/16.9_Still9a6c5cbb75130a12.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-11-24</span><a class="blog-slider__title" href="2024/11/24/Redis详解/" alt="">Redis详解</a><div class="blog-slider__text">Redis详解</div><a class="blog-slider__button" href="2024/11/24/Redis详解/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/11/24/MySQL/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picgo.net/2024/12/07/169_1_1dcc9958-41f3-416d-b80a-b8be820f67430b82f2f4c399f3a1.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-11-24</span><a class="blog-slider__title" href="2024/11/24/MySQL/" alt="">MySQL</a><div class="blog-slider__text">MySQL</div><a class="blog-slider__button" href="2024/11/24/MySQL/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/11/24/C语言经典100例/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picgo.net/2024/12/07/16_9_705655e0-03d6-4ba7-8b8c-ca3f2a81b3ac5ac2e8ae4394b197.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-11-24</span><a class="blog-slider__title" href="2024/11/24/C语言经典100例/" alt="">C语言经典100例</a><div class="blog-slider__text">C语言经典100例</div><a class="blog-slider__button" href="2024/11/24/C语言经典100例/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>